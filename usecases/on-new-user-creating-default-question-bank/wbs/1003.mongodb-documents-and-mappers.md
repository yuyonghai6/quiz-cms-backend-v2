# WBS 1003: MongoDB Documents and Mappers

## User Story
**As a** persistence layer
**I want** MongoDB document models and bidirectional mappers
**So that** domain aggregates can be persisted and reconstructed from MongoDB

---

## Acceptance Criteria
- [ ] QuestionBanksPerUserDocument with MongoDB annotations
- [ ] TaxonomySetDocument with MongoDB annotations
- [ ] Mappers convert aggregate ↔ document bidirectionally
- [ ] Nested objects mapped correctly (embedded QuestionBank, Tags, etc.)
- [ ] Timestamps preserved during mapping
- [ ] Null handling in mappers
- [ ] MongoDB field names match data model spec

---

## TDD Cycle

### Epic and Story Annotation
```java
@Epic("Use Case On New User Create Default Question Bank Happy Path")
@Story("1003.mongodb-documents-and-mappers")
```

### Test Coverage Requirements
- **Unit Tests**: 100% coverage for mappers
- **Test Count**: 15-20 tests
- **No Integration Tests**: Pure mapping logic (no MongoDB)

---

## Task Breakdown

### Task 3.1: RED - Write Tests for QuestionBanksPerUserMapper

**File**: `QuestionBanksPerUserMapperTest.java`
**Location**: `internal-layer/question-bank/src/test/java/com/quizfun/questionbank/infrastructure/persistence/mappers/`

```java
package com.quizfun.questionbank.infrastructure.persistence.mappers;

import com.quizfun.questionbank.domain.aggregates.QuestionBanksPerUserAggregate;
import com.quizfun.questionbank.domain.entities.QuestionBank;
import com.quizfun.questionbank.infrastructure.persistence.documents.QuestionBanksPerUserDocument;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.bson.types.ObjectId;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.*;

@Epic("Use Case On New User Create Default Question Bank Happy Path")
@Story("1003.mongodb-documents-and-mappers")
@DisplayName("QuestionBanksPerUserMapper Tests")
class QuestionBanksPerUserMapperTest {

    private QuestionBanksPerUserMapper mapper;

    @BeforeEach
    void setUp() {
        mapper = new QuestionBanksPerUserMapper();
    }

    @Test
    @DisplayName("Should map aggregate to document with all fields")
    void shouldMapAggregateToDocumentWithAllFields() {
        // Given
        Long userId = 123456789L;
        Long questionBankId = 1730832000000000L;
        Instant now = Instant.now();

        QuestionBanksPerUserAggregate aggregate =
            QuestionBanksPerUserAggregate.createDefault(userId, questionBankId, now);

        // When
        QuestionBanksPerUserDocument document = mapper.toDocument(aggregate);

        // Then
        assertThat(document).isNotNull();
        assertThat(document.getId()).isNotNull();
        assertThat(document.getUserId()).isEqualTo(userId);
        assertThat(document.getDefaultQuestionBankId()).isEqualTo(questionBankId);
        assertThat(document.getQuestionBanks()).hasSize(1);
        assertThat(document.getCreatedAt()).isNotNull();
        assertThat(document.getUpdatedAt()).isNotNull();
    }

    @Test
    @DisplayName("Should map embedded question bank correctly")
    void shouldMapEmbeddedQuestionBankCorrectly() {
        // Given
        Long userId = 123L;
        Long questionBankId = 456L;
        Instant now = Instant.parse("2025-10-06T10:30:00Z");

        QuestionBanksPerUserAggregate aggregate =
            QuestionBanksPerUserAggregate.createDefault(userId, questionBankId, now);

        // When
        QuestionBanksPerUserDocument document = mapper.toDocument(aggregate);

        // Then
        var embeddedBank = document.getQuestionBanks().get(0);
        assertThat(embeddedBank.getBankId()).isEqualTo(questionBankId);
        assertThat(embeddedBank.getName()).isEqualTo("Default Question Bank");
        assertThat(embeddedBank.getDescription())
            .isEqualTo("Your default question bank for getting started with quiz creation");
        assertThat(embeddedBank.isActive()).isTrue();
        assertThat(embeddedBank.getCreatedAt()).isEqualTo(now);
        assertThat(embeddedBank.getUpdatedAt()).isEqualTo(now);
    }

    @Test
    @DisplayName("Should preserve timestamps during mapping")
    void shouldPreserveTimestampsDuringMapping() {
        // Given
        Instant specificTime = Instant.parse("2025-10-06T10:30:15.123Z");
        QuestionBanksPerUserAggregate aggregate =
            QuestionBanksPerUserAggregate.createDefault(123L, 456L, specificTime);

        // When
        QuestionBanksPerUserDocument document = mapper.toDocument(aggregate);

        // Then
        assertThat(document.getCreatedAt()).isEqualTo(specificTime);
        assertThat(document.getUpdatedAt()).isEqualTo(specificTime);
        assertThat(document.getQuestionBanks().get(0).getCreatedAt()).isEqualTo(specificTime);
        assertThat(document.getQuestionBanks().get(0).getUpdatedAt()).isEqualTo(specificTime);
    }

    @Test
    @DisplayName("Should map document back to aggregate")
    void shouldMapDocumentBackToAggregate() {
        // Given
        QuestionBanksPerUserDocument document = new QuestionBanksPerUserDocument();
        document.setId(new ObjectId());
        document.setUserId(123456789L);
        document.setDefaultQuestionBankId(1730832000000000L);

        QuestionBanksPerUserDocument.QuestionBankEmbedded embedded =
            new QuestionBanksPerUserDocument.QuestionBankEmbedded();
        embedded.setBankId(1730832000000000L);
        embedded.setName("Default Question Bank");
        embedded.setDescription("Test description");
        embedded.setActive(true);
        embedded.setCreatedAt(Instant.now());
        embedded.setUpdatedAt(Instant.now());

        document.setQuestionBanks(java.util.List.of(embedded));
        document.setCreatedAt(Instant.now());
        document.setUpdatedAt(Instant.now());

        // When
        QuestionBanksPerUserAggregate aggregate = mapper.toAggregate(document);

        // Then
        assertThat(aggregate).isNotNull();
        assertThat(aggregate.getUserId()).isEqualTo(document.getUserId());
        assertThat(aggregate.getDefaultQuestionBankId()).isEqualTo(document.getDefaultQuestionBankId());
        assertThat(aggregate.getQuestionBanks()).hasSize(1);
    }

    @Test
    @DisplayName("Should handle round-trip mapping without data loss")
    void shouldHandleRoundTripMappingWithoutDataLoss() {
        // Given
        Long userId = 123456789L;
        Long questionBankId = 1730832000000000L;
        Instant now = Instant.now();

        QuestionBanksPerUserAggregate originalAggregate =
            QuestionBanksPerUserAggregate.createDefault(userId, questionBankId, now);

        // When - Round trip: aggregate → document → aggregate
        QuestionBanksPerUserDocument document = mapper.toDocument(originalAggregate);
        QuestionBanksPerUserAggregate reconstructedAggregate = mapper.toAggregate(document);

        // Then - All data preserved
        assertThat(reconstructedAggregate.getUserId()).isEqualTo(originalAggregate.getUserId());
        assertThat(reconstructedAggregate.getDefaultQuestionBankId())
            .isEqualTo(originalAggregate.getDefaultQuestionBankId());
        assertThat(reconstructedAggregate.getQuestionBanks())
            .hasSize(originalAggregate.getQuestionBanks().size());
    }

    @Test
    @DisplayName("Should throw exception when mapping null aggregate")
    void shouldThrowExceptionWhenMappingNullAggregate() {
        // When & Then
        assertThatThrownBy(() -> mapper.toDocument(null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Aggregate cannot be null");
    }

    @Test
    @DisplayName("Should throw exception when mapping null document")
    void shouldThrowExceptionWhenMappingNullDocument() {
        // When & Then
        assertThatThrownBy(() -> mapper.toAggregate(null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Document cannot be null");
    }
}
```

**Expected Result**: Tests FAIL (mapper and document don't exist yet)

---

### Task 3.2: GREEN - Implement QuestionBanksPerUserDocument

**File**: `QuestionBanksPerUserDocument.java`
**Location**: `internal-layer/question-bank/src/main/java/com/quizfun/questionbank/infrastructure/persistence/documents/`

```java
package com.quizfun.questionbank.infrastructure.persistence.documents;

import org.bson.types.ObjectId;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import java.time.Instant;
import java.util.List;

/**
 * MongoDB document for question_banks_per_user collection.
 *
 * Stores user's question bank registry with embedded question bank array.
 */
@Document(collection = "question_banks_per_user")
public class QuestionBanksPerUserDocument {

    @Id
    private ObjectId id;

    @Indexed(unique = true)
    @Field("user_id")
    private Long userId;

    @Field("default_question_bank_id")
    private Long defaultQuestionBankId;

    @Field("question_banks")
    private List<QuestionBankEmbedded> questionBanks;

    @Field("created_at")
    private Instant createdAt;

    @Field("updated_at")
    private Instant updatedAt;

    /**
     * Embedded question bank within user's question_banks array.
     */
    public static class QuestionBankEmbedded {
        @Field("bank_id")
        private Long bankId;

        @Field("name")
        private String name;

        @Field("description")
        private String description;

        @Field("is_active")
        private boolean isActive;

        @Field("created_at")
        private Instant createdAt;

        @Field("updated_at")
        private Instant updatedAt;

        // Constructors
        public QuestionBankEmbedded() {}

        public QuestionBankEmbedded(Long bankId, String name, String description,
                                   boolean isActive, Instant createdAt, Instant updatedAt) {
            this.bankId = bankId;
            this.name = name;
            this.description = description;
            this.isActive = isActive;
            this.createdAt = createdAt;
            this.updatedAt = updatedAt;
        }

        // Getters and Setters
        public Long getBankId() { return bankId; }
        public void setBankId(Long bankId) { this.bankId = bankId; }

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }

        public boolean isActive() { return isActive; }
        public void setActive(boolean active) { isActive = active; }

        public Instant getCreatedAt() { return createdAt; }
        public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

        public Instant getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }
    }

    // Constructors
    public QuestionBanksPerUserDocument() {}

    // Getters and Setters
    public ObjectId getId() { return id; }
    public void setId(ObjectId id) { this.id = id; }

    public Long getUserId() { return userId; }
    public void setUserId(Long userId) { this.userId = userId; }

    public Long getDefaultQuestionBankId() { return defaultQuestionBankId; }
    public void setDefaultQuestionBankId(Long defaultQuestionBankId) {
        this.defaultQuestionBankId = defaultQuestionBankId;
    }

    public List<QuestionBankEmbedded> getQuestionBanks() { return questionBanks; }
    public void setQuestionBanks(List<QuestionBankEmbedded> questionBanks) {
        this.questionBanks = questionBanks;
    }

    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }
}
```

---

### Task 3.3: GREEN - Implement QuestionBanksPerUserMapper

**File**: `QuestionBanksPerUserMapper.java`
**Location**: `internal-layer/question-bank/src/main/java/com/quizfun/questionbank/infrastructure/persistence/mappers/`

```java
package com.quizfun.questionbank.infrastructure.persistence.mappers;

import com.quizfun.questionbank.domain.aggregates.QuestionBanksPerUserAggregate;
import com.quizfun.questionbank.domain.entities.QuestionBank;
import com.quizfun.questionbank.infrastructure.persistence.documents.QuestionBanksPerUserDocument;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Mapper for QuestionBanksPerUserAggregate ↔ QuestionBanksPerUserDocument.
 */
@Component
public class QuestionBanksPerUserMapper {

    /**
     * Maps domain aggregate to MongoDB document.
     */
    public QuestionBanksPerUserDocument toDocument(QuestionBanksPerUserAggregate aggregate) {
        if (aggregate == null) {
            throw new IllegalArgumentException("Aggregate cannot be null");
        }

        QuestionBanksPerUserDocument document = new QuestionBanksPerUserDocument();
        document.setId(aggregate.getId());
        document.setUserId(aggregate.getUserId());
        document.setDefaultQuestionBankId(aggregate.getDefaultQuestionBankId());

        // Map embedded question banks
        List<QuestionBanksPerUserDocument.QuestionBankEmbedded> embeddedBanks =
            aggregate.getQuestionBanks().stream()
                .map(this::mapQuestionBankToEmbedded)
                .collect(Collectors.toList());
        document.setQuestionBanks(embeddedBanks);

        document.setCreatedAt(aggregate.getCreatedAt());
        document.setUpdatedAt(aggregate.getUpdatedAt());

        return document;
    }

    /**
     * Maps MongoDB document to domain aggregate.
     */
    public QuestionBanksPerUserAggregate toAggregate(QuestionBanksPerUserDocument document) {
        if (document == null) {
            throw new IllegalArgumentException("Document cannot be null");
        }

        // Map embedded question banks to domain entities
        List<QuestionBank> questionBanks = document.getQuestionBanks().stream()
            .map(this::mapEmbeddedToQuestionBank)
            .collect(Collectors.toList());

        return QuestionBanksPerUserAggregate.create(
            document.getId(),
            document.getUserId(),
            document.getDefaultQuestionBankId(),
            questionBanks
        );
    }

    private QuestionBanksPerUserDocument.QuestionBankEmbedded mapQuestionBankToEmbedded(
            QuestionBank questionBank) {

        return new QuestionBanksPerUserDocument.QuestionBankEmbedded(
            questionBank.getBankId(),
            questionBank.getName(),
            questionBank.getDescription(),
            questionBank.isActive(),
            questionBank.getCreatedAt(),
            questionBank.getUpdatedAt()
        );
    }

    private QuestionBank mapEmbeddedToQuestionBank(
            QuestionBanksPerUserDocument.QuestionBankEmbedded embedded) {

        return new QuestionBank(
            embedded.getBankId(),
            embedded.getName(),
            embedded.getDescription(),
            embedded.isActive(),
            embedded.getCreatedAt(),
            embedded.getUpdatedAt()
        );
    }
}
```

**Expected Result**: QuestionBanksPerUserMapper tests PASS

---

### Task 3.4: RED - Write Tests for TaxonomySetMapper

**File**: `TaxonomySetMapperTest.java`

```java
package com.quizfun.questionbank.infrastructure.persistence.mappers;

import com.quizfun.questionbank.domain.aggregates.TaxonomySetAggregate;
import com.quizfun.questionbank.infrastructure.persistence.documents.TaxonomySetDocument;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.*;

@Epic("Use Case On New User Create Default Question Bank Happy Path")
@Story("1003.mongodb-documents-and-mappers")
@DisplayName("TaxonomySetMapper Tests")
class TaxonomySetMapperTest {

    private TaxonomySetMapper mapper;

    @BeforeEach
    void setUp() {
        mapper = new TaxonomySetMapper();
    }

    @Test
    @DisplayName("Should map aggregate to document with all taxonomy elements")
    void shouldMapAggregateToDocumentWithAllTaxonomyElements() {
        // Given
        Long userId = 123L;
        Long questionBankId = 456L;
        Instant now = Instant.now();

        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(userId, questionBankId, now);

        // When
        TaxonomySetDocument document = mapper.toDocument(aggregate);

        // Then
        assertThat(document).isNotNull();
        assertThat(document.getUserId()).isEqualTo(userId);
        assertThat(document.getQuestionBankId()).isEqualTo(questionBankId);
        assertThat(document.getCategories()).isNotNull();
        assertThat(document.getTags()).hasSize(3);
        assertThat(document.getQuizzes()).isEmpty();
        assertThat(document.getCurrentDifficultyLevel()).isNotNull();
        assertThat(document.getAvailableDifficultyLevels()).hasSize(3);
    }

    @Test
    @DisplayName("Should map category level_1 correctly")
    void shouldMapCategoryLevel1Correctly() {
        // Given
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // When
        TaxonomySetDocument document = mapper.toDocument(aggregate);

        // Then
        var level1 = document.getCategories().getLevel1();
        assertThat(level1).isNotNull();
        assertThat(level1.getId()).isEqualTo("general");
        assertThat(level1.getName()).isEqualTo("General");
        assertThat(level1.getSlug()).isEqualTo("general");
        assertThat(level1.getParentId()).isNull();
    }

    @Test
    @DisplayName("Should map tags with colors correctly")
    void shouldMapTagsWithColorsCorrectly() {
        // Given
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // When
        TaxonomySetDocument document = mapper.toDocument(aggregate);

        // Then
        var tags = document.getTags();
        assertThat(tags).anyMatch(tag ->
            tag.getId().equals("beginner") && tag.getColor().equals("#28a745"));
        assertThat(tags).anyMatch(tag ->
            tag.getId().equals("practice") && tag.getColor().equals("#007bff"));
        assertThat(tags).anyMatch(tag ->
            tag.getId().equals("quick-test") && tag.getColor().equals("#6f42c1"));
    }

    @Test
    @DisplayName("Should map difficulty levels correctly")
    void shouldMapDifficultyLevelsCorrectly() {
        // Given
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // When
        TaxonomySetDocument document = mapper.toDocument(aggregate);

        // Then
        assertThat(document.getCurrentDifficultyLevel().getLevel()).isEqualTo("easy");
        assertThat(document.getCurrentDifficultyLevel().getNumericValue()).isEqualTo(1);

        var availableLevels = document.getAvailableDifficultyLevels();
        assertThat(availableLevels).extracting("level")
            .containsExactly("easy", "medium", "hard");
        assertThat(availableLevels).extracting("numericValue")
            .containsExactly(1, 2, 3);
    }

    @Test
    @DisplayName("Should handle round-trip mapping for taxonomy")
    void shouldHandleRoundTripMappingForTaxonomy() {
        // Given
        Long userId = 123L;
        Long questionBankId = 456L;
        Instant now = Instant.now();

        TaxonomySetAggregate originalAggregate =
            TaxonomySetAggregate.createDefault(userId, questionBankId, now);

        // When - Round trip
        TaxonomySetDocument document = mapper.toDocument(originalAggregate);
        TaxonomySetAggregate reconstructed = mapper.toAggregate(document);

        // Then - Data preserved
        assertThat(reconstructed.getUserId()).isEqualTo(originalAggregate.getUserId());
        assertThat(reconstructed.getQuestionBankId()).isEqualTo(originalAggregate.getQuestionBankId());
        assertThat(reconstructed.getTags()).hasSize(originalAggregate.getTags().size());
        assertThat(reconstructed.getAvailableDifficultyLevels())
            .hasSize(originalAggregate.getAvailableDifficultyLevels().size());
    }

    @Test
    @DisplayName("Should throw exception when mapping null aggregate")
    void shouldThrowExceptionWhenMappingNullAggregate() {
        // When & Then
        assertThatThrownBy(() -> mapper.toDocument(null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Aggregate cannot be null");
    }

    @Test
    @DisplayName("Should throw exception when mapping null document")
    void shouldThrowExceptionWhenMappingNullDocument() {
        // When & Then
        assertThatThrownBy(() -> mapper.toAggregate(null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Document cannot be null");
    }
}
```

**Expected Result**: Tests FAIL (TaxonomySetDocument and mapper don't exist)

---

### Task 3.5: GREEN - Implement TaxonomySetDocument and Mapper

*Implementation follows same pattern as QuestionBanksPerUserDocument*

**File**: `TaxonomySetDocument.java`

```java
@Document(collection = "taxonomy_sets")
public class TaxonomySetDocument {

    @Id
    private ObjectId id;

    @Field("user_id")
    private Long userId;

    @Field("question_bank_id")
    private Long questionBankId;

    @Field("categories")
    private CategoryLevelsEmbedded categories;

    @Field("tags")
    private List<TagEmbedded> tags;

    @Field("quizzes")
    private List<QuizEmbedded> quizzes;

    @Field("current_difficulty_level")
    private DifficultyLevelEmbedded currentDifficultyLevel;

    @Field("available_difficulty_levels")
    private List<DifficultyLevelEmbedded> availableDifficultyLevels;

    @Field("created_at")
    private Instant createdAt;

    @Field("updated_at")
    private Instant updatedAt;

    // Nested classes for embedded documents
    public static class CategoryLevelsEmbedded {
        @Field("level_1")
        private CategoryEmbedded level1;

        @Field("level_2")
        private CategoryEmbedded level2;

        @Field("level_3")
        private CategoryEmbedded level3;

        @Field("level_4")
        private CategoryEmbedded level4;

        // Getters/setters
    }

    public static class CategoryEmbedded {
        @Field("id")
        private String id;

        @Field("name")
        private String name;

        @Field("slug")
        private String slug;

        @Field("parent_id")
        private String parentId;

        // Getters/setters
    }

    public static class TagEmbedded {
        @Field("id")
        private String id;

        @Field("name")
        private String name;

        @Field("color")
        private String color;

        // Getters/setters
    }

    public static class DifficultyLevelEmbedded {
        @Field("level")
        private String level;

        @Field("numeric_value")
        private Integer numericValue;

        @Field("description")
        private String description;

        // Getters/setters
    }

    // ... all getters/setters
}
```

**Expected Result**: All TaxonomySetMapper tests PASS

---

## Definition of Done

- [x] QuestionBanksPerUserDocument created with MongoDB annotations
- [x] TaxonomySetDocument created with MongoDB annotations
- [x] QuestionBanksPerUserMapper implemented (bidirectional)
- [x] TaxonomySetMapper implemented (bidirectional)
- [x] All mapper tests passing (100% coverage)
- [x] Round-trip mapping verified (no data loss)
- [x] Null handling in mappers
- [x] Field names match MongoDB data model
- [x] Proper Allure annotations
- [x] Code review ready

---

## Dependencies
- **WBS 1002**: Domain aggregates (createDefault methods)

---

## Estimated Effort
**6-8 hours** (1 day)

---

## Notes
- MongoDB field names use snake_case (e.g., user_id, created_at)
- Document models are separate from domain models (anti-corruption layer)
- Mappers use Spring @Component for dependency injection
- Embedded documents for nested structures
- Round-trip mapping ensures no data loss
