# US-002: Question Domain Aggregate Implementation

## Story Overview
**As a** content creator
**I want** the system to properly model question domain logic with business rules
**So that** questions are created and updated according to business requirements with proper audit trail

## Business Value
- Ensures question data integrity through domain rules
- Provides audit trail through domain events
- Enables different question types with type-specific data
- Maintains business logic encapsulation in domain layer

## Work Breakdown Structure (WBS)

### 1. Domain Event Infrastructure
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: US-000 complete

#### Tasks:
- [ ] **1.1** Create question-specific domain events
- [ ] **1.2** Implement QuestionCreatedEvent
- [ ] **1.3** Implement QuestionUpdatedEvent
- [ ] **1.4** Add event metadata and context
- [ ] **1.5** Configure event serialization

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/events/QuestionCreatedEvent.java
public class QuestionCreatedEvent extends BaseDomainEvent {
    private final String sourceQuestionId;
    private final QuestionType questionType;
    private final Long userId;
    private final Long questionBankId;

    public QuestionCreatedEvent(String aggregateId, String sourceQuestionId,
                               QuestionType questionType, Long userId, Long questionBankId) {
        super("QuestionCreated", aggregateId);
        this.sourceQuestionId = sourceQuestionId;
        this.questionType = questionType;
        this.userId = userId;
        this.questionBankId = questionBankId;
    }
}

// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/events/QuestionUpdatedEvent.java
public class QuestionUpdatedEvent extends BaseDomainEvent {
    private final String sourceQuestionId;
    private final String previousTitle;
    private final String newTitle;

    public QuestionUpdatedEvent(String aggregateId, String sourceQuestionId,
                               String previousTitle, String newTitle) {
        super("QuestionUpdated", aggregateId);
        this.sourceQuestionId = sourceQuestionId;
        this.previousTitle = previousTitle;
        this.newTitle = newTitle;
    }
}
```

#### Acceptance Criteria:
- Domain events capture relevant business information
- Events include proper metadata and context
- Event serialization works correctly
- Events follow domain event patterns

#### Test Requirements:
- [ ] Unit test: QuestionCreatedEvent creation and properties
- [ ] Unit test: QuestionUpdatedEvent creation and properties
- [ ] Unit test: Event serialization/deserialization
- [ ] Unit test: Event metadata validation

---

### 2. Question Type Enumeration and Value Objects
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 1 complete

#### Tasks:
- [ ] **2.1** Create QuestionType enumeration
- [ ] **2.2** Implement type-specific data value objects
  - [ ] McqData value object
  - [ ] EssayData value object
  - [ ] TrueFalseData value object
- [ ] **2.3** Add validation for each value object
- [ ] **2.4** Implement equals/hashCode for value objects
- [ ] **2.5** Add JSON serialization support

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/entities/QuestionType.java
public enum QuestionType {
    MCQ("mcq"),
    ESSAY("essay"),
    TRUE_FALSE("true_false");

    private final String value;

    QuestionType(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}

// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/entities/McqData.java
public class McqData {
    private final List<McqOption> options;
    private final boolean shuffleOptions;
    private final boolean allowMultipleCorrect;
    private final boolean allowPartialCredit;
    private final Integer timeLimitSeconds;

    public McqData(List<McqOption> options, boolean shuffleOptions,
                   boolean allowMultipleCorrect, boolean allowPartialCredit,
                   Integer timeLimitSeconds) {
        this.options = validateOptions(options);
        this.shuffleOptions = shuffleOptions;
        this.allowMultipleCorrect = allowMultipleCorrect;
        this.allowPartialCredit = allowPartialCredit;
        this.timeLimitSeconds = timeLimitSeconds;
    }

    private List<McqOption> validateOptions(List<McqOption> options) {
        if (options == null || options.isEmpty()) {
            throw new IllegalArgumentException("MCQ must have at least one option");
        }

        boolean hasCorrectAnswer = options.stream().anyMatch(McqOption::isCorrect);
        if (!hasCorrectAnswer) {
            throw new IllegalArgumentException("MCQ must have at least one correct answer");
        }

        return new ArrayList<>(options);
    }
}
```

#### Acceptance Criteria:
- QuestionType enumeration covers all supported types
- Value objects are immutable and validated
- Type-specific validation rules enforced
- JSON serialization supported

#### TDD Cycle and Verification Approach:

**Red Phase (Write Failing Tests First):**
```java
class QuestionTypeValueObjectsTest {

    @Nested
    @DisplayName("MCQ Data Tests")
    class McqDataTests {

        @Test
        @DisplayName("Should create valid MCQ data with correct options")
        void shouldCreateValidMcqDataWithCorrectOptions() {
            var options = List.of(
                new McqOption("A", "Option A", true, 1.0),
                new McqOption("B", "Option B", false, 0.0)
            );

            var mcqData = new McqData(options, true, false, false, 300);

            assertThat(mcqData.getOptions()).hasSize(2);
            assertThat(mcqData.isShuffleOptions()).isTrue();
            assertThat(mcqData.hasCorrectAnswer()).isTrue();
        }

        @Test
        @DisplayName("Should reject MCQ data without correct answers")
        void shouldRejectMcqDataWithoutCorrectAnswers() {
            var options = List.of(
                new McqOption("A", "Option A", false, 0.0),
                new McqOption("B", "Option B", false, 0.0)
            );

            assertThatThrownBy(() ->
                new McqData(options, true, false, false, 300)
            ).isInstanceOf(IllegalArgumentException.class)
             .hasMessageContaining("must have at least one correct answer");
        }

        @Test
        @DisplayName("Should be immutable value object")
        void shouldBeImmutableValueObject() {
            var options = new ArrayList<>(List.of(
                new McqOption("A", "Option A", true, 1.0)
            ));

            var mcqData = new McqData(options, true, false, false, 300);
            options.clear(); // Modify original list

            assertThat(mcqData.getOptions()).hasSize(1); // Should be unaffected
        }
    }

    @Nested
    @DisplayName("Essay Data Tests")
    class EssayDataTests {

        @Test
        @DisplayName("Should create valid essay data with rubric")
        void shouldCreateValidEssayDataWithRubric() {
            var rubric = new EssayRubric(
                "Demonstrates understanding",
                List.of("Grammar", "Content", "Structure"),
                1000
            );

            var essayData = new EssayData(
                1000, 5000, true, rubric
            );

            assertThat(essayData.getMinWordCount()).isEqualTo(1000);
            assertThat(essayData.getMaxWordCount()).isEqualTo(5000);
            assertThat(essayData.isAllowRichText()).isTrue();
            assertThat(essayData.getRubric()).isEqualTo(rubric);
        }

        @Test
        @DisplayName("Should reject invalid word count ranges")
        void shouldRejectInvalidWordCountRanges() {
            assertThatThrownBy(() ->
                new EssayData(5000, 1000, true, null) // min > max
            ).isInstanceOf(IllegalArgumentException.class)
             .hasMessageContaining("minimum word count cannot exceed maximum");
        }
    }
}
```

**Green Phase (Minimal Implementation):**
- Implement basic value objects with validation
- Add immutability and proper equals/hashCode
- Ensure type safety

**Refactor Phase:**
- Optimize validation logic
- Add comprehensive business rules
- Improve error messages

**Verification Criteria:**
- [ ] All value object tests pass (100% coverage)
- [ ] Immutability verified through mutation testing
- [ ] Equals/hashCode contract verified
- [ ] Performance: Object creation <50Âµs

---

### 3. QuestionAggregate Core Implementation
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: Task 2 complete

#### Tasks:
- [ ] **3.1** Design QuestionAggregate class structure
- [ ] **3.2** Implement core properties and fields
- [ ] **3.3** Add constructor with validation
- [ ] **3.4** Implement business rule validation
- [ ] **3.5** Add type-specific data handling
- [ ] **3.6** Implement audit trail fields

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/aggregates/QuestionAggregate.java
public class QuestionAggregate extends AggregateRoot {
    private ObjectId id;
    private Long userId;
    private Long questionBankId;
    private String sourceQuestionId;
    private QuestionType questionType;
    private String title;
    private String content;
    private Integer points;
    private String status;
    private Integer displayOrder;
    private String solutionExplanation;

    // Type-specific data
    private McqData mcqData;
    private EssayData essayData;
    private TrueFalseData trueFalseData;

    // Metadata and settings
    private List<Attachment> attachments;
    private QuestionSettings questionSettings;
    private QuestionMetadata metadata;

    // Audit fields
    private Instant createdAt;
    private Instant updatedAt;
    private Instant publishedAt;
    private Instant archivedAt;

    // Private constructor to enforce factory methods
    private QuestionAggregate() {}

    public static QuestionAggregate createNew(Long userId, Long questionBankId,
                                            String sourceQuestionId, QuestionType questionType,
                                            String title, String content, Integer points) {
        var aggregate = new QuestionAggregate();

        // Validate required fields
        aggregate.validateRequiredFields(userId, questionBankId, sourceQuestionId,
                                       questionType, title, content);

        // Set core properties
        aggregate.userId = userId;
        aggregate.questionBankId = questionBankId;
        aggregate.sourceQuestionId = sourceQuestionId;
        aggregate.questionType = questionType;
        aggregate.title = title;
        aggregate.content = content;
        aggregate.points = points != null ? points : 0;
        aggregate.status = "draft";
        aggregate.createdAt = Instant.now();
        aggregate.updatedAt = Instant.now();

        // Generate domain event
        aggregate.addDomainEvent(new QuestionCreatedEvent(
            aggregate.id != null ? aggregate.id.toString() : UUID.randomUUID().toString(),
            aggregate.sourceQuestionId,
            aggregate.questionType,
            aggregate.userId,
            aggregate.questionBankId
        ));

        return aggregate;
    }

    private void validateRequiredFields(Long userId, Long questionBankId,
                                      String sourceQuestionId, QuestionType questionType,
                                      String title, String content) {
        if (userId == null) {
            throw new IllegalArgumentException("User ID is required");
        }
        if (questionBankId == null) {
            throw new IllegalArgumentException("Question bank ID is required");
        }
        if (sourceQuestionId == null || sourceQuestionId.trim().isEmpty()) {
            throw new IllegalArgumentException("Source question ID is required");
        }
        if (questionType == null) {
            throw new IllegalArgumentException("Question type is required");
        }
        if (title == null || title.trim().isEmpty()) {
            throw new IllegalArgumentException("Question title is required");
        }
        if (content == null || content.trim().isEmpty()) {
            throw new IllegalArgumentException("Question content is required");
        }
    }
}
```

#### Acceptance Criteria:
- QuestionAggregate extends AggregateRoot properly
- Required field validation enforced
- Factory method prevents invalid creation
- Core properties properly encapsulated
- Business rules validated at creation

#### TDD Cycle and Verification Approach:

**Red Phase (Write Failing Tests First):**
```java
@ExtendWith(MockitoExtension.class)
class QuestionAggregateCoreImplementationTest {

    @Test
    @DisplayName("Should create new question with valid data")
    void shouldCreateNewQuestionWithValidData() {
        // Test will fail initially - QuestionAggregate doesn't exist yet
        var aggregate = QuestionAggregate.createNew(
            1001L, 2002L, "Q123", QuestionType.MCQ,
            "What is 2+2?", "Choose the correct answer", 5
        );

        assertThat(aggregate.getUserId()).isEqualTo(1001L);
        assertThat(aggregate.getQuestionBankId()).isEqualTo(2002L);
        assertThat(aggregate.getSourceQuestionId()).isEqualTo("Q123");
        assertThat(aggregate.getQuestionType()).isEqualTo(QuestionType.MCQ);
        assertThat(aggregate.getTitle()).isEqualTo("What is 2+2?");
        assertThat(aggregate.getContent()).isEqualTo("Choose the correct answer");
        assertThat(aggregate.getPoints()).isEqualTo(5);
        assertThat(aggregate.getStatus()).isEqualTo("draft");
        assertThat(aggregate.getCreatedAt()).isNotNull();
        assertThat(aggregate.getUpdatedAt()).isNotNull();
    }

    @Test
    @DisplayName("Should set default values for optional fields")
    void shouldSetDefaultValuesForOptionalFields() {
        var aggregate = QuestionAggregate.createNew(
            1001L, 2002L, "Q123", QuestionType.MCQ,
            "Test Question", "Test Content", null
        );

        assertThat(aggregate.getPoints()).isEqualTo(0);
        assertThat(aggregate.getStatus()).isEqualTo("draft");
        assertThat(aggregate.getDisplayOrder()).isNull();
        assertThat(aggregate.getPublishedAt()).isNull();
        assertThat(aggregate.getArchivedAt()).isNull();
    }

    @ParameterizedTest
    @ValueSource(longs = {0L, -1L})
    @NullSource
    @DisplayName("Should reject invalid user IDs")
    void shouldRejectInvalidUserIds(Long invalidUserId) {
        assertThatThrownBy(() ->
            QuestionAggregate.createNew(
                invalidUserId, 2002L, "Q123", QuestionType.MCQ,
                "Test Question", "Test Content", 5
            )
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("User ID is required");
    }

    @ParameterizedTest
    @ValueSource(strings = {"", " ", "   "})
    @NullSource
    @DisplayName("Should reject invalid source question IDs")
    void shouldRejectInvalidSourceQuestionIds(String invalidSourceId) {
        assertThatThrownBy(() ->
            QuestionAggregate.createNew(
                1001L, 2002L, invalidSourceId, QuestionType.MCQ,
                "Test Question", "Test Content", 5
            )
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Source question ID is required");
    }

    @Test
    @DisplayName("Should generate QuestionCreatedEvent on creation")
    void shouldGenerateQuestionCreatedEventOnCreation() {
        var aggregate = QuestionAggregate.createNew(
            1001L, 2002L, "Q123", QuestionType.MCQ,
            "Test Question", "Test Content", 5
        );

        var events = aggregate.getUncommittedEvents();
        assertThat(events).hasSize(1);

        var event = events.get(0);
        assertThat(event).isInstanceOf(QuestionCreatedEvent.class);

        var createdEvent = (QuestionCreatedEvent) event;
        assertThat(createdEvent.getSourceQuestionId()).isEqualTo("Q123");
        assertThat(createdEvent.getQuestionType()).isEqualTo(QuestionType.MCQ);
        assertThat(createdEvent.getUserId()).isEqualTo(1001L);
        assertThat(createdEvent.getQuestionBankId()).isEqualTo(2002L);
    }

    @Test
    @DisplayName("Should enforce immutability of core properties")
    void shouldEnforceImmutabilityOfCoreProperties() {
        var aggregate = QuestionAggregate.createNew(
            1001L, 2002L, "Q123", QuestionType.MCQ,
            "Test Question", "Test Content", 5
        );

        // These properties should not have setters
        assertThat(aggregate.getId()).isNotNull();
        assertThat(aggregate.getUserId()).isEqualTo(1001L);
        assertThat(aggregate.getQuestionBankId()).isEqualTo(2002L);
        assertThat(aggregate.getSourceQuestionId()).isEqualTo("Q123");
        assertThat(aggregate.getQuestionType()).isEqualTo(QuestionType.MCQ);
        assertThat(aggregate.getCreatedAt()).isNotNull();

        // Verify no setters exist for immutable properties
        var methods = Arrays.stream(QuestionAggregate.class.getMethods())
            .map(Method::getName)
            .collect(Collectors.toList());

        assertThat(methods).doesNotContain(
            "setUserId", "setQuestionBankId", "setSourceQuestionId",
            "setQuestionType", "setCreatedAt", "setId"
        );
    }

    @Test
    @DisplayName("Should validate business rules during creation")
    void shouldValidateBusinessRulesDuringCreation() {
        // Title cannot be empty
        assertThatThrownBy(() ->
            QuestionAggregate.createNew(
                1001L, 2002L, "Q123", QuestionType.MCQ,
                "", "Test Content", 5
            )
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Title is required");

        // Content cannot be empty
        assertThatThrownBy(() ->
            QuestionAggregate.createNew(
                1001L, 2002L, "Q123", QuestionType.MCQ,
                "Test Question", "", 5
            )
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Content is required");

        // Points cannot be negative
        assertThatThrownBy(() ->
            QuestionAggregate.createNew(
                1001L, 2002L, "Q123", QuestionType.MCQ,
                "Test Question", "Test Content", -1
            )
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Points cannot be negative");
    }

    @Test
    @DisplayName("Should handle concurrent creation safely")
    void shouldHandleConcurrentCreationSafely() throws InterruptedException {
        var aggregates = new ConcurrentLinkedQueue<QuestionAggregate>();
        var executor = Executors.newFixedThreadPool(10);
        var latch = new CountDownLatch(50);

        for (int i = 0; i < 50; i++) {
            final int questionId = i;
            executor.submit(() -> {
                try {
                    var aggregate = QuestionAggregate.createNew(
                        1001L, 2002L, "Q" + questionId, QuestionType.MCQ,
                        "Question " + questionId, "Content " + questionId, 5
                    );
                    aggregates.add(aggregate);
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await(10, TimeUnit.SECONDS);
        assertThat(aggregates).hasSize(50);

        // All aggregates should have unique source question IDs
        var sourceIds = aggregates.stream()
            .map(QuestionAggregate::getSourceQuestionId)
            .collect(Collectors.toSet());

        assertThat(sourceIds).hasSize(50);
    }
}
```

**Green Phase (Minimal Implementation):**
- Implement basic QuestionAggregate class extending AggregateRoot
- Add private constructor and static factory method
- Implement core field validation
- Add domain event generation
- Ensure immutability of key properties

**Refactor Phase:**
- Optimize validation logic
- Add comprehensive business rules
- Improve error messages
- Add performance optimizations

**Verification Criteria:**
- [ ] All core tests pass (100% coverage)
- [ ] Object creation performance <100Âµs
- [ ] Domain events properly generated and immutable
- [ ] Validation errors provide clear feedback
- [ ] Thread safety verified under concurrent load
- [ ] Memory usage <1KB per aggregate instance
- [ ] Unit test: aggregate root inheritance functionality
- [ ] Unit test: immutable property enforcement

---

### 4. Question Update Logic Implementation
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: Task 3 complete

#### Tasks:
- [ ] **4.1** Implement updateFrom() method
- [ ] **4.2** Add immutable property protection
- [ ] **4.3** Implement selective field updates
- [ ] **4.4** Add business rule validation for updates
- [ ] **4.5** Generate appropriate domain events
- [ ] **4.6** Handle type-specific data updates

#### Implementation Details:
```java
// Addition to QuestionAggregate class
public void updateFrom(String title, String content, Integer points, String status,
                      String solutionExplanation, McqData mcqData,
                      EssayData essayData, TrueFalseData trueFalseData) {

    // Store previous values for event
    String previousTitle = this.title;

    // Validate update rules
    validateUpdateRules(title, content);

    // Update modifiable fields only
    if (title != null && !title.trim().isEmpty()) {
        this.title = title;
    }
    if (content != null && !content.trim().isEmpty()) {
        this.content = content;
    }
    if (points != null && points >= 0) {
        this.points = points;
    }
    if (status != null && isValidStatus(status)) {
        this.status = status;
    }
    if (solutionExplanation != null) {
        this.solutionExplanation = solutionExplanation;
    }

    // Update type-specific data based on question type
    updateTypeSpecificData(mcqData, essayData, trueFalseData);

    // Update audit fields
    this.updatedAt = Instant.now();

    // Generate domain event
    this.addDomainEvent(new QuestionUpdatedEvent(
        this.id.toString(),
        this.sourceQuestionId,
        previousTitle,
        this.title
    ));
}

private void validateUpdateRules(String title, String content) {
    // Cannot update to empty title or content
    if (title != null && title.trim().isEmpty()) {
        throw new IllegalArgumentException("Title cannot be empty");
    }
    if (content != null && content.trim().isEmpty()) {
        throw new IllegalArgumentException("Content cannot be empty");
    }

    // Cannot update if archived
    if ("archived".equals(this.status)) {
        throw new IllegalStateException("Cannot update archived question");
    }
}

private void updateTypeSpecificData(McqData mcqData, EssayData essayData, TrueFalseData trueFalseData) {
    switch (this.questionType) {
        case MCQ:
            if (mcqData != null) {
                this.mcqData = mcqData;
                // Clear other type data
                this.essayData = null;
                this.trueFalseData = null;
            }
            break;
        case ESSAY:
            if (essayData != null) {
                this.essayData = essayData;
                // Clear other type data
                this.mcqData = null;
                this.trueFalseData = null;
            }
            break;
        case TRUE_FALSE:
            if (trueFalseData != null) {
                this.trueFalseData = trueFalseData;
                // Clear other type data
                this.mcqData = null;
                this.essayData = null;
            }
            break;
    }
}

// Immutable property getters (no setters for these)
public ObjectId getId() { return id; }
public Long getUserId() { return userId; }
public Long getQuestionBankId() { return questionBankId; }
public String getSourceQuestionId() { return sourceQuestionId; }
public QuestionType getQuestionType() { return questionType; }
public Instant getCreatedAt() { return createdAt; }
```

#### Acceptance Criteria:
- Only modifiable fields can be updated
- Immutable properties (id, userId, questionBankId, sourceQuestionId, questionType, createdAt) protected
- Business rules enforced during updates
- Domain events generated for successful updates
- Type-specific data properly managed

#### TDD Cycle and Verification Approach:

**Red Phase (Write Failing Tests First):**
```java
class QuestionAggregateUpdateFunctionalityTest {

    private QuestionAggregate aggregate;

    @BeforeEach
    void setUp() {
        aggregate = QuestionAggregate.createNew(
            1001L, 2002L, "Q123", QuestionType.MCQ,
            "Original Title", "Original Content", 5
        );
        // Clear creation event
        aggregate.markEventsAsCommitted();
    }

    @Test
    @DisplayName("Should update modifiable fields successfully")
    void shouldUpdateModifiableFieldsSuccessfully() {
        // Test will fail initially - updateFrom method doesn't exist
        var mcqData = new McqData(
            List.of(new McqOption("A", "Option A", true, 1.0)),
            true, false, false, 300
        );

        aggregate.updateFrom(
            "Updated Title",
            "Updated Content",
            10,
            "published",
            "This is the solution",
            mcqData,
            null,
            null
        );

        assertThat(aggregate.getTitle()).isEqualTo("Updated Title");
        assertThat(aggregate.getContent()).isEqualTo("Updated Content");
        assertThat(aggregate.getPoints()).isEqualTo(10);
        assertThat(aggregate.getStatus()).isEqualTo("published");
        assertThat(aggregate.getSolutionExplanation()).isEqualTo("This is the solution");
        assertThat(aggregate.getMcqData()).isEqualTo(mcqData);
        assertThat(aggregate.getUpdatedAt()).isAfter(aggregate.getCreatedAt());
    }

    @Test
    @DisplayName("Should protect immutable properties from updates")
    void shouldProtectImmutablePropertiesFromUpdates() {
        var originalUserId = aggregate.getUserId();
        var originalQuestionBankId = aggregate.getQuestionBankId();
        var originalSourceId = aggregate.getSourceQuestionId();
        var originalType = aggregate.getQuestionType();
        var originalCreatedAt = aggregate.getCreatedAt();

        aggregate.updateFrom(
            "Updated Title", "Updated Content", 10, "published",
            "Solution", null, null, null
        );

        // Immutable properties should remain unchanged
        assertThat(aggregate.getUserId()).isEqualTo(originalUserId);
        assertThat(aggregate.getQuestionBankId()).isEqualTo(originalQuestionBankId);
        assertThat(aggregate.getSourceQuestionId()).isEqualTo(originalSourceId);
        assertThat(aggregate.getQuestionType()).isEqualTo(originalType);
        assertThat(aggregate.getCreatedAt()).isEqualTo(originalCreatedAt);
    }

    @Test
    @DisplayName("Should generate QuestionUpdatedEvent on successful update")
    void shouldGenerateQuestionUpdatedEventOnSuccessfulUpdate() {
        aggregate.updateFrom(
            "Updated Title", null, null, null, null, null, null, null
        );

        var events = aggregate.getUncommittedEvents();
        assertThat(events).hasSize(1);

        var event = events.get(0);
        assertThat(event).isInstanceOf(QuestionUpdatedEvent.class);

        var updatedEvent = (QuestionUpdatedEvent) event;
        assertThat(updatedEvent.getSourceQuestionId()).isEqualTo("Q123");
        assertThat(updatedEvent.getPreviousTitle()).isEqualTo("Original Title");
        assertThat(updatedEvent.getNewTitle()).isEqualTo("Updated Title");
    }

    @Test
    @DisplayName("Should validate business rules during update")
    void shouldValidateBusinessRulesDuringUpdate() {
        // Empty title should be rejected
        assertThatThrownBy(() ->
            aggregate.updateFrom("", null, null, null, null, null, null, null)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Title cannot be empty");

        // Empty content should be rejected
        assertThatThrownBy(() ->
            aggregate.updateFrom(null, "", null, null, null, null, null, null)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Content cannot be empty");

        // Negative points should be rejected
        assertThatThrownBy(() ->
            aggregate.updateFrom(null, null, -1, null, null, null, null, null)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Points cannot be negative");

        // Invalid status should be rejected
        assertThatThrownBy(() ->
            aggregate.updateFrom(null, null, null, "invalid_status", null, null, null, null)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("Invalid status");
    }

    @Test
    @DisplayName("Should handle type-specific data updates correctly")
    void shouldHandleTypeSpecificDataUpdatesCorrectly() {
        // Test MCQ data update
        var mcqData = new McqData(
            List.of(new McqOption("A", "Correct", true, 1.0)),
            true, false, false, 300
        );

        aggregate.updateFrom(null, null, null, null, null, mcqData, null, null);

        assertThat(aggregate.getMcqData()).isEqualTo(mcqData);
        assertThat(aggregate.getEssayData()).isNull();
        assertThat(aggregate.getTrueFalseData()).isNull();
    }

    @Test
    @DisplayName("Should handle partial updates correctly")
    void shouldHandlePartialUpdatesCorrectly() {
        var originalTitle = aggregate.getTitle();
        var originalContent = aggregate.getContent();

        // Update only points
        aggregate.updateFrom(null, null, 15, null, null, null, null, null);

        assertThat(aggregate.getTitle()).isEqualTo(originalTitle);
        assertThat(aggregate.getContent()).isEqualTo(originalContent);
        assertThat(aggregate.getPoints()).isEqualTo(15);
    }

    @Test
    @DisplayName("Should reject mismatched type-specific data")
    void shouldRejectMismatchedTypeSpecificData() {
        // Create essay question
        var essayAggregate = QuestionAggregate.createNew(
            1001L, 2002L, "E123", QuestionType.ESSAY,
            "Essay Question", "Write an essay", 10
        );

        var mcqData = new McqData(
            List.of(new McqOption("A", "Option", true, 1.0)),
            true, false, false, 300
        );

        // Should reject MCQ data for essay question
        assertThatThrownBy(() ->
            essayAggregate.updateFrom(null, null, null, null, null, mcqData, null, null)
        ).isInstanceOf(IllegalArgumentException.class)
         .hasMessageContaining("MCQ data not allowed for ESSAY question type");
    }

    @Test
    @DisplayName("Should handle concurrent updates safely")
    void shouldHandleConcurrentUpdatesSafely() throws InterruptedException {
        var results = new ConcurrentLinkedQueue<Boolean>();
        var executor = Executors.newFixedThreadPool(5);
        var latch = new CountDownLatch(20);

        for (int i = 0; i < 20; i++) {
            final int updateId = i;
            executor.submit(() -> {
                try {
                    aggregate.updateFrom(
                        "Title " + updateId,
                        "Content " + updateId,
                        updateId,
                        null, null, null, null, null
                    );
                    results.add(true);
                } catch (Exception e) {
                    results.add(false);
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await(10, TimeUnit.SECONDS);
        assertThat(results).hasSize(20);

        // At least some updates should succeed (depending on timing)
        assertThat(results.stream().anyMatch(success -> success)).isTrue();
        assertThat(aggregate.getUpdatedAt()).isAfter(aggregate.getCreatedAt());
    }
}
```

**Green Phase (Minimal Implementation):**
- Implement updateFrom() method with field updates
- Add validation for updateable fields
- Implement type-specific data handling
- Generate appropriate domain events
- Ensure immutable property protection

**Refactor Phase:**
- Optimize update performance
- Add comprehensive business rule validation
- Improve error handling and messages
- Add update conflict detection

**Verification Criteria:**
- [ ] All update tests pass (100% coverage)
- [ ] Update operation performance <50Âµs
- [ ] Immutable properties never change
- [ ] Domain events correctly generated
- [ ] Type-specific data properly managed
- [ ] Business rules enforced consistently
- [ ] Unit test: domain event generation on update
- [ ] Unit test: type-specific data update handling
- [ ] Unit test: archived question update prevention

---

### 5. Type-Specific Data Management
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 4 complete

#### Tasks:
- [ ] **5.1** Implement type-specific data validation
- [ ] **5.2** Add methods for setting type-specific data
- [ ] **5.3** Implement data consistency rules
- [ ] **5.4** Add type-specific validation methods
- [ ] **5.5** Handle data migration between types (if needed)

#### Implementation Details:
```java
// Addition to QuestionAggregate class
public void setMcqData(McqData mcqData) {
    if (this.questionType != QuestionType.MCQ) {
        throw new IllegalStateException("Cannot set MCQ data for non-MCQ question");
    }
    if (mcqData == null) {
        throw new IllegalArgumentException("MCQ data cannot be null for MCQ question");
    }
    this.mcqData = mcqData;
    // Clear other type data to maintain consistency
    this.essayData = null;
    this.trueFalseData = null;
}

public void setEssayData(EssayData essayData) {
    if (this.questionType != QuestionType.ESSAY) {
        throw new IllegalStateException("Cannot set Essay data for non-Essay question");
    }
    if (essayData == null) {
        throw new IllegalArgumentException("Essay data cannot be null for Essay question");
    }
    this.essayData = essayData;
    // Clear other type data to maintain consistency
    this.mcqData = null;
    this.trueFalseData = null;
}

public void setTrueFalseData(TrueFalseData trueFalseData) {
    if (this.questionType != QuestionType.TRUE_FALSE) {
        throw new IllegalStateException("Cannot set True/False data for non-True/False question");
    }
    if (trueFalseData == null) {
        throw new IllegalArgumentException("True/False data cannot be null for True/False question");
    }
    this.trueFalseData = trueFalseData;
    // Clear other type data to maintain consistency
    this.mcqData = null;
    this.essayData = null;
}

public boolean hasValidTypeSpecificData() {
    switch (this.questionType) {
        case MCQ:
            return this.mcqData != null && this.essayData == null && this.trueFalseData == null;
        case ESSAY:
            return this.essayData != null && this.mcqData == null && this.trueFalseData == null;
        case TRUE_FALSE:
            return this.trueFalseData != null && this.mcqData == null && this.essayData == null;
        default:
            return false;
    }
}
```

#### Acceptance Criteria:
- Type-specific data consistency enforced
- Only appropriate data set for question type
- Validation prevents invalid data combinations
- Data integrity maintained across operations

#### Test Requirements:
- [ ] Unit test: MCQ data setting and validation
- [ ] Unit test: Essay data setting and validation
- [ ] Unit test: True/False data setting and validation
- [ ] Unit test: type mismatch error handling
- [ ] Unit test: data consistency validation
- [ ] Unit test: hasValidTypeSpecificData() method

---

### 6. Aggregate Behavior Methods
**Estimated Effort**: 0.5 days
**Priority**: Medium
**Dependencies**: Task 5 complete

#### Tasks:
- [ ] **6.1** Implement aggregate behavior methods
- [ ] **6.2** Add question lifecycle methods
- [ ] **6.3** Implement validation helper methods
- [ ] **6.4** Add convenience methods for common operations
- [ ] **6.5** Implement aggregate comparison methods

#### Implementation Details:
```java
// Addition to QuestionAggregate class
public void publish() {
    if (!hasValidTypeSpecificData()) {
        throw new IllegalStateException("Cannot publish question without valid type-specific data");
    }
    if ("archived".equals(this.status)) {
        throw new IllegalStateException("Cannot publish archived question");
    }

    this.status = "published";
    this.publishedAt = Instant.now();
    this.updatedAt = Instant.now();

    this.addDomainEvent(new QuestionPublishedEvent(
        this.id.toString(),
        this.sourceQuestionId,
        this.userId,
        this.questionBankId
    ));
}

public void archive() {
    this.status = "archived";
    this.archivedAt = Instant.now();
    this.updatedAt = Instant.now();

    this.addDomainEvent(new QuestionArchivedEvent(
        this.id.toString(),
        this.sourceQuestionId
    ));
}

public boolean isNew() {
    return this.id == null;
}

public boolean isDraft() {
    return "draft".equals(this.status);
}

public boolean isPublished() {
    return "published".equals(this.status);
}

public boolean isArchived() {
    return "archived".equals(this.status);
}

public boolean belongsToUser(Long userId) {
    return this.userId.equals(userId);
}

public boolean belongsToQuestionBank(Long questionBankId) {
    return this.questionBankId.equals(questionBankId);
}

@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;

    QuestionAggregate that = (QuestionAggregate) obj;

    // Use business identity: user + questionBank + sourceQuestionId
    return Objects.equals(userId, that.userId) &&
           Objects.equals(questionBankId, that.questionBankId) &&
           Objects.equals(sourceQuestionId, that.sourceQuestionId);
}

@Override
public int hashCode() {
    return Objects.hash(userId, questionBankId, sourceQuestionId);
}
```

#### Acceptance Criteria:
- Question lifecycle methods work correctly
- Business identity properly implemented
- Validation helper methods provide accurate results
- State transition rules enforced

#### Test Requirements:
- [ ] Unit test: publish() method functionality and validation
- [ ] Unit test: archive() method functionality
- [ ] Unit test: lifecycle state query methods
- [ ] Unit test: ownership and belonging validation methods
- [ ] Unit test: equals() and hashCode() implementation
- [ ] Unit test: business identity consistency

---

## Acceptance Criteria Summary

### Functional Requirements
- [ ] QuestionAggregate properly extends AggregateRoot from shared module
- [ ] Support for all three question types (MCQ, Essay, True/False) with type-specific data
- [ ] Domain events generated for create, update, publish, and archive operations
- [ ] Business rules enforced for question lifecycle management
- [ ] Immutable properties protected from modification
- [ ] Type-specific data consistency maintained

### Non-Functional Requirements
- [ ] Question creation time <50ms
- [ ] Update operations time <30ms
- [ ] Memory footprint <1KB per aggregate instance
- [ ] Thread-safe domain event handling
- [ ] Code coverage >90% for aggregate logic

### Definition of Done
- [ ] QuestionAggregate class fully implemented with all methods
- [ ] All domain events implemented and tested
- [ ] Type-specific value objects created and validated
- [ ] Comprehensive unit test suite covering all scenarios
- [ ] Business rules and constraints properly enforced
- [ ] Code review completed
- [ ] Integration with AggregateRoot verified

## Dependencies and Risks

### Dependencies
- US-000 (Shared Module Infrastructure) must provide AggregateRoot
- Domain event infrastructure from shared module
- Value object pattern understanding
- Business rule requirements clarity

### Risks
- **Risk**: Complex type-specific data handling
  **Mitigation**: Clear separation of concerns and validation at boundaries

- **Risk**: Domain event overhead
  **Mitigation**: Efficient event collection and lazy evaluation

- **Risk**: Business rule complexity growth
  **Mitigation**: Focused aggregate responsibility and clear validation methods

## Testing Strategy

### Unit Testing
- Aggregate creation and update scenarios
- Business rule validation
- Domain event generation
- Type-specific data handling
- Edge cases and error conditions

### Integration Testing
- AggregateRoot inheritance behavior
- Domain event integration
- Value object serialization

### Test Data Requirements
- Valid question data for all types
- Invalid data for validation testing
- Edge case data for boundary testing

## Technical Notes

### Design Patterns Used
- **Aggregate Pattern**: Central to DDD implementation
- **Factory Method**: createNew() for aggregate creation
- **Value Object**: Type-specific data containers
- **Domain Events**: For audit trail and integration

### Performance Considerations
- Lazy loading of type-specific data where possible
- Efficient domain event collection
- Minimal object creation in validation methods

### Security Considerations
- User and question bank validation
- Input sanitization in content fields
- Business rule enforcement prevents unauthorized operations