# US-030: Error Recovery Guidance System

## User Story
**As a** API consumer experiencing validation failures
**I want** automated error recovery guidance and corrective action suggestions
**So that** I can resolve issues efficiently without extensive debugging or support intervention

## Epic
Enhanced Error Messaging

## Story
Implement intelligent error recovery guidance system that provides automated corrective actions, validation retry strategies, and progressive assistance for complex validation failures

## Acceptance Criteria

### Automated Recovery Suggestions
- [ ] **AC-030.1**: System must analyze validation failures and suggest specific corrective actions
- [ ] **AC-030.2**: Recovery suggestions must be prioritized by likelihood of success
- [ ] **AC-030.3**: Multi-step recovery processes must be broken down into actionable phases
- [ ] **AC-030.4**: Recovery guidance must adapt based on validation failure patterns and history

### Progressive Assistance
- [ ] **AC-030.5**: First-time errors must provide basic guidance and common solutions
- [ ] **AC-030.6**: Repeated similar errors must trigger enhanced guidance with detailed troubleshooting
- [ ] **AC-030.7**: Complex multi-field validation failures must provide coordinated resolution steps
- [ ] **AC-030.8**: Escalation to human support must be suggested for unresolvable validation patterns

### Validation Retry Intelligence
- [ ] **AC-030.9**: System must detect validation retry patterns and suggest optimization strategies
- [ ] **AC-030.10**: Partial validation success must be preserved across retry attempts
- [ ] **AC-030.11**: Retry guidance must include expected validation performance metrics
- [ ] **AC-030.12**: Validation state preservation must support incremental error resolution

## Test-Driven Development Cycle

### Epic and Story Annotations for Tests
- **@Epic**: `"Enhanced Error Messaging"`
- **@Story**: `"030.error-recovery-guidance-system"`

### Red-Green-Refactor Cycle

#### Phase 1: RED - Write Failing Tests for Error Recovery Guidance
**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/validation/ErrorRecoveryAnalyzerTest.java`

```java
@SpringBootTest
@ActiveProfiles("test")
@ExtendWith(AllureExtension.class)
@TestMethodOrder(OrderAnnotation.class)
class ErrorRecoveryAnalyzerTest {

    @Container
    static MongoDBContainer mongoDBContainer = new MongoDBContainer(DockerImageName.parse("mongo:6.0"))
            .withReuse(true);

    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoDBContainer::getReplicaSetUrl);
    }

    @Autowired
    private ErrorRecoveryAnalyzer recoveryAnalyzer;

    @Test
    @Order(1)
    @Epic("Enhanced Error Messaging")
    @Story("030.error-recovery-guidance-system")
    @DisplayName("Should provide automated recovery suggestions for validation failures")
    @Description("Validates that validation failures generate specific corrective action suggestions")
    void shouldProvideAutomatedRecoverySuggestionsForValidationFailures() {
        // RED: This test should fail initially
        var validationFailure = ValidationFailure.builder()
            .errorCode(ValidationErrorCode.INSUFFICIENT_MCQ_OPTIONS)
            .fieldPath("options")
            .currentValue(List.of("Single option"))
            .constraint("minimum 2 options required")
            .build();

        var command = createMcqCommand();
        var context = ValidationContext.builder()
            .questionType("multiple_choice")
            .userExperience(UserExperienceLevel.BEGINNER)
            .build();

        var guidance = recoveryAnalyzer.analyzeAndGenerateGuidance(validationFailure, command, context);

        assertThat(guidance.getRecoverySteps()).isNotEmpty();
        assertThat(guidance.getRecoverySteps().get(0).getAction())
            .contains("Add at least one more option");
        assertThat(guidance.getRecoverySteps().get(0).getPriority())
            .isEqualTo(RecoveryPriority.HIGH);
        assertThat(guidance.getExpectedSuccessRate()).isGreaterThan(0.8);
    }

    @Test
    @Order(2)
    @Epic("Enhanced Error Messaging")
    @Story("030.error-recovery-guidance-system")
    @DisplayName("Should provide progressive assistance for repeated similar errors")
    @Description("Validates that repeated errors trigger enhanced guidance with detailed troubleshooting")
    void shouldProvideProgressiveAssistanceForRepeatedErrors() {
        // RED: This test should fail initially as progressive assistance isn't implemented
        var validationFailure = ValidationFailure.builder()
            .errorCode(ValidationErrorCode.INSUFFICIENT_MCQ_OPTIONS)
            .fieldPath("options")
            .currentValue(List.of("Single option"))
            .failureCount(3) // Third occurrence of same error
            .build();

        var context = ValidationContext.builder()
            .questionType("multiple_choice")
            .userExperience(UserExperienceLevel.BEGINNER)
            .previousAttempts(2)
            .build();

        var guidance = recoveryAnalyzer.analyzeAndGenerateGuidance(validationFailure, createMcqCommand(), context);

        // Progressive assistance should provide more detailed guidance
        assertThat(guidance.getAssistanceLevel()).isEqualTo(AssistanceLevel.DETAILED);
        assertThat(guidance.getRecoverySteps()).hasSizeGreaterThan(2);
        assertThat(guidance.getExamples()).isNotEmpty();
        assertThat(guidance.getTroubleshootingTips()).isNotEmpty();
        assertThat(guidance.getDocumentationLinks()).isNotEmpty();
    }

    // TODO(human): Add test for validation state preservation across retry attempts
    @Test
    @Order(3)
    @Epic("Enhanced Error Messaging")
    @Story("030.error-recovery-guidance-system")
    @DisplayName("Should preserve partial validation success across retry attempts")
    @Description("Validates that successful validations are preserved during incremental error resolution")
    void shouldPreservePartialValidationSuccessAcrossRetries() {
        // RED: This test needs human input for validation state management design
        // TODO(human): Define how partial success should be preserved and validated
    }
}
```

#### Phase 2: GREEN - Implement Error Recovery System
**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/ErrorRecoveryAnalyzer.java`

```java
@Component
public class ErrorRecoveryAnalyzer {

    private final ValidationHistoryService historyService;
    private final RecoveryStrategyRegistry strategyRegistry;
    private final ValidationStateManager stateManager;
    private final ProgressiveAssistanceEngine assistanceEngine;

    public RecoveryGuidance analyzeAndGenerateGuidance(
            ValidationFailure failure,
            UpsertQuestionCommand command,
            ValidationContext context) {

        // 1. Analyze failure pattern
        var failurePattern = analyzeFailurePattern(failure, context);

        // 2. Determine assistance level based on history
        var assistanceLevel = determineAssistanceLevel(failure, context);

        // 3. Generate recovery strategies
        var recoveryStrategies = strategyRegistry.findStrategiesFor(failure.getErrorCode());

        // 4. Prioritize strategies based on context
        var prioritizedSteps = prioritizeRecoverySteps(recoveryStrategies, context, failurePattern);

        // 5. Generate contextual guidance
        return RecoveryGuidance.builder()
            .assistanceLevel(assistanceLevel)
            .recoverySteps(prioritizedSteps)
            .examples(generateExamples(failure, context))
            .troubleshootingTips(generateTroubleshootingTips(failurePattern))
            .documentationLinks(getRelevantDocumentation(failure.getErrorCode()))
            .expectedSuccessRate(calculateExpectedSuccessRate(prioritizedSteps, context))
            .estimatedResolutionTime(estimateResolutionTime(prioritizedSteps, context))
            .build();
    }

    private AssistanceLevel determineAssistanceLevel(ValidationFailure failure, ValidationContext context) {
        if (failure.getFailureCount() >= 3) {
            return AssistanceLevel.DETAILED;
        } else if (context.getUserExperience() == UserExperienceLevel.BEGINNER) {
            return AssistanceLevel.GUIDED;
        } else {
            return AssistanceLevel.BASIC;
        }
    }

    private List<RecoveryStep> prioritizeRecoverySteps(
            List<RecoveryStrategy> strategies,
            ValidationContext context,
            FailurePattern pattern) {

        return strategies.stream()
            .flatMap(strategy -> strategy.generateSteps(context, pattern).stream())
            .sorted(Comparator.comparing(RecoveryStep::getPriority))
            .collect(Collectors.toList());
    }

    // TODO(human): Implement advanced pattern recognition for failure analysis
    private FailurePattern analyzeFailurePattern(ValidationFailure failure, ValidationContext context) {
        // TODO(human): Add sophisticated pattern analysis based on:
        // - Error sequence patterns
        // - User behavior patterns
        // - Common mistake patterns for question types
        return FailurePattern.builder()
            .errorCode(failure.getErrorCode())
            .frequency(failure.getFailureCount())
            .context(context)
            .build();
    }
}
```

### Verification Approach for Each Acceptance Criterion

#### AC-030.1 Verification: Automated Recovery Suggestions
```java
@Test
@Epic("Enhanced Error Messaging")
@Story("030.error-recovery-guidance-system")
@DisplayName("Verify system analyzes validation failures and suggests specific corrective actions")
void verifyAutomatedRecoverySuggestions() {
    // Test each validation error type
    // Verify specific corrective actions provided
    // Validate action prioritization by success likelihood
}
```

#### AC-030.5 Verification: Progressive Assistance
```java
@Test
@Epic("Enhanced Error Messaging")
@Story("030.error-recovery-guidance-system")
@DisplayName("Verify first-time errors provide basic guidance and repeated errors trigger enhanced guidance")
void verifyProgressiveAssistance() {
    // Test first occurrence - basic guidance
    // Test repeated occurrences - detailed troubleshooting
    // Verify escalation to human support when appropriate
}
```

### Concrete File Locations
- **Error Recovery Analyzer**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/ErrorRecoveryAnalyzer.java`
- **Recovery Strategy Registry**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/recovery/RecoveryStrategyRegistry.java`
- **Progressive Assistance Engine**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/recovery/ProgressiveAssistanceEngine.java`
- **Test Implementation**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/validation/ErrorRecoveryAnalyzerTest.java`

### Maven Commands for TDD Cycle
```bash
# Run specific error recovery test during RED phase (should fail)
mvn -Dtest=ErrorRecoveryAnalyzerTest#shouldProvideAutomatedRecoverySuggestionsForValidationFailures test -pl internal-layer/question-bank

# Run all error recovery tests during GREEN phase
mvn -Dtest=ErrorRecoveryAnalyzerTest test -pl internal-layer/question-bank

# Run integration tests during REFACTOR phase
mvn test -pl internal-layer/question-bank

# Verify error recovery performance and effectiveness
mvn verify -pl internal-layer/question-bank
```

## Technical Requirements

### Error Recovery Analyzer
```java
@Component
public class ErrorRecoveryAnalyzer {

    private final ValidationHistoryService historyService;
    private final RecoveryStrategyRegistry strategyRegistry;
    private final ValidationStateManager stateManager;
    private final ProgressiveAssistanceEngine assistanceEngine;

    public RecoveryGuidance analyzeAndGenerateGuidance(
            ValidationFailure failure,
            UpsertQuestionCommand command,
            ValidationContext context) {

        var analysis = RecoveryAnalysis.builder()
            .failure(failure)
            .command(command)
            .context(context)
            .validationHistory(historyService.getValidationHistory(command.getUserId()))
            .build();

        // 1. Analyze error patterns
        var errorPattern = analyzeErrorPattern(analysis);

        // 2. Generate recovery strategies
        var recoveryStrategies = generateRecoveryStrategies(errorPattern, analysis);

        // 3. Prioritize strategies by success likelihood
        var prioritizedStrategies = prioritizeRecoveryStrategies(recoveryStrategies, analysis);

        // 4. Generate progressive assistance level
        var assistanceLevel = assistanceEngine.determineAssistanceLevel(analysis);

        // 5. Create comprehensive recovery guidance
        return RecoveryGuidance.builder()
            .errorPattern(errorPattern)
            .primaryStrategy(prioritizedStrategies.get(0))
            .alternativeStrategies(prioritizedStrategies.subList(1, prioritizedStrategies.size()))
            .assistanceLevel(assistanceLevel)
            .progressiveSteps(generateProgressiveSteps(prioritizedStrategies, assistanceLevel))
            .validationStatePreservation(determineStatePreservation(analysis))
            .build();
    }

    private ErrorPattern analyzeErrorPattern(RecoveryAnalysis analysis) {
        // 1. Single field error pattern
        if (analysis.getFailure().getFieldErrors().size() == 1) {
            return ErrorPattern.SINGLE_FIELD_ERROR;
        }

        // 2. Multi-field related error pattern
        if (areFieldsRelated(analysis.getFailure().getFieldErrors())) {
            return ErrorPattern.RELATED_FIELD_ERRORS;
        }

        // 3. Question type specific error pattern
        if (isQuestionTypeSpecific(analysis.getFailure())) {
            return ErrorPattern.QUESTION_TYPE_VALIDATION;
        }

        // 4. Cross-validation error pattern
        if (isCrossValidationError(analysis.getFailure())) {
            return ErrorPattern.CROSS_FIELD_VALIDATION;
        }

        return ErrorPattern.COMPLEX_VALIDATION;
    }

    private List<RecoveryStrategy> generateRecoveryStrategies(
            ErrorPattern pattern,
            RecoveryAnalysis analysis) {

        var strategies = new ArrayList<RecoveryStrategy>();

        // 1. Get pattern-specific strategies
        var patternStrategies = strategyRegistry.getStrategiesForPattern(pattern);
        strategies.addAll(patternStrategies);

        // 2. Add context-specific strategies
        strategies.addAll(generateContextSpecificStrategies(analysis));

        // 3. Add historical success strategies
        strategies.addAll(generateHistoricalSuccessStrategies(analysis));

        return strategies;
    }
}
```

### Progressive Assistance Engine
```java
@Component
public class ProgressiveAssistanceEngine {

    private final ValidationHistoryService historyService;
    private final UserExperienceTracker experienceTracker;

    public AssistanceLevel determineAssistanceLevel(RecoveryAnalysis analysis) {
        var userHistory = historyService.getUserValidationHistory(analysis.getCommand().getUserId());
        var experienceLevel = experienceTracker.getUserExperienceLevel(analysis.getCommand().getUserId());

        // 1. First-time user or first occurrence of error
        if (experienceLevel == ExperienceLevel.BEGINNER ||
            !userHistory.hasEncounteredError(analysis.getFailure().getErrorCode())) {
            return AssistanceLevel.BASIC;
        }

        // 2. User has seen this error before but not resolved it
        var errorHistory = userHistory.getErrorHistory(analysis.getFailure().getErrorCode());
        if (errorHistory.getResolutionCount() == 0 && errorHistory.getOccurrenceCount() > 1) {
            return AssistanceLevel.ENHANCED;
        }

        // 3. User has complex multi-field validation issues
        if (analysis.getFailure().getFieldErrors().size() > 3) {
            return AssistanceLevel.COMPREHENSIVE;
        }

        // 4. User has repeated failures despite previous guidance
        if (shouldEscalateToSupport(userHistory, analysis)) {
            return AssistanceLevel.ESCALATION;
        }

        return AssistanceLevel.STANDARD;
    }

    public List<ProgressiveStep> generateProgressiveSteps(
            List<RecoveryStrategy> strategies,
            AssistanceLevel level) {

        var steps = new ArrayList<ProgressiveStep>();

        switch (level) {
            case BASIC:
                steps.addAll(generateBasicSteps(strategies.get(0)));
                break;
            case STANDARD:
                steps.addAll(generateStandardSteps(strategies.subList(0, Math.min(2, strategies.size()))));
                break;
            case ENHANCED:
                steps.addAll(generateEnhancedSteps(strategies));
                steps.addAll(generateDiagnosticSteps());
                break;
            case COMPREHENSIVE:
                steps.addAll(generateComprehensiveSteps(strategies));
                steps.addAll(generateValidationStateSteps());
                steps.addAll(generateDebuggingSteps());
                break;
            case ESCALATION:
                steps.addAll(generateEscalationSteps());
                steps.addAll(generateSupportContextSteps());
                break;
        }

        return steps;
    }
}
```

### Validation State Manager
```java
@Component
public class ValidationStateManager {

    private final ValidationStateRepository stateRepository;
    private final ValidationCheckpointService checkpointService;

    public ValidationState preserveValidationState(
            UpsertQuestionCommand command,
            ValidationContext context,
            ValidationFailure failure) {

        var state = ValidationState.builder()
            .userId(command.getUserId())
            .questionBankId(command.getQuestionBankId())
            .validationTimestamp(LocalDateTime.now())
            .passedValidators(context.getPassedValidators())
            .failedValidator(context.getFailedValidator())
            .partialValidationResults(context.getPartialResults())
            .validationCheckpoint(checkpointService.createCheckpoint(context))
            .build();

        return stateRepository.save(state);
    }

    public Result<ValidationContext> restoreValidationState(
            String stateId,
            UpsertQuestionCommand newCommand) {

        var savedState = stateRepository.findById(stateId);
        if (savedState.isEmpty()) {
            return Result.failure("Validation state not found or expired",
                ValidationErrorCode.VALIDATION_STATE_NOT_FOUND);
        }

        var state = savedState.get();

        // 1. Verify state compatibility with new command
        if (!isStateCompatible(state, newCommand)) {
            return Result.failure("Validation state incompatible with current request",
                ValidationErrorCode.VALIDATION_STATE_INCOMPATIBLE);
        }

        // 2. Restore validation context
        var restoredContext = ValidationContext.builder()
            .passedValidators(state.getPassedValidators())
            .partialResults(state.getPartialValidationResults())
            .checkpoint(state.getValidationCheckpoint())
            .restoredFromState(true)
            .originalStateId(stateId)
            .build();

        return Result.success(restoredContext);
    }
}
```

### Integration Points
- **US-028**: Leverages type-specific validation errors for targeted recovery strategies
- **US-029**: Uses contextual error information to inform recovery guidance
- **US-003**: Integrates with ValidationHandler pattern for state management

## Business Rules

### Recovery Strategy Rules
1. **Safety-First**: Recovery strategies must not compromise data integrity
2. **Progressive Complexity**: Assistance complexity increases with user needs
3. **Performance-Aware**: Recovery guidance considers system performance impact
4. **Success-Optimized**: Strategies prioritized by historical success rates

### State Preservation Rules
1. **Incremental Progress**: Partial validation success preserved across attempts
2. **Expiration-Based**: Validation states expire after reasonable time periods
3. **User-Scoped**: Validation states isolated per user for security
4. **Checkpoint-Driven**: State preservation at logical validation checkpoints

### Escalation Rules
1. **Pattern-Based**: Escalation triggered by repeated failure patterns
2. **Complexity-Based**: Complex validation scenarios trigger enhanced assistance
3. **Time-Based**: Prolonged validation struggles trigger support escalation
4. **User-Consent**: Escalation suggestions respect user preferences

## Definition of Done

### Recovery Analysis System
- [ ] ErrorRecoveryAnalyzer implemented with pattern recognition and strategy generation
- [ ] Recovery strategy prioritization based on success likelihood and user history
- [ ] Error pattern classification for targeted recovery approach
- [ ] Integration with validation history for learning-based improvement

### Progressive Assistance
- [ ] ProgressiveAssistanceEngine with experience-based assistance level determination
- [ ] Multi-level guidance from basic to comprehensive with escalation
- [ ] User experience tracking for personalized assistance
- [ ] Support escalation with proper context and documentation

### Validation State Management
- [ ] ValidationStateManager with checkpoint-based state preservation
- [ ] Incremental validation progress preservation across retry attempts
- [ ] State compatibility validation for secure state restoration
- [ ] Validation state expiration and cleanup management

### Recovery Guidance Quality
- [ ] Recovery suggestions tested for accuracy and effectiveness
- [ ] Progressive step generation verified for all assistance levels
- [ ] State preservation tested across complex validation scenarios
- [ ] User experience improvement verified through testing

## Dependencies

### Prerequisites
- **US-028**: Type-specific validation errors for targeted recovery strategies
- **US-029**: Contextual error information for informed recovery guidance
- **US-003**: ValidationHandler pattern and validation chain infrastructure

### External Dependencies
- User experience analytics for assistance level determination
- Support system integration for escalation workflows
- Validation history storage and retrieval infrastructure

## Risk Mitigation

### Recovery Strategy Risks
- **Incorrect Guidance**: Comprehensive testing of recovery strategies with real-world scenarios
- **Data Integrity**: All recovery suggestions validated for data safety
- **Performance Impact**: Recovery analysis performance monitored and optimized
- **Strategy Effectiveness**: Success rates tracked and strategies updated accordingly

### State Management Risks
- **State Security**: User validation states properly isolated and secured
- **State Consistency**: State preservation accuracy verified through comprehensive testing
- **Storage Management**: State expiration and cleanup prevents storage bloat
- **Compatibility Issues**: State compatibility validation prevents restoration errors

### User Experience Risks
- **Assistance Appropriateness**: Progressive assistance levels tested with real users
- **Escalation Effectiveness**: Support escalation workflows validated for effectiveness
- **Learning Accuracy**: User experience tracking validated for assistance level determination
- **Privacy Compliance**: User data in validation history handled according to privacy requirements

## Success Metrics

### Recovery Effectiveness
- Validation error resolution success rate improved by 60% with recovery guidance
- Average time to error resolution reduced by 70% with automated guidance
- User satisfaction score >90% for recovery guidance helpfulness
- Recovery strategy success rate >80% for prioritized primary strategies

### Progressive Assistance Impact
- First-time error resolution rate >85% with basic assistance
- Repeat error resolution rate >95% with enhanced assistance
- Support escalation rate reduced by 50% through comprehensive assistance
- User self-service success rate >90% across all assistance levels

### State Management Efficiency
- Validation state preservation success rate 100% for checkpoint-eligible validations
- State restoration accuracy >99% with compatibility validation
- Incremental validation progress preservation reduces repeat validation time by 40%
- Validation state storage efficiency maintained with proper cleanup processes