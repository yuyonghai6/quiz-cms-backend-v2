# US-021: Security Audit Logging System

## User Story
**As a** compliance officer and system administrator
**I want** comprehensive security event logging for all unauthorized access attempts
**So that** we maintain audit trails for compliance requirements and can investigate security incidents

## Epic
Security Breach Protection

## Story
Implement SecurityAuditLogger leveraging existing US-005 MongoDB infrastructure to store structured security events

## Acceptance Criteria

### Audit Logging Functionality
- [ ] **AC-021.1**: All security violations must be logged with structured event data
- [ ] **AC-021.2**: Security events must include user context, timestamp, request details, and violation type
- [ ] **AC-021.3**: Audit logs must be stored in MongoDB using existing connection patterns from US-005
- [ ] **AC-021.4**: Security events must integrate with existing transaction management from US-007

### Data Storage Requirements
- [ ] **AC-021.5**: Security events must be stored in dedicated MongoDB collection
- [ ] **AC-021.6**: Audit documents must follow existing document structure patterns from US-005
- [ ] **AC-021.7**: Security event storage must use existing MongoTemplate configuration
- [ ] **AC-021.8**: Audit logging must not impact existing question upsert transaction performance

### Compliance Requirements
- [ ] **AC-021.9**: Audit logs must include all required fields for GDPR and FERPA compliance
- [ ] **AC-021.10**: Security events must be retained according to compliance requirements
- [ ] **AC-021.11**: Audit trail must be immutable and tamper-evident
- [ ] **AC-021.12**: Log data must be properly anonymized while maintaining investigation capability

## Test-Driven Development Cycle

### Epic and Story Annotations for Tests
- **@Epic**: `"Security Breach Protection"`
- **@Story**: `"021.security-audit-logging-system"`

### Red-Green-Refactor Cycle

#### Phase 1: RED - Write Failing Tests for Security Audit Logging
**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/security/SecurityAuditLoggerTest.java`

```java
@SpringBootTest
@ActiveProfiles("test")
@ExtendWith(AllureExtension.class)
@TestMethodOrder(OrderAnnotation.class)
class SecurityAuditLoggerTest {

    @Container
    static MongoDBContainer mongoDBContainer = new MongoDBContainer(DockerImageName.parse("mongo:6.0"))
            .withReuse(true);

    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoDBContainer::getReplicaSetUrl);
    }

    @Autowired
    private SecurityAuditLogger auditLogger;

    @Autowired
    private MongoTemplate mongoTemplate;

    @BeforeEach
    void setUp() {
        // Clean up security events collection before each test
        mongoTemplate.dropCollection("security_events");
    }

    @Test
    @Order(1)
    @Epic("Security Breach Protection")
    @Story("021.security-audit-logging-system")
    @DisplayName("Should log security violation with structured event data")
    @Description("Validates that security violations are logged with comprehensive audit information")
    void shouldLogSecurityViolationWithStructuredEventData() {
        // RED: This test should fail initially
        var securityEvent = SecurityEvent.builder()
            .type(SecurityEventType.UNAUTHORIZED_ACCESS_ATTEMPT)
            .userId(1001L)
            .sessionId("session_12345")
            .severity(SeverityLevel.HIGH)
            .requestId("req_security_violation_789")
            .details(Map.of(
                "attemptedUserId", 1002L,
                "tokenUserId", 1001L,
                "endpoint", "/api/users/1002/questionbanks/2001/questions"
            ))
            .clientIp("192.168.1.100")
            .userAgent("Mozilla/5.0...")
            .build();

        auditLogger.logSecurityViolation(securityEvent);

        // Verify audit log stored in MongoDB
        var storedEvents = mongoTemplate.findAll(SecurityEventDocument.class, "security_events");
        assertThat(storedEvents).hasSize(1);

        var storedEvent = storedEvents.get(0);
        assertThat(storedEvent.getEventType()).isEqualTo(SecurityEventType.UNAUTHORIZED_ACCESS_ATTEMPT);
        assertThat(storedEvent.getUserId()).isEqualTo(1001L);
        assertThat(storedEvent.getSessionId()).isEqualTo("session_12345");
        assertThat(storedEvent.getSeverity()).isEqualTo(SeverityLevel.HIGH);
        assertThat(storedEvent.getRequestId()).isEqualTo("req_security_violation_789");
        assertThat(storedEvent.getTimestamp()).isNotNull();
        assertThat(storedEvent.getDetails()).containsEntry("attemptedUserId", 1002L);
    }

    @Test
    @Order(2)
    @Epic("Security Breach Protection")
    @Story("021.security-audit-logging-system")
    @DisplayName("Should handle asynchronous logging without blocking request processing")
    @Description("Validates that audit logging is asynchronous and doesn't impact request performance")
    void shouldHandleAsynchronousLoggingWithoutBlocking() {
        // RED: This test should fail initially as async isn't implemented
        var securityEvent = SecurityEvent.builder()
            .type(SecurityEventType.PATH_PARAMETER_MANIPULATION)
            .userId(1001L)
            .sessionId("session_async_test")
            .severity(SeverityLevel.CRITICAL)
            .build();

        var startTime = System.nanoTime();
        auditLogger.logSecurityViolationAsync(securityEvent);
        var duration = Duration.ofNanos(System.nanoTime() - startTime);

        // Async logging should complete quickly (not wait for MongoDB write)
        assertThat(duration).isLessThan(Duration.ofMillis(10));

        // Wait briefly for async processing to complete
        await().atMost(Duration.ofSeconds(2))
            .untilAsserted(() -> {
                var events = mongoTemplate.findAll(SecurityEventDocument.class, "security_events");
                assertThat(events).hasSize(1);
                assertThat(events.get(0).getEventType()).isEqualTo(SecurityEventType.PATH_PARAMETER_MANIPULATION);
            });
    }

    @Test
    @Order(3)
    @Epic("Security Breach Protection")
    @Story("021.security-audit-logging-system")
    @DisplayName("Should handle audit logging failure gracefully with circuit breaker")
    @Description("Validates that audit logging failures don't impact main request processing")
    void shouldHandleAuditLoggingFailureGracefully() {
        // RED: This test should fail initially as circuit breaker isn't implemented
        // Simulate MongoDB connection failure
        mongoTemplate.getCollection("security_events").drop();

        var securityEvent = SecurityEvent.builder()
            .type(SecurityEventType.SESSION_HIJACKING_ATTEMPT)
            .userId(1001L)
            .sessionId("session_failure_test")
            .severity(SeverityLevel.HIGH)
            .build();

        // This should not throw an exception despite MongoDB being unavailable
        assertDoesNotThrow(() -> auditLogger.logSecurityViolation(securityEvent));

        // Verify circuit breaker logs the failure
        // TODO(human): Add specific circuit breaker state verification
    }
}
```

#### Phase 2: GREEN - Implement Security Audit Logger
**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/security/SecurityAuditLogger.java`

```java
@Component
public class SecurityAuditLogger {

    private final MongoTemplate mongoTemplate;
    private final ObjectMapper objectMapper;
    private final Clock clock;
    private final CircuitBreaker auditCircuitBreaker;

    public SecurityAuditLogger(MongoTemplate mongoTemplate,
                              ObjectMapper objectMapper,
                              Clock clock,
                              CircuitBreakerRegistry circuitBreakerRegistry) {
        this.mongoTemplate = mongoTemplate;
        this.objectMapper = objectMapper;
        this.clock = clock;
        this.auditCircuitBreaker = circuitBreakerRegistry.circuitBreaker("audit-logging");
    }

    public void logSecurityViolation(SecurityEvent securityEvent) {
        try {
            var auditDocument = createSecurityEventDocument(securityEvent);
            auditCircuitBreaker.executeSupplier(() -> {
                mongoTemplate.save(auditDocument, "security_events");
                return null;
            });
        } catch (Exception e) {
            // Log failure but don't propagate to caller
            log.error("Failed to log security event: {}", securityEvent.getType(), e);
        }
    }

    @Async("securityAuditExecutor")
    public CompletableFuture<Void> logSecurityViolationAsync(SecurityEvent securityEvent) {
        return CompletableFuture.runAsync(() -> logSecurityViolation(securityEvent));
    }

    private SecurityEventDocument createSecurityEventDocument(SecurityEvent securityEvent) {
        return SecurityEventDocument.builder()
            .eventType(securityEvent.getType())
            .userId(securityEvent.getUserId())
            .sessionId(securityEvent.getSessionId())
            .timestamp(Instant.now(clock))
            .severity(securityEvent.getSeverity())
            .details(securityEvent.getDetails())
            .requestId(securityEvent.getRequestId())
            .clientIp(securityEvent.getClientIp())
            .userAgent(securityEvent.getUserAgent())
            .checksumHash(calculateChecksum(securityEvent)) // For tamper detection
            .build();
    }

    private String calculateChecksum(SecurityEvent event) {
        // Simple checksum for audit trail integrity
        var dataToHash = String.format("%s:%s:%s:%s",
            event.getType(),
            event.getUserId(),
            event.getTimestamp(),
            event.getRequestId());
        return DigestUtils.sha256Hex(dataToHash);
    }
}
```

**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/security/SecurityEventDocument.java`

```java
@Document("security_events")
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SecurityEventDocument {

    @Id
    private ObjectId id;

    @Indexed
    private SecurityEventType eventType;

    @Indexed
    private Long userId;

    private String sessionId;

    @Indexed
    private Instant timestamp;

    @Indexed
    private SeverityLevel severity;

    private Map<String, Object> details;

    @Indexed
    private String requestId;

    private String clientIp;

    private String userAgent;

    // For audit trail integrity
    private String checksumHash;

    // For compliance tracking
    @Indexed
    private Instant anonymizationDate; // When PII should be anonymized

    @Indexed
    private Instant retentionExpiryDate; // When record should be deleted
}
```

#### Phase 3: REFACTOR - Enhance Performance and Compliance
- Add batch processing for high-volume audit events
- Implement automatic data anonymization after retention periods
- Add audit log query service for investigation capabilities
- Enhance circuit breaker with metrics and alerting

### Verification Approach for Each Acceptance Criterion

#### AC-021.1 Verification: Structured Event Data
```java
@Test
@Epic("Security Breach Protection")
@Story("021.security-audit-logging-system")
@DisplayName("Verify all security violations logged with structured event data")
void verifyStructuredSecurityEventLogging() {
    // Test each security event type
    // Verify all required fields are present
    // Validate data structure consistency
}
```

#### AC-021.8 Verification: Performance Impact
```java
@Test
@Epic("Security Breach Protection")
@Story("021.security-audit-logging-system")
@DisplayName("Verify audit logging doesn't impact question upsert transaction performance")
void verifyAuditLoggingPerformanceImpact() {
    var command = createValidUpsertCommand();

    var startTime = System.nanoTime();
    var result = questionApplicationService.upsertQuestion(command);
    var duration = Duration.ofNanos(System.nanoTime() - startTime);

    assertThat(result.isSuccess()).isTrue();
    assertThat(duration).isLessThan(Duration.ofMillis(100)); // Including audit logging
}
```

## Technical Requirements

### Concrete File Locations
- **Main Implementation**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/security/SecurityAuditLogger.java`
- **Document Model**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/security/SecurityEventDocument.java`
- **Security Event**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/security/SecurityEvent.java`
- **Test Implementation**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/security/SecurityAuditLoggerTest.java`
- **Configuration**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/config/SecurityAuditConfiguration.java`

### Implementation Order
1. Create `SecurityEvent` data structure with all required fields
2. Implement `SecurityEventDocument` following US-005 MongoDB patterns
3. Create `SecurityAuditLogger` with basic synchronous logging
4. Add asynchronous logging capability with `@Async`
5. Implement circuit breaker pattern for resilience
6. Add MongoDB indexes for query performance
7. Write comprehensive test suite following TDD cycle above

### Maven Commands for TDD Cycle
```bash
# Run specific audit logging test during RED phase (should fail)
mvn -Dtest=SecurityAuditLoggerTest#shouldLogSecurityViolationWithStructuredEventData test -pl internal-layer/question-bank

# Run all security audit tests during GREEN phase
mvn -Dtest=SecurityAuditLoggerTest test -pl internal-layer/question-bank

# Run integration tests during REFACTOR phase
mvn test -pl internal-layer/question-bank

# Verify MongoDB integration and performance
mvn verify -pl internal-layer/question-bank
```

## Technical Requirements

### Implementation Details
```java
@Component
public class SecurityAuditLogger {

    private final MongoTemplate mongoTemplate; // Reuse from US-005
    private final ObjectMapper objectMapper;
    private final Clock clock;

    public void logSecurityViolation(SecurityEvent securityEvent) {
        var auditDocument = SecurityEventDocument.builder()
            .eventType(securityEvent.getType())
            .userId(securityEvent.getUserId())
            .sessionId(securityEvent.getSessionId())
            .timestamp(Instant.now(clock))
            .severity(securityEvent.getSeverity())
            .details(securityEvent.getDetails())
            .requestId(securityEvent.getRequestId())
            .build();

        mongoTemplate.save(auditDocument, "security_events");
    }
}
```

### MongoDB Document Structure
```java
@Document("security_events")
public class SecurityEventDocument {
    @Id
    private ObjectId id;
    private SecurityEventType eventType;
    private Long userId;
    private String sessionId;
    private Instant timestamp;
    private SeverityLevel severity;
    private Map<String, Object> details;
    private String requestId;
    private String clientIp;
    private String userAgent;
}
```

### Integration Points
- **US-005**: Uses existing MongoTemplate configuration and TestContainers setup
- **US-007**: Integrates with existing transaction management
- **US-020**: Receives security events from SecurityContextValidator

## Business Rules

### Security Event Classification
1. **UNAUTHORIZED_ACCESS_ATTEMPT**: Token/path parameter mismatches
2. **PATH_PARAMETER_MANIPULATION**: URL tampering attempts
3. **TOKEN_PRIVILEGE_ESCALATION**: Users accessing unauthorized resources
4. **SESSION_HIJACKING_ATTEMPT**: Suspicious session activity
5. **CONCURRENT_SESSION_VIOLATION**: Multiple sessions from different locations

### Data Retention and Privacy
- Security events retained for 7 years for compliance
- Personal data anonymized after 90 days while maintaining investigation trails
- Access to audit logs restricted to authorized security personnel
- All audit log access must be logged for meta-auditing

### Performance Requirements
- Audit logging must be asynchronous to avoid impacting request processing
- Batch logging of events to optimize MongoDB performance
- Circuit breaker pattern for audit logging failures (request should not fail if audit logging fails)

## Definition of Done

### Implementation Complete
- [ ] SecurityAuditLogger class implemented with MongoDB integration
- [ ] SecurityEventDocument structure defined following US-005 patterns
- [ ] Security event types enum defined with all violation categories
- [ ] Asynchronous logging mechanism implemented

### MongoDB Integration
- [ ] Security events collection properly configured and indexed
- [ ] Audit logging uses existing MongoTemplate from US-005
- [ ] Integration with existing TestContainers setup for testing
- [ ] Document structure follows established patterns from US-005

### Testing Complete
- [ ] Unit tests for SecurityAuditLogger with MockBean patterns
- [ ] Integration tests using TestContainers MongoDB setup
- [ ] Security event storage verification tests
- [ ] Performance tests ensuring audit logging doesn't impact requests

### Compliance Verification
- [ ] GDPR compliance verified for personal data handling
- [ ] FERPA educational data protection requirements met
- [ ] Data retention policies implemented and tested
- [ ] Audit trail immutability verified

## Dependencies

### Prerequisites
- **US-005**: Repository Layer Implementation (MongoTemplate, TestContainers, document patterns)
- **US-007**: Application Service Integration (transaction management)
- **US-020**: SecurityContextValidator (security event source)

### External Dependencies
- MongoDB collection indexes for security event queries
- Compliance policy configuration for data retention
- Asynchronous processing infrastructure (Spring @Async)

## Risk Mitigation

### Technical Risks
- **Audit Logging Failure**: Circuit breaker prevents request failures
- **Performance Impact**: Asynchronous logging and batch processing
- **Storage Growth**: Automated data retention and cleanup processes
- **MongoDB Integration**: Leverage proven US-005 patterns

### Compliance Risks
- **Data Privacy**: Anonymization processes after retention periods
- **Audit Trail Integrity**: Immutable document structure with checksums
- **Access Control**: Restricted access with full access logging
- **Regulatory Changes**: Configurable retention and privacy policies

## Success Metrics

### Functional Metrics
- 100% security events successfully logged to MongoDB
- <5ms average audit logging processing time
- Zero audit logging failures causing request failures
- 100% integration with existing US-005 and US-007 infrastructure

### Compliance Metrics
- 100% compliance with GDPR data handling requirements
- 100% compliance with FERPA educational data protection
- 7-year audit trail retention with proper anonymization
- Zero compliance violations or audit findings

### Performance Metrics
- Audit logging adds <2ms to overall request processing
- Security events stored within existing transaction boundaries
- MongoDB collection remains performant with proper indexing
- Asynchronous processing maintains system responsiveness