# User Story 1018: End-to-End Integration Tests and K6 Performance Tests

## User Story

**As a** QA engineer
**I want** comprehensive end-to-end tests and performance tests for the query questions API
**So that** I can ensure the entire system works correctly and meets performance requirements

## Acceptance Criteria

- [ ] E2E test verifies complete flow from HTTP request to database query
- [ ] E2E test covers all major scenarios (basic query, filters, search, pagination)
- [ ] K6 performance test created for load testing
- [ ] K6 test verifies response time < 500ms (p95)
- [ ] K6 test verifies throughput > 100 RPS
- [ ] K6 test generates HTML and JSON reports
- [ ] All tests pass with JaCoCo coverage > 70%
- [ ] Allure annotations correctly applied
- [ ] K6 test scenarios documented

---

## TDD Cycle

### Allure Annotations Format

```java
@Epic("Use Case Query List of Questions of Question Bank")
@Story("1018.end-to-end-integration-tests")
```

---

## Phase 1: RED (Write Failing Tests)

### Objective
Write failing E2E tests that verify the complete system.

### Tasks

#### Task 1.1: Create Comprehensive E2E Test

**File**: `orchestration-layer/src/test/java/com/quizfun/orchestrationlayer/e2e/QueryQuestionsE2ETest.java`

```java
package com.quizfun.orchestrationlayer.e2e;

import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MongoDBContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.Instant;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1018.end-to-end-integration-tests")
@Testcontainers
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@DisplayName("Query Questions End-to-End Tests")
class QueryQuestionsE2ETest {

    @Container
    static MongoDBContainer mongoContainer = new MongoDBContainer("mongo:8.0")
            .withExposedPorts(27017)
            .withReuse(false);

    @DynamicPropertySource
    static void mongoProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoContainer::getReplicaSetUrl);
        registry.add("spring.data.mongodb.read-preference", () -> "primary");
    }

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private MongoTemplate mongoTemplate;

    private static final Long TEST_USER_ID = 12345L;
    private static final Long TEST_QUESTION_BANK_ID = 67890L;
    private static final String COLLECTION_NAME = "questions";

    private String baseUrl;

    @BeforeEach
    void setUp() {
        baseUrl = "http://localhost:" + port + "/api/v1/users/" + TEST_USER_ID
                + "/question-banks/" + TEST_QUESTION_BANK_ID + "/questions";

        mongoTemplate.dropCollection(COLLECTION_NAME);
        mongoTemplate.createCollection(COLLECTION_NAME);
        insertTestQuestions();
    }

    @AfterEach
    void tearDown() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
    }

    @Test
    @DisplayName("E2E: Should query questions with basic pagination")
    void shouldQueryQuestionsWithBasicPagination() {
        // WHEN: Making HTTP GET request
        String url = baseUrl + "?page=0&size=10";
        ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);

        // THEN: Should return 200 OK
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();

        // AND: Should have questions
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> questions = (List<Map<String, Object>>) response.getBody().get("questions");
        assertThat(questions).hasSize(10);

        // AND: Should have pagination metadata
        @SuppressWarnings("unchecked")
        Map<String, Object> pagination = (Map<String, Object>) response.getBody().get("pagination");
        assertThat(pagination.get("currentPage")).isEqualTo(0);
        assertThat(pagination.get("pageSize")).isEqualTo(10);
        assertThat(pagination.get("totalItems")).isEqualTo(50);
        assertThat(pagination.get("totalPages")).isEqualTo(5);
    }

    @Test
    @DisplayName("E2E: Should query questions with category filter")
    void shouldQueryQuestionsWithCategoryFilter() {
        // WHEN: Filtering by category
        String url = baseUrl + "?categories=Math&page=0&size=20";
        ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);

        // THEN: Should return filtered results
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        @SuppressWarnings("unchecked")
        List<Map<String, Object>> questions = (List<Map<String, Object>>) response.getBody().get("questions");
        assertThat(questions).hasSize(20);

        // Verify first question has Math category
        @SuppressWarnings("unchecked")
        Map<String, Object> firstQuestion = questions.get(0);
        @SuppressWarnings("unchecked")
        Map<String, Object> taxonomy = (Map<String, Object>) firstQuestion.get("taxonomy");
        @SuppressWarnings("unchecked")
        List<String> categories = (List<String>) taxonomy.get("categories");
        assertThat(categories).contains("Math");
    }

    @Test
    @DisplayName("E2E: Should query questions with text search")
    void shouldQueryQuestionsWithTextSearch() {
        // WHEN: Searching by text
        String url = baseUrl + "?searchText=equation&page=0&size=10";
        ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);

        // THEN: Should return matching results
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        @SuppressWarnings("unchecked")
        List<Map<String, Object>> questions = (List<Map<String, Object>>) response.getBody().get("questions");
        assertThat(questions).isNotEmpty();

        // Verify question text contains search term
        String questionText = (String) questions.get(0).get("questionText");
        assertThat(questionText.toLowerCase()).contains("equation");
    }

    @Test
    @DisplayName("E2E: Should query questions with combined filters")
    void shouldQueryQuestionsWithCombinedFilters() {
        // WHEN: Combining multiple filters
        String url = baseUrl + "?categories=Math&tags=algebra&searchText=equation&page=0&size=10";
        ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);

        // THEN: Should return results matching all filters
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        @SuppressWarnings("unchecked")
        List<Map<String, Object>> questions = (List<Map<String, Object>>) response.getBody().get("questions");
        assertThat(questions).isNotEmpty();
    }

    @Test
    @DisplayName("E2E: Should handle pagination across multiple pages")
    void shouldHandlePaginationAcrossMultiplePages() {
        // WHEN: Querying multiple pages
        String url1 = baseUrl + "?page=0&size=10";
        String url2 = baseUrl + "?page=1&size=10";
        String url3 = baseUrl + "?page=4&size=10";

        ResponseEntity<Map> response1 = restTemplate.getForEntity(url1, Map.class);
        ResponseEntity<Map> response2 = restTemplate.getForEntity(url2, Map.class);
        ResponseEntity<Map> response3 = restTemplate.getForEntity(url3, Map.class);

        // THEN: All pages should return successfully
        assertThat(response1.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response2.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response3.getStatusCode()).isEqualTo(HttpStatus.OK);

        // AND: Pages should have correct sizes
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> page1 = (List<Map<String, Object>>) response1.getBody().get("questions");
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> page2 = (List<Map<String, Object>>) response2.getBody().get("questions");
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> page3 = (List<Map<String, Object>>) response3.getBody().get("questions");

        assertThat(page1).hasSize(10);
        assertThat(page2).hasSize(10);
        assertThat(page3).isEmpty(); // Last page beyond total items
    }

    @Test
    @DisplayName("E2E: Should return empty list for non-existent user")
    void shouldReturnEmptyListForNonExistentUser() {
        // WHEN: Querying with non-existent user
        String url = "http://localhost:" + port + "/api/v1/users/99999/question-banks/"
                + TEST_QUESTION_BANK_ID + "/questions?page=0&size=10";
        ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);

        // THEN: Should return 200 OK with empty list
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        @SuppressWarnings("unchecked")
        List<Map<String, Object>> questions = (List<Map<String, Object>>) response.getBody().get("questions");
        assertThat(questions).isEmpty();

        @SuppressWarnings("unchecked")
        Map<String, Object> pagination = (Map<String, Object>) response.getBody().get("pagination");
        assertThat(pagination.get("totalItems")).isEqualTo(0);
    }

    @Test
    @DisplayName("E2E: Should return 400 for invalid page number")
    void shouldReturn400ForInvalidPageNumber() {
        // WHEN: Using invalid page number
        String url = baseUrl + "?page=-1&size=10";
        ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);

        // THEN: Should return 400 BAD REQUEST
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
    }

    @Test
    @DisplayName("E2E: Should verify complete response structure")
    void shouldVerifyCompleteResponseStructure() {
        // WHEN: Making request
        String url = baseUrl + "?page=0&size=1";
        ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);

        // THEN: Should have complete structure
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        Map<String, Object> body = response.getBody();
        assertThat(body).containsKeys("questions", "pagination");

        @SuppressWarnings("unchecked")
        List<Map<String, Object>> questions = (List<Map<String, Object>>) body.get("questions");
        assertThat(questions).hasSize(1);

        Map<String, Object> question = questions.get(0);
        assertThat(question).containsKeys(
                "questionId", "questionText", "questionType",
                "difficultyLevel", "taxonomy", "createdAt", "updatedAt"
        );

        @SuppressWarnings("unchecked")
        Map<String, Object> taxonomy = (Map<String, Object>) question.get("taxonomy");
        assertThat(taxonomy).containsKeys("categories", "tags", "quizzes");

        @SuppressWarnings("unchecked")
        Map<String, Object> pagination = (Map<String, Object>) body.get("pagination");
        assertThat(pagination).containsKeys(
                "currentPage", "pageSize", "totalItems", "totalPages"
        );
    }

    // Helper method

    private void insertTestQuestions() {
        Instant now = Instant.now();
        for (int i = 0; i < 50; i++) {
            TaxonomyDocument taxonomy = TaxonomyDocument.builder()
                    .categories(List.of("Math", "Algebra"))
                    .tags(List.of("algebra", "equations"))
                    .quizzes(List.of("midterm-2024"))
                    .build();

            QuestionDocument doc = QuestionDocument.builder()
                    .questionId(6000000000000L + i)
                    .userId(TEST_USER_ID)
                    .questionBankId(TEST_QUESTION_BANK_ID)
                    .questionText("Solve the equation for x: " + i)
                    .questionType("MCQ")
                    .difficultyLevel("EASY")
                    .taxonomy(taxonomy)
                    .createdAt(now.minusSeconds(100 - i))
                    .updatedAt(now.minusSeconds(100 - i))
                    .build();

            mongoTemplate.insert(doc, COLLECTION_NAME);
        }
    }
}
```

#### Task 1.2: Run E2E Tests (Should PASS if previous user stories complete)

```bash
mvn clean test -pl orchestration-layer -Dtest=QueryQuestionsE2ETest
```

**Expected Result**: All 8 E2E tests should PASS (system is already implemented).

---

## Phase 2: GREEN (Create K6 Performance Tests)

### Objective
Create K6 performance tests to verify response times and throughput.

### Tasks

#### Task 2.1: Create K6 Test Script

**File**: `api-system-test/test-query-questions.js`

```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';
import { htmlReport } from 'https://raw.githubusercontent.com/benc-uk/k6-reporter/main/dist/bundle.js';

// Custom metrics
const errorRate = new Rate('errors');
const queryDuration = new Trend('query_duration');

// Test configuration
export const options = {
    stages: [
        { duration: '30s', target: 50 },   // Ramp-up to 50 users
        { duration: '1m', target: 100 },   // Ramp-up to 100 users
        { duration: '2m', target: 100 },   // Stay at 100 users
        { duration: '30s', target: 0 },    // Ramp-down to 0 users
    ],
    thresholds: {
        http_req_duration: ['p(95)<500'],  // 95% of requests < 500ms
        http_req_failed: ['rate<0.01'],    // Error rate < 1%
        'errors': ['rate<0.01'],
    },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:8765';
const USER_ID = __ENV.USER_ID || '12345';
const QUESTION_BANK_ID = __ENV.QUESTION_BANK_ID || '67890';

export default function () {
    // Scenario 1: Basic query with pagination
    basicQuery();

    // Scenario 2: Query with category filter
    categoryFilter();

    // Scenario 3: Query with text search
    textSearch();

    // Scenario 4: Query with combined filters
    combinedFilters();

    sleep(1);
}

function basicQuery() {
    const url = `${BASE_URL}/api/v1/users/${USER_ID}/question-banks/${QUESTION_BANK_ID}/questions?page=0&size=20`;

    const response = http.get(url, {
        tags: { scenario: 'basic_query' },
    });

    const success = check(response, {
        'Basic Query: status is 200': (r) => r.status === 200,
        'Basic Query: has questions': (r) => {
            const body = JSON.parse(r.body);
            return body.questions !== undefined;
        },
        'Basic Query: has pagination': (r) => {
            const body = JSON.parse(r.body);
            return body.pagination !== undefined;
        },
    });

    errorRate.add(!success);
    queryDuration.add(response.timings.duration);
}

function categoryFilter() {
    const url = `${BASE_URL}/api/v1/users/${USER_ID}/question-banks/${QUESTION_BANK_ID}/questions?categories=Math&page=0&size=20`;

    const response = http.get(url, {
        tags: { scenario: 'category_filter' },
    });

    const success = check(response, {
        'Category Filter: status is 200': (r) => r.status === 200,
        'Category Filter: response time < 500ms': (r) => r.timings.duration < 500,
    });

    errorRate.add(!success);
    queryDuration.add(response.timings.duration);
}

function textSearch() {
    const url = `${BASE_URL}/api/v1/users/${USER_ID}/question-banks/${QUESTION_BANK_ID}/questions?searchText=equation&page=0&size=20`;

    const response = http.get(url, {
        tags: { scenario: 'text_search' },
    });

    const success = check(response, {
        'Text Search: status is 200': (r) => r.status === 200,
        'Text Search: response time < 500ms': (r) => r.timings.duration < 500,
    });

    errorRate.add(!success);
    queryDuration.add(response.timings.duration);
}

function combinedFilters() {
    const url = `${BASE_URL}/api/v1/users/${USER_ID}/question-banks/${QUESTION_BANK_ID}/questions?categories=Math&tags=algebra&searchText=solve&page=0&size=10`;

    const response = http.get(url, {
        tags: { scenario: 'combined_filters' },
    });

    const success = check(response, {
        'Combined Filters: status is 200': (r) => r.status === 200,
        'Combined Filters: response time < 500ms': (r) => r.timings.duration < 500,
    });

    errorRate.add(!success);
    queryDuration.add(response.timings.duration);
}

export function handleSummary(data) {
    const scriptPath = __ENV.K6_SCRIPT_PATH || 'test-query-questions.js';
    const scriptName = scriptPath.split('/').pop().replace('.js', '');
    const reportDir = `api-system-test/reports/${scriptName}`;

    return {
        [`${reportDir}/summary-report.html`]: htmlReport(data, {
            title: 'Query Questions API - Performance Test Report'
        }),
        [`${reportDir}/summary-data.json`]: JSON.stringify(data, null, 2),
        stdout: textSummary(data, { indent: ' ', enableColors: true }),
    };
}

function textSummary(data, options) {
    // Generate text summary for console output
    return `
========================================================
Query Questions API - Performance Test Summary
========================================================

Test Duration: ${data.state.testRunDurationMs / 1000}s

Requests:
  Total:       ${data.metrics.http_reqs.values.count}
  Success:     ${data.metrics.http_reqs.values.count - (data.metrics.http_req_failed.values.passes || 0)}
  Failed:      ${data.metrics.http_req_failed.values.passes || 0}

Response Times:
  Min:         ${data.metrics.http_req_duration.values.min.toFixed(2)}ms
  Avg:         ${data.metrics.http_req_duration.values.avg.toFixed(2)}ms
  Max:         ${data.metrics.http_req_duration.values.max.toFixed(2)}ms
  P95:         ${data.metrics.http_req_duration.values['p(95)'].toFixed(2)}ms

Throughput:
  RPS:         ${(data.metrics.http_reqs.values.count / (data.state.testRunDurationMs / 1000)).toFixed(2)}

Custom Metrics:
  Error Rate:  ${((data.metrics.errors?.values.rate || 0) * 100).toFixed(2)}%
  Query Avg:   ${(data.metrics.query_duration?.values.avg || 0).toFixed(2)}ms

========================================================
`;
}
```

#### Task 2.2: Create K6 Test Documentation

**File**: `api-system-test/docs/test-query-questions-guide.md`

```markdown
# Query Questions API - Performance Test Guide

## Overview

K6 performance test for the Query Questions API endpoint that verifies:
- Response time < 500ms (p95)
- Throughput > 100 RPS
- Error rate < 1%

## Test Scenarios

1. **Basic Query**: Simple pagination query
2. **Category Filter**: Filter by hierarchical categories
3. **Text Search**: Full-text search on question content
4. **Combined Filters**: Multiple filters simultaneously

## Running the Test

### Prerequisites

- K6 installed: `brew install k6` (Mac) or `choco install k6` (Windows)
- Application running on port 8765
- MongoDB with test data

### Start Application

```bash
mvn spring-boot:run -pl orchestration-layer
```

### Run K6 Test

```bash
# Basic run
k6 run api-system-test/test-query-questions.js

# With custom parameters
k6 run \
  -e BASE_URL=http://localhost:8765 \
  -e USER_ID=12345 \
  -e QUESTION_BANK_ID=67890 \
  -e K6_SCRIPT_PATH=api-system-test/test-query-questions.js \
  api-system-test/test-query-questions.js
```

## Test Configuration

- **Ramp-up**: 30s to 50 users
- **Scale**: 1m to 100 users
- **Duration**: 2m at 100 users
- **Ramp-down**: 30s to 0 users
- **Total Duration**: 4 minutes

## Performance Targets

- **p95 Response Time**: < 500ms
- **Throughput**: > 100 RPS
- **Error Rate**: < 1%

## Reports

Reports are generated in:
```
api-system-test/reports/test-query-questions/
├── summary-report.html  (Visual HTML report)
└── summary-data.json    (Raw data for analysis)
```

Open HTML report:
```bash
open api-system-test/reports/test-query-questions/summary-report.html
```

## Interpreting Results

### Success Criteria

✅ All thresholds passed
✅ p95 < 500ms
✅ Error rate < 1%
✅ Throughput > 100 RPS

### Common Issues

**High Response Times:**
- Check MongoDB indexes
- Review query complexity
- Check network latency

**High Error Rate:**
- Check application logs
- Verify MongoDB connection
- Check rate limiting

**Low Throughput:**
- Increase virtual users
- Check system resources
- Review application performance
```

#### Task 2.3: Run K6 Test

```bash
# Start application
mvn spring-boot:run -pl orchestration-layer &

# Wait for startup
sleep 30

# Run K6 test
k6 run -e K6_SCRIPT_PATH=api-system-test/test-query-questions.js api-system-test/test-query-questions.js
```

**Expected Result**: K6 test should pass all thresholds and generate reports.

---

## Phase 3: REFACTOR (Document and Finalize)

### Objective
Finalize documentation and ensure all tests are maintainable.

### Tasks

#### Task 3.1: Add README for API System Tests

**File**: `api-system-test/README.md`

```markdown
# API System Tests

Performance and integration tests for Quiz CMS API system.

## Test Suites

### 1. Upsert Question with Taxonomy
- **File**: `test-upsert-question-with-taxonomy.js`
- **Endpoint**: POST `/api/v1/users/{userId}/question-banks/{questionBankId}/questions`
- **Purpose**: Test question creation/update performance

### 2. Query Questions
- **File**: `test-query-questions.js`
- **Endpoint**: GET `/api/v1/users/{userId}/question-banks/{questionBankId}/questions`
- **Purpose**: Test question query performance with filters and pagination

## Running All Tests

```bash
# Run all K6 tests
for file in api-system-test/test-*.js; do
  k6 run -e K6_SCRIPT_PATH="$file" "$file"
done
```

## Reports

All test reports are generated in `api-system-test/reports/` with subdirectories per test.

## Performance Targets

- **Response Time (p95)**: < 500ms
- **Throughput**: > 100 RPS
- **Error Rate**: < 1%
```

#### Task 3.2: Run All Tests and Generate Final Reports

```bash
# Run all unit and integration tests
mvn clean verify

# Generate Allure report
mvn allure:report

# Run K6 tests
k6 run api-system-test/test-query-questions.js
```

#### Task 3.3: Verify Coverage Reports

```bash
# Check coverage for question-bank-query module
open internal-layer/question-bank-query/target/site/jacoco/index.html

# Check coverage for orchestration-layer
open orchestration-layer/target/site/jacoco/index.html
```

Verify:
- ✅ Line coverage > 70%
- ✅ Branch coverage > 60%
- ✅ All critical paths covered

---

## Definition of Done

- [ ] E2E tests created and passing (8 tests)
- [ ] E2E tests cover major scenarios
- [ ] K6 performance test created
- [ ] K6 test verifies p95 < 500ms
- [ ] K6 test verifies throughput > 100 RPS
- [ ] K6 generates HTML and JSON reports
- [ ] Test documentation created
- [ ] API system test README created
- [ ] All tests pass (unit, integration, E2E)
- [ ] JaCoCo coverage >= 70%
- [ ] Allure report generated successfully
- [ ] Performance targets met
- [ ] Code reviewed and approved

---

## Testing Checklist

### E2E Tests
- [ ] ✅ Basic pagination query
- [ ] ✅ Category filter
- [ ] ✅ Text search
- [ ] ✅ Combined filters
- [ ] ✅ Pagination across multiple pages
- [ ] ✅ Empty list for non-existent user
- [ ] ✅ 400 for invalid parameters
- [ ] ✅ Complete response structure verification

### K6 Performance Tests
- [ ] ✅ Basic query scenario
- [ ] ✅ Category filter scenario
- [ ] ✅ Text search scenario
- [ ] ✅ Combined filters scenario
- [ ] ✅ p95 response time < 500ms
- [ ] ✅ Throughput > 100 RPS
- [ ] ✅ Error rate < 1%
- [ ] ✅ HTML report generated
- [ ] ✅ JSON report generated

### Coverage Reports
- [ ] ✅ JaCoCo line coverage > 70%
- [ ] ✅ JaCoCo branch coverage > 60%
- [ ] ✅ Allure report with all stories

---

## Estimated Effort

- **RED Phase (E2E Tests)**: 2 hours
- **GREEN Phase (K6 Tests)**: 2.5 hours
- **REFACTOR Phase (Documentation)**: 1.5 hours
- **Total**: 6 hours

---

## Dependencies

- **1010-1017**: All previous user stories (complete implementation)
- **K6**: Performance testing tool
- **Testcontainers**: For E2E tests
- **MongoDB**: With test data

---

## Notes

### E2E vs Integration Tests

- **Integration Tests**: Test individual layers (controller, service, repository)
- **E2E Tests**: Test complete flow from HTTP to database

### K6 Test Stages

1. **Ramp-up (30s)**: Gradually increase load to 50 users
2. **Scale (1m)**: Increase to 100 users
3. **Steady State (2m)**: Maintain 100 users
4. **Ramp-down (30s)**: Decrease to 0 users

### Performance Baselines

Based on requirements:
- **p95 Response Time**: < 500ms (95th percentile)
- **Throughput**: > 100 RPS (requests per second)
- **Error Rate**: < 1% (system reliability)

### Report Locations

```
api-system-test/reports/
├── test-query-questions/
│   ├── summary-report.html
│   └── summary-data.json
└── test-upsert-question-with-taxonomy/
    ├── summary-report.html
    └── summary-data.json

target/
├── site/jacoco/index.html          (Coverage)
└── allure-report/index.html        (Test results)
```

### Running in CI/CD

```yaml
# Example GitHub Actions workflow
- name: Run Integration Tests
  run: mvn clean verify

- name: Run K6 Performance Tests
  run: |
    k6 run --quiet api-system-test/test-query-questions.js

- name: Upload Reports
  uses: actions/upload-artifact@v3
  with:
    name: test-reports
    path: |
      **/target/site/jacoco/
      **/target/allure-report/
      api-system-test/reports/
```

## Summary

This final user story completes the Query use case by:
1. ✅ Verifying end-to-end functionality
2. ✅ Validating performance requirements
3. ✅ Generating comprehensive reports
4. ✅ Documenting test procedures

All 9 user stories (1010-1018) are now complete!
