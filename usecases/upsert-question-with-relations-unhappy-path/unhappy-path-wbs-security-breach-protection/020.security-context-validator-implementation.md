# US-020: Security Context Validator Implementation

## User Story
**As a** system security administrator
**I want** the question upsert system to validate JWT token consistency with path parameters
**So that** malicious users cannot manipulate URL parameters to access other users' question banks

## Epic
Security Breach Protection

## Story
Implement SecurityContextValidator to extend the existing US-003 validation chain with authentication context verification

## Acceptance Criteria

### Primary Security Validation
- [ ] **AC-020.1**: JWT token user ID must exactly match the `userId` path parameter
- [ ] **AC-020.2**: Security violations must be immediately logged with comprehensive audit information
- [ ] **AC-020.3**: Failed security validation must return appropriate error codes from existing US-003 ValidationErrorCode enum
- [ ] **AC-020.4**: Security validation must integrate seamlessly with existing US-003 validation chain

### Integration Requirements
- [ ] **AC-020.5**: SecurityContextValidator must extend the existing ValidationHandler base class from US-003
- [ ] **AC-020.6**: Must reuse existing RetryHelper from US-003 for resilient validation operations
- [ ] **AC-020.7**: Must integrate with existing ValidationChainMetrics from US-003 for performance monitoring
- [ ] **AC-020.8**: Must maintain compatibility with existing Result<T> pattern from US-003

### Performance Requirements
- [ ] **AC-020.9**: Security validation must add less than 20ms to request processing time
- [ ] **AC-020.10**: Validation metrics must be collected and reported via existing metrics infrastructure
- [ ] **AC-020.11**: Failed validation must not impact legitimate user request processing performance

## Test-Driven Development Cycle

### Epic and Story Annotations for Tests
- **@Epic**: `"Security Breach Protection"`
- **@Story**: `"020.security-context-validator-implementation"`

### Red-Green-Refactor Cycle

#### Phase 1: RED - Write Failing Tests
**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/security/SecurityContextValidatorTest.java`

```java
@SpringBootTest
@ActiveProfiles("test")
@ExtendWith(AllureExtension.class)
@TestMethodOrder(OrderAnnotation.class)
class SecurityContextValidatorTest {

    @Container
    static MongoDBContainer mongoDBContainer = new MongoDBContainer(DockerImageName.parse("mongo:6.0"))
            .withReuse(true);

    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoDBContainer::getReplicaSetUrl);
    }

    @Autowired
    private SecurityContextValidator securityValidator;

    @Test
    @Order(1)
    @Epic("Security Breach Protection")
    @Story("020.security-context-validator-implementation")
    @DisplayName("Should reject request when JWT token user ID differs from path parameter")
    @Description("Validates that path parameter manipulation attacks are detected and blocked")
    void shouldRejectMismatchedUserIdAttack() {
        // RED: This test should fail initially
        var maliciousCommand = UpsertQuestionCommand.builder()
            .userId(1001L)  // Path parameter
            .questionBankId(2001L)
            .build();

        // Mock JWT context with different user ID
        SecurityContextHolder.getContext().setAuthentication(
            new JwtAuthenticationToken(createJwtToken("1002"))  // Token contains different user
        );

        var result = securityValidator.validate(maliciousCommand);

        assertThat(result.isFailure()).isTrue();
        assertThat(result.getErrorCode()).isEqualTo(ValidationErrorCode.UNAUTHORIZED_ACCESS);
    }

    @Test
    @Order(2)
    @Epic("Security Breach Protection")
    @Story("020.security-context-validator-implementation")
    @DisplayName("Should allow request when JWT token user ID matches path parameter")
    @Description("Validates that legitimate users can access their own resources")
    void shouldAllowValidUserAccess() {
        // RED: This test should fail initially
        var validCommand = UpsertQuestionCommand.builder()
            .userId(1001L)
            .questionBankId(2001L)
            .build();

        SecurityContextHolder.getContext().setAuthentication(
            new JwtAuthenticationToken(createJwtToken("1001"))  // Matching user ID
        );

        var result = securityValidator.validate(validCommand);

        assertThat(result.isSuccess()).isTrue();
    }
}
```

#### Phase 2: GREEN - Implement Minimal Working Solution
**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/security/SecurityContextValidator.java`

```java
@Component
public class SecurityContextValidator extends ValidationHandler {

    private final SecurityAuditLogger auditLogger;
    private final RetryHelper retryHelper; // Reuse from US-003
    private final ValidationChainMetrics metrics; // Reuse from US-003

    public SecurityContextValidator(ValidationHandler next,
                                  SecurityAuditLogger auditLogger,
                                  RetryHelper retryHelper,
                                  ValidationChainMetrics metrics) {
        super(next);
        this.auditLogger = auditLogger;
        this.retryHelper = retryHelper;
        this.metrics = metrics;
    }

    @Override
    public Result<Void> validate(UpsertQuestionCommand command) {
        var timer = metrics.startTimer("security_context_validation");

        try {
            // 1. Extract user from JWT token
            var authContext = SecurityContextHolder.getContext().getAuthentication();
            if (authContext == null || !(authContext instanceof JwtAuthenticationToken)) {
                auditLogger.logSecurityViolation(
                    SecurityEventType.INVALID_AUTHENTICATION_TOKEN,
                    command.getUserId(),
                    "Missing or invalid authentication token"
                );
                return Result.failure("Authentication required", ValidationErrorCode.UNAUTHORIZED_ACCESS);
            }

            Long tokenUserId = Long.valueOf(authContext.getName());

            // 2. Compare with command user ID
            if (!tokenUserId.equals(command.getUserId())) {
                auditLogger.logSecurityViolation(
                    SecurityEventType.PATH_PARAMETER_MANIPULATION,
                    tokenUserId,
                    String.format("Token user %d attempted access to user %d resources",
                                tokenUserId, command.getUserId())
                );
                return Result.failure("Access denied", ValidationErrorCode.UNAUTHORIZED_ACCESS);
            }

            // 3. Continue to next validator
            return checkNext(command);

        } finally {
            metrics.endTimer(timer);
        }
    }
}
```

#### Phase 3: REFACTOR - Enhance and Optimize
- Extract security event creation to builder pattern
- Add retry logic for transient authentication failures
- Optimize performance with caching where appropriate
- Add comprehensive logging context

### Verification Approach for Each Acceptance Criterion

#### AC-020.1 Verification: JWT Token Matching
```java
@Test
@Epic("Security Breach Protection")
@Story("020.security-context-validator-implementation")
@DisplayName("Verify JWT token user ID exactly matches userId path parameter")
void verifyJwtTokenUserIdMatching() {
    // Test various user ID formats and edge cases
    // Verify exact matching (no approximation)
    // Test numeric vs string comparisons
}
```

#### AC-020.2 Verification: Security Violation Logging
```java
@Test
@Epic("Security Breach Protection")
@Story("020.security-context-validator-implementation")
@DisplayName("Verify security violations logged with comprehensive audit information")
void verifySecurityViolationLogging() {
    // Verify audit log entry created
    // Check all required fields present
    // Validate timestamp, user context, request details
}
```

#### AC-020.9 Verification: Performance Requirements
```java
@Test
@Epic("Security Breach Protection")
@Story("020.security-context-validator-implementation")
@DisplayName("Verify security validation adds less than 20ms processing time")
void verifyPerformanceRequirements() {
    var startTime = System.nanoTime();
    securityValidator.validate(validCommand);
    var duration = Duration.ofNanos(System.nanoTime() - startTime);

    assertThat(duration).isLessThan(Duration.ofMillis(20));
}
```

## Technical Requirements

### Concrete File Locations
- **Main Implementation**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/security/SecurityContextValidator.java`
- **Test Implementation**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/security/SecurityContextValidatorTest.java`
- **Configuration**: Update `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/config/ValidationChainConfiguration.java`

### Implementation Order
1. Create `SecurityAuditLogger` interface and implementation (depends on US-021)
2. Implement `SecurityContextValidator` extending `ValidationHandler`
3. Update validation chain configuration to include security validator
4. Add security validator to existing validation chain in `QuestionApplicationService`
5. Write comprehensive test suite following TDD cycle above

### Maven Commands for TDD Cycle
```bash
# Run specific test during RED phase (should fail)
mvn -Dtest=SecurityContextValidatorTest#shouldRejectMismatchedUserIdAttack test -pl internal-layer/question-bank

# Run all security tests during GREEN phase
mvn -Dtest=SecurityContextValidatorTest test -pl internal-layer/question-bank

# Run full validation suite during REFACTOR phase
mvn test -pl internal-layer/question-bank

# Performance verification
mvn verify -pl internal-layer/question-bank
```

### Integration Points
- **US-003**: Extends ValidationHandler, uses RetryHelper and ValidationChainMetrics
- **US-005**: Integrates with repository layer for audit logging storage
- **US-007**: Works within existing application service transaction boundaries

## Business Rules

### Security Validation Rules
1. **Token-Parameter Consistency**: JWT token subject must match userId path parameter exactly
2. **Audit Logging**: All validation attempts (success and failure) must be logged for compliance
3. **Fail-Safe**: Any security validation failure must immediately block the request
4. **Non-Disclosure**: Security error responses must not reveal system internal information

### Error Handling
- Use existing ValidationErrorCode.UNAUTHORIZED_ACCESS for token mismatches
- Log security violations with full context for forensic analysis
- Return minimal error information to prevent information disclosure
- Continue to next validator only on successful security validation

## Definition of Done

### Implementation Complete
- [ ] SecurityContextValidator class implemented extending ValidationHandler
- [ ] JWT token extraction and validation logic implemented
- [ ] Security audit logging integration completed
- [ ] Integration with existing US-003 infrastructure completed

### Testing Complete
- [ ] Unit tests implemented following existing US-003 patterns
- [ ] Integration tests using TestContainers as per US-005 standards
- [ ] Security test scenarios covering token manipulation attacks
- [ ] Performance tests validating <20ms validation time

### Integration Verified
- [ ] All existing US-003 through US-007 tests continue to pass
- [ ] Security validator integrates seamlessly in validation chain
- [ ] Metrics and monitoring integration functional
- [ ] Audit logging stored correctly in MongoDB

## Dependencies

### Prerequisites
- **US-003**: Validation Chain Implementation (ValidationHandler, RetryHelper, ValidationChainMetrics)
- **US-005**: Repository Layer Implementation (MongoDB connectivity, TestContainers setup)
- **US-007**: Application Service Integration (transaction management)

### External Dependencies
- Spring Security framework for JWT token handling
- MongoDB audit logging collection setup
- Existing monitoring and metrics infrastructure

## Risk Mitigation

### Technical Risks
- **Integration Complexity**: Mitigated by following established US-003 patterns
- **Performance Impact**: Mitigated by reusing existing retry and metrics infrastructure
- **Security Gaps**: Mitigated by comprehensive test coverage of attack scenarios

### Business Risks
- **False Positives**: Mitigated by thorough testing with legitimate user scenarios
- **System Disruption**: Mitigated by maintaining existing validation chain compatibility
- **Audit Compliance**: Mitigated by comprehensive security event logging

## Success Metrics

### Security Metrics
- 100% detection rate for token manipulation attacks
- <1% false positive rate for legitimate requests
- Security validation time <20ms per request
- 100% audit logging coverage for security events

### Integration Metrics
- All existing tests continue to pass (regression prevention)
- Security validation integrates without breaking changes
- Performance impact <3% on overall system response time
- MongoDB audit storage operates within existing transaction boundaries