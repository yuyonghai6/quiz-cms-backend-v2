# User Story 1015: Query Application Service

## User Story

**As a** backend developer
**I want** to create an application service that orchestrates question query operations
**So that** the business logic for querying questions with pagination metadata is properly encapsulated

## Acceptance Criteria

- [ ] Application service interface created (input port)
- [ ] Application service implementation created without domain layer
- [ ] Service calculates pagination metadata from count and page info
- [ ] Service delegates to repository for queries and counts
- [ ] Service validates request parameters
- [ ] Service returns complete response with questions and pagination
- [ ] Unit tests verify service logic
- [ ] Integration tests verify service with repository
- [ ] All tests pass with JaCoCo coverage > 70%
- [ ] Allure annotations correctly applied

---

## TDD Cycle

### Allure Annotations Format

```java
@Epic("Use Case Query List of Questions of Question Bank")
@Story("1015.query-application-service")
```

---

## Phase 1: RED (Write Failing Tests)

### Objective
Write failing tests for application service.

### Tasks

#### Task 1.1: Create Application Service Interface (Input Port)

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/ports/in/IQueryQuestionsService.java`

```java
package com.quizfun.questionbankquery.application.ports.in;

import com.quizfun.globalshared.mediator.Result;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsResponse;

/**
 * Input port for querying questions.
 *
 * <p>This interface defines the contract for the application service
 * in hexagonal architecture (ports and adapters pattern).
 */
public interface IQueryQuestionsService {

    /**
     * Queries questions with filters, pagination, and sorting.
     *
     * @param request Query request with filters and pagination
     * @return Result containing questions with pagination metadata, or error
     */
    Result<QueryQuestionsResponse> queryQuestions(QueryQuestionsRequest request);
}
```

#### Task 1.2: Create Unit Tests for Application Service

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/services/QueryQuestionsServiceTest.java`

```java
package com.quizfun.questionbankquery.application.services;

import com.quizfun.globalshared.mediator.Result;
import com.quizfun.questionbankquery.application.dto.PaginationMetadata;
import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsResponse;
import com.quizfun.questionbankquery.application.ports.in.IQueryQuestionsService;
import com.quizfun.questionbankquery.application.ports.out.IQuestionQueryRepository;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.Instant;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1015.query-application-service")
@ExtendWith(MockitoExtension.class)
@DisplayName("Query Application Service Unit Tests")
class QueryQuestionsServiceTest {

    @Mock
    private IQuestionQueryRepository questionQueryRepository;

    private IQueryQuestionsService queryQuestionsService;

    @BeforeEach
    void setUp() {
        queryQuestionsService = new QueryQuestionsService(questionQueryRepository);
    }

    @Test
    @DisplayName("Should return questions with pagination metadata")
    void shouldReturnQuestionsWithPaginationMetadata() {
        // GIVEN: Repository returns 2 questions and total count of 50
        List<QuestionDTO> mockQuestions = List.of(
                new QuestionDTO(1L, "Q1", "MCQ", "EASY", null, null, Instant.now(), Instant.now()),
                new QuestionDTO(2L, "Q2", "MCQ", "EASY", null, null, Instant.now(), Instant.now())
        );

        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(0)
                .size(20)
                .build();

        when(questionQueryRepository.queryQuestions(request)).thenReturn(mockQuestions);
        when(questionQueryRepository.countQuestions(eq(12345L), eq(67890L), any())).thenReturn(50L);

        // WHEN: Querying questions
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Should return success with questions and pagination
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().questions()).hasSize(2);

        PaginationMetadata pagination = result.getValue().pagination();
        assertThat(pagination.currentPage()).isZero();
        assertThat(pagination.pageSize()).isEqualTo(20);
        assertThat(pagination.totalItems()).isEqualTo(50);
        assertThat(pagination.totalPages()).isEqualTo(3); // ceil(50/20) = 3
    }

    @Test
    @DisplayName("Should return empty list when no questions match")
    void shouldReturnEmptyListWhenNoQuestionsMatch() {
        // GIVEN: Repository returns empty list
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(0)
                .size(20)
                .build();

        when(questionQueryRepository.queryQuestions(request)).thenReturn(List.of());
        when(questionQueryRepository.countQuestions(eq(12345L), eq(67890L), any())).thenReturn(0L);

        // WHEN: Querying questions
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Should return success with empty list
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().questions()).isEmpty();
        assertThat(result.getValue().pagination().totalItems()).isZero();
        assertThat(result.getValue().pagination().totalPages()).isZero();
    }

    @Test
    @DisplayName("Should calculate total pages correctly")
    void shouldCalculateTotalPagesCorrectly() {
        // GIVEN: 95 total items with page size 20
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(0)
                .size(20)
                .build();

        when(questionQueryRepository.queryQuestions(request)).thenReturn(List.of());
        when(questionQueryRepository.countQuestions(eq(12345L), eq(67890L), any())).thenReturn(95L);

        // WHEN: Querying questions
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Total pages should be 5 (ceil(95/20))
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().pagination().totalPages()).isEqualTo(5);
    }

    @Test
    @DisplayName("Should handle filters in count query")
    void shouldHandleFiltersInCountQuery() {
        // GIVEN: Request with filters
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .categories(List.of("Math"))
                .tags(List.of("algebra"))
                .page(0)
                .size(20)
                .build();

        when(questionQueryRepository.queryQuestions(request)).thenReturn(List.of());
        when(questionQueryRepository.countQuestions(eq(12345L), eq(67890L), any())).thenReturn(10L);

        // WHEN: Querying with filters
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Should pass request to count method for filtering
        verify(questionQueryRepository).countQuestions(eq(12345L), eq(67890L), eq(request));
        assertThat(result.getValue().pagination().totalItems()).isEqualTo(10);
    }

    @Test
    @DisplayName("Should return failure when repository throws exception")
    void shouldReturnFailureWhenRepositoryThrowsException() {
        // GIVEN: Repository throws exception
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .build();

        when(questionQueryRepository.queryQuestions(request))
                .thenThrow(new RuntimeException("Database connection failed"));

        // WHEN: Querying questions
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Should return failure
        assertThat(result.isSuccess()).isFalse();
        assertThat(result.getError()).contains("Database connection failed");
    }

    @Test
    @DisplayName("Should validate request is not null")
    void shouldValidateRequestIsNotNull() {
        // GIVEN: Null request

        // WHEN: Querying with null request
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(null);

        // THEN: Should return failure
        assertThat(result.isSuccess()).isFalse();
        assertThat(result.getError()).contains("Request cannot be null");
    }

    @Test
    @DisplayName("Should call repository methods exactly once")
    void shouldCallRepositoryMethodsExactlyOnce() {
        // GIVEN: Valid request
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .build();

        when(questionQueryRepository.queryQuestions(request)).thenReturn(List.of());
        when(questionQueryRepository.countQuestions(eq(12345L), eq(67890L), any())).thenReturn(0L);

        // WHEN: Querying questions
        queryQuestionsService.queryQuestions(request);

        // THEN: Repository methods called exactly once
        verify(questionQueryRepository, times(1)).queryQuestions(request);
        verify(questionQueryRepository, times(1)).countQuestions(eq(12345L), eq(67890L), any());
    }

    @Test
    @DisplayName("Should handle pagination for last page correctly")
    void shouldHandlePaginationForLastPageCorrectly() {
        // GIVEN: Last page with partial results (42 total, page 2, size 20)
        List<QuestionDTO> mockQuestions = List.of(
                new QuestionDTO(1L, "Q1", "MCQ", "EASY", null, null, Instant.now(), Instant.now()),
                new QuestionDTO(2L, "Q2", "MCQ", "EASY", null, null, Instant.now(), Instant.now())
        );

        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(2) // Third page (0-indexed)
                .size(20)
                .build();

        when(questionQueryRepository.queryQuestions(request)).thenReturn(mockQuestions);
        when(questionQueryRepository.countQuestions(eq(12345L), eq(67890L), any())).thenReturn(42L);

        // WHEN: Querying last page
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Pagination should be correct
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().questions()).hasSize(2);
        assertThat(result.getValue().pagination().currentPage()).isEqualTo(2);
        assertThat(result.getValue().pagination().totalPages()).isEqualTo(3); // ceil(42/20)
    }
}
```

#### Task 1.3: Create Integration Test for Service

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/services/QueryQuestionsServiceIntegrationTest.java`

```java
package com.quizfun.questionbankquery.application.services;

import com.quizfun.globalshared.mediator.Result;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsResponse;
import com.quizfun.questionbankquery.application.ports.in.IQueryQuestionsService;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MongoDBContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.Instant;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1015.query-application-service")
@Testcontainers
@SpringBootTest
@DisplayName("Query Application Service Integration Tests")
class QueryQuestionsServiceIntegrationTest {

    @Container
    static MongoDBContainer mongoContainer = new MongoDBContainer("mongo:8.0")
            .withExposedPorts(27017)
            .withReuse(false);

    @DynamicPropertySource
    static void mongoProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoContainer::getReplicaSetUrl);
        registry.add("spring.data.mongodb.read-preference", () -> "primary");
    }

    @Autowired
    private MongoTemplate mongoTemplate;

    @Autowired
    private IQueryQuestionsService queryQuestionsService;

    private static final Long TEST_USER_ID = 12345L;
    private static final Long TEST_QUESTION_BANK_ID = 67890L;
    private static final String COLLECTION_NAME = "questions";

    @BeforeEach
    void setUp() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
        mongoTemplate.createCollection(COLLECTION_NAME);
        insertTestQuestions(25); // Insert 25 questions
    }

    @AfterEach
    void tearDown() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
    }

    @Test
    @DisplayName("Should return questions with correct pagination metadata")
    void shouldReturnQuestionsWithCorrectPaginationMetadata() {
        // GIVEN: 25 questions in database
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying first page
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Should return success with correct data
        assertThat(result.isSuccess()).isTrue();

        QueryQuestionsResponse response = result.getValue();
        assertThat(response.questions()).hasSize(10);
        assertThat(response.pagination().currentPage()).isZero();
        assertThat(response.pagination().pageSize()).isEqualTo(10);
        assertThat(response.pagination().totalItems()).isEqualTo(25);
        assertThat(response.pagination().totalPages()).isEqualTo(3); // ceil(25/10)
    }

    @Test
    @DisplayName("Should handle last page with partial results")
    void shouldHandleLastPageWithPartialResults() {
        // GIVEN: 25 questions in database
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(2) // Last page
                .size(10)
                .build();

        // WHEN: Querying last page
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Should return 5 questions (25 - 20)
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().questions()).hasSize(5);
        assertThat(result.getValue().pagination().currentPage()).isEqualTo(2);
    }

    @Test
    @DisplayName("Should return empty result when no questions match")
    void shouldReturnEmptyResultWhenNoQuestionsMatch() {
        // GIVEN: Request for different user
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(99999L)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        Result<QueryQuestionsResponse> result = queryQuestionsService.queryQuestions(request);

        // THEN: Should return empty list
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().questions()).isEmpty();
        assertThat(result.getValue().pagination().totalItems()).isZero();
    }

    // Helper method

    private void insertTestQuestions(int count) {
        Instant now = Instant.now();
        for (int i = 0; i < count; i++) {
            QuestionDocument doc = QuestionDocument.builder()
                    .questionId(3000000000000L + i)
                    .userId(TEST_USER_ID)
                    .questionBankId(TEST_QUESTION_BANK_ID)
                    .questionText("Test Question " + i)
                    .questionType("MCQ")
                    .createdAt(now.minusSeconds(count - i))
                    .updatedAt(now.minusSeconds(count - i))
                    .build();
            mongoTemplate.insert(doc, COLLECTION_NAME);
        }
    }
}
```

#### Task 1.4: Run Tests (Should FAIL)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=*QueryQuestionsService*
```

**Expected Result**: Tests should FAIL because service implementation doesn't exist.

---

## Phase 2: GREEN (Make Tests Pass)

### Objective
Implement application service to make tests pass.

### Tasks

#### Task 2.1: Implement Application Service

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/services/QueryQuestionsService.java`

```java
package com.quizfun.questionbankquery.application.services;

import com.quizfun.globalshared.mediator.Result;
import com.quizfun.questionbankquery.application.dto.PaginationMetadata;
import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsResponse;
import com.quizfun.questionbankquery.application.ports.in.IQueryQuestionsService;
import com.quizfun.questionbankquery.application.ports.out.IQuestionQueryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Application service for querying questions.
 *
 * <p>This service orchestrates the query operation without domain logic complexity.
 * It delegates to the repository and calculates pagination metadata.
 *
 * <p><strong>Why No Domain Layer?</strong></p>
 * <ul>
 *   <li>Query operations don't enforce business rules</li>
 *   <li>No state transitions or domain events</li>
 *   <li>Direct mapping from repository to DTOs is sufficient</li>
 *   <li>Simpler architecture improves maintainability</li>
 * </ul>
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class QueryQuestionsService implements IQueryQuestionsService {

    private final IQuestionQueryRepository questionQueryRepository;

    @Override
    public Result<QueryQuestionsResponse> queryQuestions(QueryQuestionsRequest request) {
        try {
            // Validate request
            if (request == null) {
                log.warn("Query request is null");
                return Result.failure("Request cannot be null");
            }

            log.debug("Querying questions for user: {}, questionBank: {}, page: {}, size: {}",
                    request.getUserId(), request.getQuestionBankId(),
                    request.getPage(), request.getSize());

            // Query questions from repository
            List<QuestionDTO> questions = questionQueryRepository.queryQuestions(request);

            // Count total matching questions
            long totalItems = questionQueryRepository.countQuestions(
                    request.getUserId(),
                    request.getQuestionBankId(),
                    request
            );

            // Calculate pagination metadata
            PaginationMetadata pagination = PaginationMetadata.of(
                    request.getPage(),
                    request.getSize(),
                    totalItems
            );

            // Create response
            QueryQuestionsResponse response = new QueryQuestionsResponse(questions, pagination);

            log.debug("Query completed successfully. Found {} questions out of {} total",
                    questions.size(), totalItems);

            return Result.success(response);

        } catch (Exception e) {
            log.error("Error querying questions: {}", e.getMessage(), e);
            return Result.failure("Failed to query questions: " + e.getMessage());
        }
    }
}
```

#### Task 2.2: Run Tests (Should PASS)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=*QueryQuestionsService*
```

**Expected Result**: All service tests should PASS (8 unit tests + 3 integration tests).

---

## Phase 3: REFACTOR (Improve Code Quality)

### Objective
Add request validation and improve error handling.

### Tasks

#### Task 3.1: Create Request Validator

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/validation/QueryRequestValidator.java`

```java
package com.quizfun.questionbankquery.application.validation;

import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;

/**
 * Validator for query requests.
 *
 * <p>Performs business validation beyond JSR-303 annotations.
 */
@Slf4j
public class QueryRequestValidator {

    /**
     * Validates query request.
     *
     * @param request Request to validate
     * @return List of validation errors (empty if valid)
     */
    public static List<String> validate(QueryQuestionsRequest request) {
        List<String> errors = new ArrayList<>();

        if (request == null) {
            errors.add("Request cannot be null");
            return errors;
        }

        if (request.getUserId() == null) {
            errors.add("User ID cannot be null");
        }

        if (request.getQuestionBankId() == null) {
            errors.add("Question Bank ID cannot be null");
        }

        if (request.getPage() < 0) {
            errors.add("Page number cannot be negative");
        }

        if (request.getSize() < 1 || request.getSize() > 100) {
            errors.add("Page size must be between 1 and 100");
        }

        return errors;
    }
}
```

#### Task 3.2: Update Service to Use Validator

Update `QueryQuestionsService.java`:

```java
@Override
public Result<QueryQuestionsResponse> queryQuestions(QueryQuestionsRequest request) {
    try {
        // Validate request
        List<String> validationErrors = QueryRequestValidator.validate(request);
        if (!validationErrors.isEmpty()) {
            String errorMessage = String.join(", ", validationErrors);
            log.warn("Query request validation failed: {}", errorMessage);
            return Result.failure(errorMessage);
        }

        log.debug("Querying questions for user: {}, questionBank: {}, page: {}, size: {}",
                request.getUserId(), request.getQuestionBankId(),
                request.getPage(), request.getSize());

        // Query questions from repository
        List<QuestionDTO> questions = questionQueryRepository.queryQuestions(request);

        // Count total matching questions
        long totalItems = questionQueryRepository.countQuestions(
                request.getUserId(),
                request.getQuestionBankId(),
                request
        );

        // Calculate pagination metadata
        PaginationMetadata pagination = PaginationMetadata.of(
                request.getPage(),
                request.getSize(),
                totalItems
        );

        // Create response
        QueryQuestionsResponse response = new QueryQuestionsResponse(questions, pagination);

        log.debug("Query completed successfully. Found {} questions out of {} total",
                questions.size(), totalItems);

        return Result.success(response);

    } catch (Exception e) {
        log.error("Error querying questions: {}", e.getMessage(), e);
        return Result.failure("Failed to query questions: " + e.getMessage());
    }
}
```

#### Task 3.3: Add Tests for Validator

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/validation/QueryRequestValidatorTest.java`

```java
package com.quizfun.questionbankquery.application.validation;

import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1015.query-application-service")
@DisplayName("Query Request Validator Tests")
class QueryRequestValidatorTest {

    @Test
    @DisplayName("Should pass validation for valid request")
    void shouldPassValidationForValidRequest() {
        // GIVEN: Valid request
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(0)
                .size(20)
                .build();

        // WHEN: Validating
        List<String> errors = QueryRequestValidator.validate(request);

        // THEN: Should have no errors
        assertThat(errors).isEmpty();
    }

    @Test
    @DisplayName("Should fail validation when request is null")
    void shouldFailValidationWhenRequestIsNull() {
        // WHEN: Validating null request
        List<String> errors = QueryRequestValidator.validate(null);

        // THEN: Should have error
        assertThat(errors).hasSize(1);
        assertThat(errors.getFirst()).contains("cannot be null");
    }

    @Test
    @DisplayName("Should fail validation when userId is null")
    void shouldFailValidationWhenUserIdIsNull() {
        // GIVEN: Request with null userId
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(null)
                .questionBankId(67890L)
                .build();

        // WHEN: Validating
        List<String> errors = QueryRequestValidator.validate(request);

        // THEN: Should have error
        assertThat(errors).isNotEmpty();
        assertThat(errors).anyMatch(e -> e.contains("User ID"));
    }

    @Test
    @DisplayName("Should fail validation when questionBankId is null")
    void shouldFailValidationWhenQuestionBankIdIsNull() {
        // GIVEN: Request with null questionBankId
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(null)
                .build();

        // WHEN: Validating
        List<String> errors = QueryRequestValidator.validate(request);

        // THEN: Should have error
        assertThat(errors).isNotEmpty();
        assertThat(errors).anyMatch(e -> e.contains("Question Bank ID"));
    }

    @Test
    @DisplayName("Should fail validation when page is negative")
    void shouldFailValidationWhenPageIsNegative() {
        // GIVEN: Request with negative page
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(-1)
                .size(20)
                .build();

        // WHEN: Validating
        List<String> errors = QueryRequestValidator.validate(request);

        // THEN: Should have error
        assertThat(errors).isNotEmpty();
        assertThat(errors).anyMatch(e -> e.contains("Page number"));
    }

    @Test
    @DisplayName("Should fail validation when size is out of range")
    void shouldFailValidationWhenSizeIsOutOfRange() {
        // GIVEN: Request with invalid size
        QueryQuestionsRequest request1 = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(0)
                .size(0)
                .build();

        QueryQuestionsRequest request2 = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(0)
                .size(150)
                .build();

        // WHEN: Validating
        List<String> errors1 = QueryRequestValidator.validate(request1);
        List<String> errors2 = QueryRequestValidator.validate(request2);

        // THEN: Should have errors
        assertThat(errors1).isNotEmpty();
        assertThat(errors2).isNotEmpty();
    }
}
```

#### Task 3.4: Run All Tests with Coverage

```bash
mvn clean verify -pl internal-layer/question-bank-query
```

Verify:
- ✅ All tests pass (60+ tests)
- ✅ JaCoCo coverage > 70%

#### Task 3.5: Generate Allure Report

```bash
mvn allure:report -pl internal-layer/question-bank-query
```

---

## Definition of Done

- [ ] Application service interface created (input port)
- [ ] Application service implementation created
- [ ] Request validator created
- [ ] Service calculates pagination metadata correctly
- [ ] Service delegates to repository
- [ ] Service returns complete response
- [ ] All unit tests pass (8 tests)
- [ ] All integration tests pass (3 tests)
- [ ] All validator tests pass (6 tests)
- [ ] JaCoCo coverage >= 70%
- [ ] Allure annotations correctly applied
- [ ] Code properly documented
- [ ] No Checkstyle violations
- [ ] No SonarLint warnings
- [ ] Code reviewed and approved

---

## Testing Checklist

### Unit Tests
- [ ] ✅ Return questions with pagination metadata
- [ ] ✅ Return empty list when no matches
- [ ] ✅ Calculate total pages correctly
- [ ] ✅ Handle filters in count query
- [ ] ✅ Return failure on repository exception
- [ ] ✅ Validate request is not null
- [ ] ✅ Call repository methods exactly once
- [ ] ✅ Handle last page with partial results

### Integration Tests
- [ ] ✅ Return questions with correct pagination
- [ ] ✅ Handle last page with partial results
- [ ] ✅ Return empty when no matches

### Validator Tests
- [ ] ✅ Pass validation for valid request
- [ ] ✅ Fail when request is null
- [ ] ✅ Fail when userId is null
- [ ] ✅ Fail when questionBankId is null
- [ ] ✅ Fail when page is negative
- [ ] ✅ Fail when size is out of range

---

## Estimated Effort

- **RED Phase**: 2.5 hours
- **GREEN Phase**: 1.5 hours
- **REFACTOR Phase**: 1.5 hours
- **Total**: 5.5 hours

---

## Dependencies

- **1010.testcontainer-mongodb-setup-and-configuration**: Test infrastructure
- **1011.query-dtos-and-pagination-logic**: DTOs
- **1012.simple-mongodb-query-repository**: Repository interface and implementation
- **1013.complex-taxonomy-filter-aggregation**: Taxonomy filters
- **1014.full-text-search-implementation**: Text search

---

## Notes

### Why No Domain Layer?

The query side intentionally omits the domain layer because:

1. **No Business Rules**: Read operations don't enforce invariants
2. **No State Transitions**: Queries don't change state
3. **No Domain Events**: No events to publish
4. **Performance**: Direct repository-to-DTO mapping is faster
5. **Simplicity**: Easier to understand and maintain

### Service Responsibilities

The application service:
- ✅ Validates requests
- ✅ Orchestrates repository calls
- ✅ Calculates pagination metadata
- ✅ Maps to response DTOs
- ✅ Handles errors gracefully

It does NOT:
- ❌ Implement business rules (none needed for queries)
- ❌ Manage transactions (read-only operations)
- ❌ Publish domain events (query side doesn't emit events)

### Hexagonal Architecture Ports

- **Input Port**: `IQueryQuestionsService` (called by query handler)
- **Output Port**: `IQuestionQueryRepository` (implemented by MongoDB adapter)

This maintains clean separation between layers while keeping the architecture simple.
