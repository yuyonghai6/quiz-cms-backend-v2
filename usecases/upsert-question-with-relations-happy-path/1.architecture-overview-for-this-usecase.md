# Architecture Overview - Upsert Question with Taxonomies Use Case

## System Context

### Multi-Module Maven Architecture
```
quiz-cms (Parent)
├── orchestration-layer (Spring Boot App - Port 8765)
│   ├── Controllers (HTTP Layer)
│   ├── Command Handlers (CQRS)
│   └── Application Services (Orchestration)
├── internal-layer (Business Logic)
│   ├── question-bank (Bounded Context)
│   │   ├── Domain (Aggregates, Entities)
│   │   ├── Application (Ports/Services)
│   │   └── Infrastructure (Repositories)
│   └── shared (Cross-Module)
│       ├── AggregateRoot.java
│       └── TestDataLoader
├── global-shared-library (Infrastructure)
│   ├── Mediator Pattern (CQRS)
│   ├── Result<T> (Response Wrapper)
│   └── Common Utilities
└── external-service-proxy (External Integration)
    └── [Not used in this use case]
```

## Architectural Patterns Applied

### 1. Domain-Driven Design (DDD)
- **Bounded Context**: question-bank module encapsulates question management domain
- **Aggregates**: QuestionAggregate, TaxonomySetAggregate, QuestionTaxonomyRelationshipAggregate, QuestionBanksPerUserAggregate
- **Domain Events**: Stored in AggregateRoot for eventual consistency
- **Repositories**: Abstract data access with domain-focused interfaces

### 2. CQRS (Command Query Responsibility Segregation)
- **Commands**: UpsertQuestionCommand for write operations
- **Queries**: [Future queries for read operations]
- **Mediator**: Routes commands to appropriate handlers
- **Handlers**: Single responsibility for each use case

### 3. Hexagonal Architecture (Ports & Adapters)
```
┌─────────────────────────────────────────────────────────────┐
│                    orchestration-layer                      │
│  ┌─────────────────┐    ┌──────────────────────────────────┐ │
│  │   Controller    │───▶│     Command Handler              │ │
│  │  (HTTP Adapter) │    │   (Application Service)         │ │
│  └─────────────────┘    └──────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                  │
                                  ▼ (via Mediator)
┌─────────────────────────────────────────────────────────────┐
│                    internal-layer/question-bank             │
│  ┌─────────────────┐    ┌──────────────────────────────────┐ │
│  │  Application    │───▶│           Domain                 │ │
│  │   Service       │    │      (Aggregates)               │ │
│  │   (Port IN)     │    │                                  │ │
│  └─────────────────┘    └──────────────────────────────────┘ │
│           │                              │                   │
│           ▼                              ▼                   │
│  ┌─────────────────┐    ┌──────────────────────────────────┐ │
│  │  Infrastructure │    │        Repositories              │ │
│  │    (Adapters)   │    │       (Port OUT)                │ │
│  └─────────────────┘    └──────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────┐
│                     MongoDB (TestContainers)                │
│  ┌─────────────────┬──────────────────┬─────────────────────┐ │
│  │    questions    │ taxonomy_sets    │ question_taxonomy_  │ │
│  │   collection    │   collection     │ relationships       │ │
│  └─────────────────┴──────────────────┴─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 4. Design Patterns Implementation

#### Chain of Responsibility (Validation)
```java
public abstract class ValidationHandler {
    protected ValidationHandler next;

    public ValidationHandler setNext(ValidationHandler handler) {
        this.next = handler;
        return handler;
    }

    public abstract Result<Void> validate(UpsertQuestionCommand command);
}

// Concrete Validators
- QuestionBankOwnershipValidator
- TaxonomyReferenceValidator
- QuestionDataIntegrityValidator
- DuplicateSourceIdValidator
```

#### Strategy Pattern (Question Types)
```java
public interface QuestionTypeStrategy {
    Result<QuestionAggregate> processQuestionData(UpsertQuestionCommand command);
}

// Concrete Strategies
- McqQuestionStrategy
- TrueFalseQuestionStrategy
- EssayQuestionStrategy
```

#### Repository Pattern (Data Access)
```java
// Port OUT interfaces
public interface QuestionRepository {
    Result<QuestionAggregate> upsertBySourceQuestionId(QuestionAggregate aggregate);
}

// Infrastructure implementations
public class MongoQuestionRepository implements QuestionRepository {
    // MongoDB-specific implementation
}
```

## Data Flow Architecture

### Request Processing Flow
```
HTTP Request
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│  orchestration-layer                                        │
│  ┌─────────────────┐                                        │
│  │   Controller    │ 1. Extract userId, questionBankId     │
│  │                 │    from path parameters               │
│  │                 │ 2. Create UpsertQuestionCommand       │
│  └─────────────────┘                                        │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                        │
│  │    Mediator     │ 3. Route to UpsertQuestionHandler     │
│  └─────────────────┘                                        │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                        │
│  │  Command        │ 4. Orchestrate validation and         │
│  │  Handler        │    business logic execution           │
│  └─────────────────┘                                        │
└─────────────────────────────────────────────────────────────┘
           │
           ▼ (Inject Application Service)
┌─────────────────────────────────────────────────────────────┐
│  internal-layer/question-bank                               │
│  ┌─────────────────┐                                        │
│  │  Application    │ 5. Execute validation chain           │
│  │  Service        │ 6. Instantiate domain aggregates      │
│  │  (Port IN)      │ 7. Coordinate repository operations   │
│  └─────────────────┘                                        │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                        │
│  │   Validation    │ 8. Chain of Responsibility:           │
│  │     Chain       │    - Ownership validation             │
│  │                 │    - Taxonomy validation              │
│  │                 │    - Data integrity validation        │
│  └─────────────────┘                                        │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                        │
│  │    Domain       │ 9. Instantiate QuestionAggregate      │
│  │  Aggregates     │ 10. Apply business rules              │
│  │                 │ 11. Generate domain events            │
│  └─────────────────┘                                        │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                        │
│  │  Repositories   │ 12. Transactional operations:         │
│  │   (Port OUT)    │     - Upsert question                 │
│  │                 │     - Update taxonomy relationships   │
│  └─────────────────┘                                        │
└─────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────┐
│  MongoDB Collections                                        │
│  ┌─────────────────┬──────────────────┬─────────────────────┐ │
│  │    questions    │ question_taxonomy │ taxonomy_sets      │ │
│  │   (upsert)      │ _relationships   │   (read-only)      │ │
│  │                 │   (replace)      │                    │ │
│  └─────────────────┴──────────────────┴─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## Component Interaction Details

### 1. Controller Layer (orchestration-layer)
```java
@RestController
@RequestMapping("/api/users/{userId}/questionbanks/{questionbankId}")
public class QuestionController {

    private final IMediator mediator;

    @PostMapping("/questions")
    public ResponseEntity<Result<QuestionResponseDto>> upsertQuestion(
        @PathVariable Long userId,
        @PathVariable Long questionbankId,
        @RequestBody UpsertQuestionRequestDto request) {

        var command = new UpsertQuestionCommand(userId, questionbankId, request);
        var result = mediator.send(command);
        return ResponseEntity.ok(result);
    }
}
```

### 2. Command Handler (orchestration-layer)
```java
@Service
public class UpsertQuestionCommandHandler implements ICommandHandler<UpsertQuestionCommand, QuestionResponseDto> {

    private final QuestionApplicationService questionApplicationService;

    @Override
    public Result<QuestionResponseDto> handle(UpsertQuestionCommand command) {
        return questionApplicationService.upsertQuestion(command);
    }
}
```

### 3. Application Service (internal-layer/question-bank)
```java
@Service
public class QuestionApplicationService {

    private final ValidationHandler validationChain;
    private final QuestionTypeStrategyFactory strategyFactory;
    private final QuestionRepository questionRepository;
    private final QuestionTaxonomyRelationshipRepository relationshipRepository;

    @Transactional
    public Result<QuestionResponseDto> upsertQuestion(UpsertQuestionCommand command) {
        // 1. Validate using Chain of Responsibility
        var validationResult = validationChain.validate(command);
        if (validationResult.isFailure()) {
            return Result.failure(validationResult.getError());
        }

        // 2. Process question using Strategy Pattern
        var strategy = strategyFactory.getStrategy(command.getQuestionType());
        var questionAggregate = strategy.processQuestionData(command);

        // 3. Upsert question (transactional)
        var questionResult = questionRepository.upsertBySourceQuestionId(questionAggregate);

        // 4. Update taxonomy relationships (transactional)
        var relationships = createTaxonomyRelationships(questionResult.getId(), command);
        relationshipRepository.replaceRelationshipsForQuestion(questionResult.getId(), relationships);

        return Result.success(mapToDto(questionResult));
    }
}
```

## Transaction and Consistency Management

### ACID Compliance
```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public Result<QuestionResponseDto> upsertQuestion(UpsertQuestionCommand command) {
    try {
        // All operations within single transaction
        var questionResult = questionRepository.upsertBySourceQuestionId(...);
        relationshipRepository.replaceRelationshipsForQuestion(...);
        return Result.success(questionResult);
    } catch (Exception ex) {
        // Transaction rollback automatic
        return Result.failure("Database operation failed");
    }
}
```

### Event Sourcing (Future Enhancement)
```java
public abstract class AggregateRoot {
    private final List<DomainEvent> domainEvents = new ArrayList<>();
    private Long version;

    protected void addDomainEvent(DomainEvent event) {
        domainEvents.add(event);
    }

    public List<DomainEvent> getUncommittedEvents() {
        return new ArrayList<>(domainEvents);
    }

    public void markEventsAsCommitted() {
        domainEvents.clear();
    }
}
```

## Cross-Cutting Concerns

### 1. Error Handling Strategy
- **Fast Fail**: Stop on first validation error
- **Detailed Messages**: Include field-level error information
- **Error Codes**: Enumerated error types for client handling
- **Logging**: Structured logging for debugging and monitoring

### 2. Security (Currently Disabled)
- **Authentication**: Spring Security (can be bypassed)
- **Authorization**: User can only access their own question banks
- **Data Isolation**: Multi-tenant data separation by user_id

### 3. Testing Strategy
- **Unit Tests**: Domain logic and business rules
- **Integration Tests**: Repository and database operations
- **End-to-End Tests**: Complete request-response flow
- **TestContainers**: MongoDB integration testing

### 4. Performance Considerations
- **MongoDB Indexing**: Optimized for query patterns
- **Connection Pooling**: Efficient database connections
- **Caching**: Future enhancement for taxonomy sets
- **Bulk Operations**: Efficient relationship updates

## Technology Stack Integration

### Core Technologies
- **Java 21**: Latest LTS with performance improvements
- **Spring Boot 3.5.6**: Modern Spring stack
- **MongoDB 8.0**: Document database for flexible schemas
- **Maven**: Multi-module project management

### Testing Technologies
- **JUnit 5**: Modern testing framework
- **TestContainers**: Integration testing with real MongoDB
- **JaCoCo**: Code coverage analysis (70% minimum)
- **Allure**: Rich test reporting

### Development Tools
- **Lombok**: Reduced boilerplate code
- **Spring IoC**: Dependency injection
- **Reflection**: Dynamic handler registration in mediator

This architecture provides a scalable, maintainable foundation for the question management system while adhering to modern software engineering principles and patterns.