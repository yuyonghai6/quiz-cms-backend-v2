# User Story 1016: Query Handler and Mediator Integration

## User Story

**As a** backend developer
**I want** to create a CQRS query handler that integrates with the mediator pattern
**So that** query requests can be routed through the mediator to the appropriate handler

## Acceptance Criteria

- [ ] Query class created implementing `IQuery<QueryQuestionsResponse>`
- [ ] Query handler created implementing `IQueryHandler<QueryQuestions, QueryQuestionsResponse>`
- [ ] Handler is registered as Spring `@Service` for auto-discovery by mediator
- [ ] Handler delegates to application service
- [ ] Handler returns `Result<QueryQuestionsResponse>`
- [ ] Unit tests verify handler logic with mocked service
- [ ] Integration tests verify mediator routing to handler
- [ ] All tests pass with JaCoCo coverage > 70%
- [ ] Allure annotations correctly applied

---

## TDD Cycle

### Allure Annotations Format

```java
@Epic("Use Case Query List of Questions of Question Bank")
@Story("1016.query-handler-mediator-integration")
```

---

## Phase 1: RED (Write Failing Tests)

### Objective
Write failing tests for query and query handler.

### Tasks

#### Task 1.1: Create Query Class

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/queries/QueryQuestions.java`

```java
package com.quizfun.questionbankquery.application.queries;

import com.quizfun.globalshared.mediator.IQuery;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsResponse;
import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * Query for retrieving questions with filters and pagination.
 *
 * <p>This implements the CQRS query pattern using the mediator.
 * Queries are routed to the appropriate handler via the mediator.
 */
@Getter
@AllArgsConstructor
public class QueryQuestions implements IQuery<QueryQuestionsResponse> {

    private final QueryQuestionsRequest request;
}
```

#### Task 1.2: Create Unit Tests for Query Handler

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/queries/QueryQuestionsHandlerTest.java`

```java
package com.quizfun.questionbankquery.application.queries;

import com.quizfun.globalshared.mediator.Result;
import com.quizfun.questionbankquery.application.dto.PaginationMetadata;
import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsResponse;
import com.quizfun.questionbankquery.application.ports.in.IQueryQuestionsService;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.Instant;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1016.query-handler-mediator-integration")
@ExtendWith(MockitoExtension.class)
@DisplayName("Query Questions Handler Unit Tests")
class QueryQuestionsHandlerTest {

    @Mock
    private IQueryQuestionsService queryQuestionsService;

    private QueryQuestionsHandler queryQuestionsHandler;

    @BeforeEach
    void setUp() {
        queryQuestionsHandler = new QueryQuestionsHandler(queryQuestionsService);
    }

    @Test
    @DisplayName("Should handle query and return success result")
    void shouldHandleQueryAndReturnSuccessResult() {
        // GIVEN: Service returns success
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .page(0)
                .size(20)
                .build();

        List<QuestionDTO> mockQuestions = List.of(
                new QuestionDTO(1L, "Q1", "MCQ", "EASY", null, null, Instant.now(), Instant.now())
        );

        PaginationMetadata pagination = new PaginationMetadata(0, 20, 1, 1);
        QueryQuestionsResponse mockResponse = new QueryQuestionsResponse(mockQuestions, pagination);

        when(queryQuestionsService.queryQuestions(request)).thenReturn(Result.success(mockResponse));

        // WHEN: Handling query
        QueryQuestions query = new QueryQuestions(request);
        Result<QueryQuestionsResponse> result = queryQuestionsHandler.handle(query);

        // THEN: Should return success
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue()).isEqualTo(mockResponse);
        verify(queryQuestionsService, times(1)).queryQuestions(request);
    }

    @Test
    @DisplayName("Should handle query and return failure result")
    void shouldHandleQueryAndReturnFailureResult() {
        // GIVEN: Service returns failure
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .build();

        when(queryQuestionsService.queryQuestions(request))
                .thenReturn(Result.failure("Database error"));

        // WHEN: Handling query
        QueryQuestions query = new QueryQuestions(request);
        Result<QueryQuestionsResponse> result = queryQuestionsHandler.handle(query);

        // THEN: Should return failure
        assertThat(result.isSuccess()).isFalse();
        assertThat(result.getError()).contains("Database error");
    }

    @Test
    @DisplayName("Should handle query with null request gracefully")
    void shouldHandleQueryWithNullRequestGracefully() {
        // GIVEN: Query with null request
        QueryQuestions query = new QueryQuestions(null);

        when(queryQuestionsService.queryQuestions(null))
                .thenReturn(Result.failure("Request cannot be null"));

        // WHEN: Handling query
        Result<QueryQuestionsResponse> result = queryQuestionsHandler.handle(query);

        // THEN: Should return failure
        assertThat(result.isSuccess()).isFalse();
        assertThat(result.getError()).contains("cannot be null");
    }

    @Test
    @DisplayName("Should delegate to service without modification")
    void shouldDelegateToServiceWithoutModification() {
        // GIVEN: Valid query
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(12345L)
                .questionBankId(67890L)
                .categories(List.of("Math"))
                .tags(List.of("algebra"))
                .page(1)
                .size(10)
                .build();

        QueryQuestionsResponse mockResponse = new QueryQuestionsResponse(
                List.of(),
                new PaginationMetadata(1, 10, 0, 0)
        );

        when(queryQuestionsService.queryQuestions(request)).thenReturn(Result.success(mockResponse));

        // WHEN: Handling query
        QueryQuestions query = new QueryQuestions(request);
        queryQuestionsHandler.handle(query);

        // THEN: Should pass exact same request to service
        verify(queryQuestionsService, times(1)).queryQuestions(request);
        verifyNoMoreInteractions(queryQuestionsService);
    }
}
```

#### Task 1.3: Create Integration Tests for Mediator Routing

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/queries/QueryQuestionsMediatorIntegrationTest.java`

```java
package com.quizfun.questionbankquery.application.queries;

import com.quizfun.globalshared.mediator.IMediator;
import com.quizfun.globalshared.mediator.Result;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsResponse;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MongoDBContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.Instant;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1016.query-handler-mediator-integration")
@Testcontainers
@SpringBootTest
@DisplayName("Query Questions Mediator Integration Tests")
class QueryQuestionsMediatorIntegrationTest {

    @Container
    static MongoDBContainer mongoContainer = new MongoDBContainer("mongo:8.0")
            .withExposedPorts(27017)
            .withReuse(false);

    @DynamicPropertySource
    static void mongoProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoContainer::getReplicaSetUrl);
        registry.add("spring.data.mongodb.read-preference", () -> "primary");
    }

    @Autowired
    private MongoTemplate mongoTemplate;

    @Autowired
    private IMediator mediator;

    private static final Long TEST_USER_ID = 12345L;
    private static final Long TEST_QUESTION_BANK_ID = 67890L;
    private static final String COLLECTION_NAME = "questions";

    @BeforeEach
    void setUp() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
        mongoTemplate.createCollection(COLLECTION_NAME);
        insertTestQuestions(10);
    }

    @AfterEach
    void tearDown() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
    }

    @Test
    @DisplayName("Should route query through mediator to handler")
    void shouldRouteQueryThroughMediatorToHandler() {
        // GIVEN: Query request
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .build();

        QueryQuestions query = new QueryQuestions(request);

        // WHEN: Sending query through mediator
        Result<QueryQuestionsResponse> result = mediator.send(query);

        // THEN: Should return success
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue()).isNotNull();
        assertThat(result.getValue().questions()).hasSize(10);
    }

    @Test
    @DisplayName("Should handle query with filters through mediator")
    void shouldHandleQueryWithFiltersThroughMediator() {
        // GIVEN: Query with filters
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Math"))
                .page(0)
                .size(10)
                .build();

        QueryQuestions query = new QueryQuestions(request);

        // WHEN: Sending query through mediator
        Result<QueryQuestionsResponse> result = mediator.send(query);

        // THEN: Should return filtered results
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().questions()).isNotEmpty();
    }

    @Test
    @DisplayName("Should handle empty results through mediator")
    void shouldHandleEmptyResultsThroughMediator() {
        // GIVEN: Query for non-existent user
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(99999L)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .build();

        QueryQuestions query = new QueryQuestions(request);

        // WHEN: Sending query through mediator
        Result<QueryQuestionsResponse> result = mediator.send(query);

        // THEN: Should return empty list (not error)
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().questions()).isEmpty();
        assertThat(result.getValue().pagination().totalItems()).isZero();
    }

    @Test
    @DisplayName("Should return correct pagination metadata through mediator")
    void shouldReturnCorrectPaginationMetadataThroughMediator() {
        // GIVEN: Query with pagination
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(5)
                .build();

        QueryQuestions query = new QueryQuestions(request);

        // WHEN: Sending query through mediator
        Result<QueryQuestionsResponse> result = mediator.send(query);

        // THEN: Pagination should be correct
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getValue().pagination().currentPage()).isZero();
        assertThat(result.getValue().pagination().pageSize()).isEqualTo(5);
        assertThat(result.getValue().pagination().totalItems()).isEqualTo(10);
        assertThat(result.getValue().pagination().totalPages()).isEqualTo(2);
    }

    // Helper method

    private void insertTestQuestions(int count) {
        Instant now = Instant.now();
        for (int i = 0; i < count; i++) {
            QuestionDocument doc = QuestionDocument.builder()
                    .questionId(4000000000000L + i)
                    .userId(TEST_USER_ID)
                    .questionBankId(TEST_QUESTION_BANK_ID)
                    .questionText("Test Question " + i)
                    .questionType("MCQ")
                    .taxonomy(com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument.builder()
                            .categories(List.of("Math"))
                            .tags(List.of("test"))
                            .quizzes(List.of("test-quiz"))
                            .build())
                    .createdAt(now.minusSeconds(count - i))
                    .updatedAt(now.minusSeconds(count - i))
                    .build();
            mongoTemplate.insert(doc, COLLECTION_NAME);
        }
    }
}
```

#### Task 1.4: Run Tests (Should FAIL)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=*QueryQuestions*Handler*,*QueryQuestions*Mediator*
```

**Expected Result**: Tests should FAIL because handler doesn't exist yet.

---

## Phase 2: GREEN (Make Tests Pass)

### Objective
Implement query handler to make tests pass.

### Tasks

#### Task 2.1: Implement Query Handler

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/queries/QueryQuestionsHandler.java`

```java
package com.quizfun.questionbankquery.application.queries;

import com.quizfun.globalshared.mediator.IQueryHandler;
import com.quizfun.globalshared.mediator.Result;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsResponse;
import com.quizfun.questionbankquery.application.ports.in.IQueryQuestionsService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Query handler for querying questions.
 *
 * <p>This handler is part of the CQRS pattern implementation.
 * It is automatically registered with the mediator via Spring's component scanning.
 *
 * <p><strong>Handler Registration:</strong></p>
 * <ul>
 *   <li>The handler is marked with @Service for Spring auto-discovery</li>
 *   <li>The mediator uses reflection to extract generic type parameters</li>
 *   <li>At runtime, the mediator routes QueryQuestions queries to this handler</li>
 * </ul>
 *
 * <p><strong>Responsibilities:</strong></p>
 * <ul>
 *   <li>Receives QueryQuestions query from mediator</li>
 *   <li>Delegates to application service</li>
 *   <li>Returns Result<QueryQuestionsResponse> back through mediator</li>
 * </ul>
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class QueryQuestionsHandler implements IQueryHandler<QueryQuestions, QueryQuestionsResponse> {

    private final IQueryQuestionsService queryQuestionsService;

    @Override
    public Result<QueryQuestionsResponse> handle(QueryQuestions query) {
        log.debug("Handling QueryQuestions query");

        // Delegate to application service
        return queryQuestionsService.queryQuestions(query.getRequest());
    }
}
```

#### Task 2.2: Run Tests (Should PASS)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=*QueryQuestions*Handler*,*QueryQuestions*Mediator*
```

**Expected Result**: All handler and mediator tests should PASS (4 unit + 4 integration tests).

---

## Phase 3: REFACTOR (Improve Code Quality)

### Objective
Add comprehensive documentation and verify mediator registration.

### Tasks

#### Task 3.1: Add Test to Verify Handler Registration

**File**: Update `QueryQuestionsMediatorIntegrationTest.java`

```java
@Test
@DisplayName("Should have QueryQuestionsHandler registered in mediator")
void shouldHaveQueryQuestionsHandlerRegisteredInMediator() {
    // GIVEN: Spring context is loaded

    // WHEN: Checking if handler is available as Spring bean
    QueryQuestionsHandler handler = applicationContext.getBean(QueryQuestionsHandler.class);

    // THEN: Handler should be registered
    assertThat(handler).isNotNull();
}

// Add field to inject ApplicationContext
@Autowired
private org.springframework.context.ApplicationContext applicationContext;
```

#### Task 3.2: Add Integration Test for Invalid Query

**File**: Update `QueryQuestionsMediatorIntegrationTest.java`

```java
@Test
@DisplayName("Should handle invalid query gracefully through mediator")
void shouldHandleInvalidQueryGracefullyThroughMediator() {
    // GIVEN: Query with null request
    QueryQuestions query = new QueryQuestions(null);

    // WHEN: Sending invalid query through mediator
    Result<QueryQuestionsResponse> result = mediator.send(query);

    // THEN: Should return failure (not throw exception)
    assertThat(result.isSuccess()).isFalse();
    assertThat(result.getError()).isNotNull();
}
```

#### Task 3.3: Document CQRS Pattern in Package Info

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/queries/package-info.java`

```java
/**
 * CQRS Query layer for question-bank-query module.
 *
 * <p>This package contains queries and query handlers that implement the CQRS pattern
 * using the mediator pattern from global-shared-library.
 *
 * <h2>Pattern Overview</h2>
 * <pre>
 * Controller → Mediator.send(Query) → QueryHandler → Application Service → Repository
 * </pre>
 *
 * <h2>Key Components</h2>
 * <ul>
 *   <li><strong>Query:</strong> Immutable request object implementing IQuery&lt;T&gt;</li>
 *   <li><strong>QueryHandler:</strong> Handler implementing IQueryHandler&lt;Q, T&gt;</li>
 *   <li><strong>Mediator:</strong> Routes queries to appropriate handlers</li>
 *   <li><strong>Result:</strong> Wrapper for success/failure responses</li>
 * </ul>
 *
 * <h2>Handler Registration</h2>
 * <p>Query handlers are automatically registered with the mediator:
 * <ol>
 *   <li>Handler is marked with @Service annotation</li>
 *   <li>Spring's component scanning discovers the handler</li>
 *   <li>Mediator uses reflection to extract generic type parameters</li>
 *   <li>At runtime, queries are routed to the matching handler</li>
 * </ol>
 *
 * <h2>Example Usage</h2>
 * <pre>
 * // In Controller
 * QueryQuestionsRequest request = QueryQuestionsRequest.builder()
 *     .userId(userId)
 *     .questionBankId(questionBankId)
 *     .page(0)
 *     .size(20)
 *     .build();
 *
 * QueryQuestions query = new QueryQuestions(request);
 * Result&lt;QueryQuestionsResponse&gt; result = mediator.send(query);
 *
 * if (result.isSuccess()) {
 *     return ResponseEntity.ok(result.getValue());
 * } else {
 *     return ResponseEntity.badRequest().body(result.getError());
 * }
 * </pre>
 *
 * @see com.quizfun.globalshared.mediator.IMediator
 * @see com.quizfun.globalshared.mediator.IQuery
 * @see com.quizfun.globalshared.mediator.IQueryHandler
 */
package com.quizfun.questionbankquery.application.queries;
```

#### Task 3.4: Run All Tests with Coverage

```bash
mvn clean verify -pl internal-layer/question-bank-query
```

Verify:
- ✅ All tests pass (70+ tests including all user stories)
- ✅ JaCoCo coverage > 70%

#### Task 3.5: Generate Allure Report

```bash
mvn allure:report -pl internal-layer/question-bank-query
```

Verify:
- ✅ Story "1016.query-handler-mediator-integration" appears
- ✅ All handler and mediator tests visible
- ✅ All previous user stories tests still passing

---

## Definition of Done

- [ ] Query class created implementing IQuery
- [ ] Query handler created implementing IQueryHandler
- [ ] Handler registered as @Service for mediator auto-discovery
- [ ] Handler delegates to application service
- [ ] All unit tests pass (4 tests)
- [ ] All integration tests pass (5 tests)
- [ ] JaCoCo coverage >= 70%
- [ ] Allure annotations correctly applied
- [ ] Comprehensive CQRS documentation added
- [ ] Package-info.java created
- [ ] No Checkstyle violations
- [ ] No SonarLint warnings
- [ ] Code reviewed and approved

---

## Testing Checklist

### Unit Tests
- [ ] ✅ Handle query and return success
- [ ] ✅ Handle query and return failure
- [ ] ✅ Handle null request gracefully
- [ ] ✅ Delegate to service without modification

### Integration Tests
- [ ] ✅ Route query through mediator to handler
- [ ] ✅ Handle query with filters through mediator
- [ ] ✅ Handle empty results through mediator
- [ ] ✅ Return correct pagination through mediator
- [ ] ✅ Handler registered in mediator
- [ ] ✅ Handle invalid query gracefully

---

## Estimated Effort

- **RED Phase**: 2 hours
- **GREEN Phase**: 1 hour
- **REFACTOR Phase**: 1.5 hours
- **Total**: 4.5 hours

---

## Dependencies

- **1010-1014**: Repository layer (infrastructure)
- **1015**: Application service layer
- **global-shared-library**: Mediator pattern implementation

---

## Notes

### CQRS and Mediator Pattern

**Why Use Mediator?**
1. **Decoupling**: Controllers don't know about specific handlers
2. **Type Safety**: Generic type parameters ensure correct routing
3. **Consistency**: Same pattern for commands and queries
4. **Testability**: Easy to mock mediator in tests

**Handler Registration Flow:**
```
@Service Annotation
    ↓
Spring Component Scanning
    ↓
ApplicationContext
    ↓
MediatorImpl Constructor
    ↓
Reflection on Generic Types
    ↓
Handler Map: QueryQuestions → QueryQuestionsHandler
```

**Runtime Routing:**
```
mediator.send(QueryQuestions)
    ↓
Look up handler in map
    ↓
QueryQuestionsHandler.handle()
    ↓
Return Result<QueryQuestionsResponse>
```

### Query vs Command

- **Query**: Read-only operation, returns data
- **Command**: Write operation, changes state

This user story implements the **Query** side of CQRS.

### Package Structure

```
application/
├── queries/           ← Query and Handler (this user story)
│   ├── QueryQuestions.java
│   ├── QueryQuestionsHandler.java
│   └── package-info.java
├── services/          ← Application Service (user story 1015)
│   └── QueryQuestionsService.java
├── ports/
│   ├── in/           ← Input ports (hexagonal architecture)
│   └── out/          ← Output ports (repository interfaces)
└── dto/              ← Data Transfer Objects
```
