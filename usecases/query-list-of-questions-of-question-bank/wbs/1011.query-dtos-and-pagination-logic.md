# User Story 1011: Query DTOs and Pagination Logic

## User Story

**As a** backend developer
**I want** to create request/response DTOs with filter and pagination logic for querying questions
**So that** the API can accept complex filter criteria and return paginated results with metadata

## Acceptance Criteria

- [ ] `QueryQuestionsRequest` DTO created with all filter parameters (taxonomy, search, pagination)
- [ ] `QueryQuestionsResponse` DTO created with question list and pagination metadata
- [ ] `QuestionDTO` created for individual question data
- [ ] `PaginationMetadata` DTO created for page info (current page, total pages, total items)
- [ ] Taxonomy filter parameters support AND/OR logic (categories AND, tags/quizzes OR)
- [ ] Pagination parameters validated (page >= 0, size <= 100, default size = 20)
- [ ] Sort parameters validated (supported fields: createdAt, updatedAt, questionText)
- [ ] All DTOs have proper validation annotations (@NotNull, @Min, @Max, etc.)
- [ ] Unit tests verify validation logic for all DTOs
- [ ] All tests pass with JaCoCo coverage > 70%
- [ ] Allure annotations correctly applied (@Epic and @Story only)

---

## TDD Cycle

### Allure Annotations Format

```java
@Epic("Use Case Query List of Questions of Question Bank")
@Story("1011.query-dtos-and-pagination-logic")
```

---

## Phase 1: RED (Write Failing Tests)

### Objective
Write failing tests for DTO validation and structure.

### Tasks

#### Task 1.1: Create QuestionDTO Test

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/dto/QuestionDTOTest.java`

```java
package com.quizfun.questionbankquery.application.dto;

import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1011.query-dtos-and-pagination-logic")
@DisplayName("QuestionDTO Tests")
class QuestionDTOTest {

    @Test
    @DisplayName("Should create QuestionDTO with all fields")
    void shouldCreateQuestionDTOWithAllFields() {
        // GIVEN: All required fields
        Long questionId = 1234567890123L;
        String questionText = "What is the capital of France?";
        String questionType = "MCQ";
        String difficultyLevel = "EASY";
        Map<String, Object> typeSpecificData = Map.of(
                "options", List.of("Paris", "London", "Berlin", "Madrid"),
                "correctAnswer", "Paris"
        );
        TaxonomyDTO taxonomy = new TaxonomyDTO(
                List.of("Geography", "Europe", "Capitals"),
                List.of("trivia", "beginner"),
                List.of("quick-quiz", "geography-101")
        );
        Instant createdAt = Instant.now();
        Instant updatedAt = Instant.now();

        // WHEN: Creating QuestionDTO
        QuestionDTO dto = new QuestionDTO(
                questionId,
                questionText,
                questionType,
                difficultyLevel,
                typeSpecificData,
                taxonomy,
                createdAt,
                updatedAt
        );

        // THEN: All fields should be set correctly
        assertThat(dto.questionId()).isEqualTo(questionId);
        assertThat(dto.questionText()).isEqualTo(questionText);
        assertThat(dto.questionType()).isEqualTo(questionType);
        assertThat(dto.difficultyLevel()).isEqualTo(difficultyLevel);
        assertThat(dto.typeSpecificData()).isEqualTo(typeSpecificData);
        assertThat(dto.taxonomy()).isEqualTo(taxonomy);
        assertThat(dto.createdAt()).isEqualTo(createdAt);
        assertThat(dto.updatedAt()).isEqualTo(updatedAt);
    }

    @Test
    @DisplayName("Should create QuestionDTO with null optional fields")
    void shouldCreateQuestionDTOWithNullOptionalFields() {
        // GIVEN: Only required fields (taxonomy can be null)
        Long questionId = 1234567890123L;
        String questionText = "What is 2 + 2?";
        String questionType = "ESSAY";

        // WHEN: Creating QuestionDTO with nulls
        QuestionDTO dto = new QuestionDTO(
                questionId,
                questionText,
                questionType,
                null,  // difficultyLevel optional
                Map.of(),  // empty type-specific data
                null,  // taxonomy optional
                Instant.now(),
                Instant.now()
        );

        // THEN: Should be created successfully
        assertThat(dto.questionId()).isEqualTo(questionId);
        assertThat(dto.difficultyLevel()).isNull();
        assertThat(dto.taxonomy()).isNull();
    }
}
```

#### Task 1.2: Create TaxonomyDTO Test

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/dto/TaxonomyDTOTest.java`

```java
package com.quizfun.questionbankquery.application.dto;

import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1011.query-dtos-and-pagination-logic")
@DisplayName("TaxonomyDTO Tests")
class TaxonomyDTOTest {

    @Test
    @DisplayName("Should create TaxonomyDTO with all fields")
    void shouldCreateTaxonomyDTOWithAllFields() {
        // GIVEN: All taxonomy fields
        List<String> categories = List.of("Math", "Algebra", "Linear Equations");
        List<String> tags = List.of("equations", "solve-for-x");
        List<String> quizzes = List.of("midterm-2024", "practice-set-1");

        // WHEN: Creating TaxonomyDTO
        TaxonomyDTO dto = new TaxonomyDTO(categories, tags, quizzes);

        // THEN: All fields should be set
        assertThat(dto.categories()).isEqualTo(categories);
        assertThat(dto.tags()).isEqualTo(tags);
        assertThat(dto.quizzes()).isEqualTo(quizzes);
    }

    @Test
    @DisplayName("Should create TaxonomyDTO with empty lists")
    void shouldCreateTaxonomyDTOWithEmptyLists() {
        // GIVEN: Empty lists
        List<String> emptyList = List.of();

        // WHEN: Creating TaxonomyDTO with empty lists
        TaxonomyDTO dto = new TaxonomyDTO(emptyList, emptyList, emptyList);

        // THEN: Should be created with empty lists
        assertThat(dto.categories()).isEmpty();
        assertThat(dto.tags()).isEmpty();
        assertThat(dto.quizzes()).isEmpty();
    }
}
```

#### Task 1.3: Create PaginationMetadata Test

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/dto/PaginationMetadataTest.java`

```java
package com.quizfun.questionbankquery.application.dto;

import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1011.query-dtos-and-pagination-logic")
@DisplayName("PaginationMetadata Tests")
class PaginationMetadataTest {

    @Test
    @DisplayName("Should create PaginationMetadata with valid data")
    void shouldCreatePaginationMetadataWithValidData() {
        // GIVEN: Pagination data
        int currentPage = 2;
        int pageSize = 20;
        long totalItems = 150;
        int totalPages = 8;

        // WHEN: Creating PaginationMetadata
        PaginationMetadata metadata = new PaginationMetadata(
                currentPage,
                pageSize,
                totalItems,
                totalPages
        );

        // THEN: All fields should be set correctly
        assertThat(metadata.currentPage()).isEqualTo(currentPage);
        assertThat(metadata.pageSize()).isEqualTo(pageSize);
        assertThat(metadata.totalItems()).isEqualTo(totalItems);
        assertThat(metadata.totalPages()).isEqualTo(totalPages);
    }

    @Test
    @DisplayName("Should calculate total pages correctly")
    void shouldCalculateTotalPagesCorrectly() {
        // GIVEN: Total items and page size
        long totalItems = 95;
        int pageSize = 20;
        int expectedTotalPages = (int) Math.ceil((double) totalItems / pageSize); // 5

        // WHEN: Creating metadata
        PaginationMetadata metadata = new PaginationMetadata(
                0,
                pageSize,
                totalItems,
                expectedTotalPages
        );

        // THEN: Total pages should be calculated correctly
        assertThat(metadata.totalPages()).isEqualTo(5);
    }

    @Test
    @DisplayName("Should handle zero total items")
    void shouldHandleZeroTotalItems() {
        // GIVEN: Zero items
        long totalItems = 0;
        int pageSize = 20;

        // WHEN: Creating metadata
        PaginationMetadata metadata = new PaginationMetadata(
                0,
                pageSize,
                totalItems,
                0
        );

        // THEN: Should have zero pages
        assertThat(metadata.totalPages()).isZero();
        assertThat(metadata.totalItems()).isZero();
    }
}
```

#### Task 1.4: Create QueryQuestionsRequest Test

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/dto/QueryQuestionsRequestTest.java`

```java
package com.quizfun.questionbankquery.application.dto;

import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1011.query-dtos-and-pagination-logic")
@DisplayName("QueryQuestionsRequest Validation Tests")
class QueryQuestionsRequestTest {

    private static Validator validator;

    @BeforeAll
    static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    @DisplayName("Should create valid request with all fields")
    void shouldCreateValidRequestWithAllFields() {
        // GIVEN: Valid request data
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(123456L)
                .questionBankId(789012L)
                .categories(List.of("Math", "Algebra"))
                .tags(List.of("equations", "beginner"))
                .quizzes(List.of("midterm-2024"))
                .searchText("solve for x")
                .page(0)
                .size(20)
                .sortBy("createdAt")
                .sortDirection("desc")
                .build();

        // WHEN: Validating request
        Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);

        // THEN: Should have no violations
        assertThat(violations).isEmpty();
    }

    @Test
    @DisplayName("Should fail validation when userId is null")
    void shouldFailValidationWhenUserIdIsNull() {
        // GIVEN: Request with null userId
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(null)
                .questionBankId(789012L)
                .build();

        // WHEN: Validating request
        Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);

        // THEN: Should have violation
        assertThat(violations).hasSize(1);
        assertThat(violations.iterator().next().getMessage())
                .contains("must not be null");
    }

    @Test
    @DisplayName("Should fail validation when questionBankId is null")
    void shouldFailValidationWhenQuestionBankIdIsNull() {
        // GIVEN: Request with null questionBankId
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(123456L)
                .questionBankId(null)
                .build();

        // WHEN: Validating request
        Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);

        // THEN: Should have violation
        assertThat(violations).hasSize(1);
        assertThat(violations.iterator().next().getMessage())
                .contains("must not be null");
    }

    @Test
    @DisplayName("Should fail validation when page is negative")
    void shouldFailValidationWhenPageIsNegative() {
        // GIVEN: Request with negative page
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(123456L)
                .questionBankId(789012L)
                .page(-1)
                .size(20)
                .build();

        // WHEN: Validating request
        Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);

        // THEN: Should have violation
        assertThat(violations).hasSize(1);
        assertThat(violations.iterator().next().getMessage())
                .contains("must be greater than or equal to 0");
    }

    @Test
    @DisplayName("Should fail validation when size exceeds maximum")
    void shouldFailValidationWhenSizeExceedsMaximum() {
        // GIVEN: Request with size > 100
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(123456L)
                .questionBankId(789012L)
                .page(0)
                .size(150)
                .build();

        // WHEN: Validating request
        Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);

        // THEN: Should have violation
        assertThat(violations).hasSize(1);
        assertThat(violations.iterator().next().getMessage())
                .contains("must be less than or equal to 100");
    }

    @Test
    @DisplayName("Should fail validation when size is less than minimum")
    void shouldFailValidationWhenSizeIsLessThanMinimum() {
        // GIVEN: Request with size < 1
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(123456L)
                .questionBankId(789012L)
                .page(0)
                .size(0)
                .build();

        // WHEN: Validating request
        Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);

        // THEN: Should have violation
        assertThat(violations).hasSize(1);
        assertThat(violations.iterator().next().getMessage())
                .contains("must be greater than or equal to 1");
    }

    @Test
    @DisplayName("Should use default values when optional fields are null")
    void shouldUseDefaultValuesWhenOptionalFieldsAreNull() {
        // GIVEN: Request with only required fields
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(123456L)
                .questionBankId(789012L)
                .build();

        // WHEN: Validating request
        Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);

        // THEN: Should be valid
        assertThat(violations).isEmpty();

        // AND: Should use default values
        assertThat(request.getPage()).isEqualTo(0);
        assertThat(request.getSize()).isEqualTo(20);
        assertThat(request.getSortBy()).isEqualTo("createdAt");
        assertThat(request.getSortDirection()).isEqualTo("desc");
    }

    @Test
    @DisplayName("Should accept empty filter lists")
    void shouldAcceptEmptyFilterLists() {
        // GIVEN: Request with empty filter lists
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(123456L)
                .questionBankId(789012L)
                .categories(List.of())
                .tags(List.of())
                .quizzes(List.of())
                .build();

        // WHEN: Validating request
        Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);

        // THEN: Should be valid
        assertThat(violations).isEmpty();
    }

    @Test
    @DisplayName("Should validate sortBy field values")
    void shouldValidateSortByFieldValues() {
        // GIVEN: Valid sortBy values
        List<String> validSortByValues = List.of("createdAt", "updatedAt", "questionText");

        for (String sortBy : validSortByValues) {
            // WHEN: Creating request with valid sortBy
            QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                    .userId(123456L)
                    .questionBankId(789012L)
                    .sortBy(sortBy)
                    .build();

            // THEN: Should be valid
            Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);
            assertThat(violations).isEmpty();
        }
    }

    @Test
    @DisplayName("Should validate sortDirection values")
    void shouldValidateSortDirectionValues() {
        // GIVEN: Valid sortDirection values
        List<String> validDirections = List.of("asc", "desc");

        for (String direction : validDirections) {
            // WHEN: Creating request with valid sortDirection
            QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                    .userId(123456L)
                    .questionBankId(789012L)
                    .sortDirection(direction)
                    .build();

            // THEN: Should be valid
            Set<ConstraintViolation<QueryQuestionsRequest>> violations = validator.validate(request);
            assertThat(violations).isEmpty();
        }
    }
}
```

#### Task 1.5: Create QueryQuestionsResponse Test

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/application/dto/QueryQuestionsResponseTest.java`

```java
package com.quizfun.questionbankquery.application.dto;

import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1011.query-dtos-and-pagination-logic")
@DisplayName("QueryQuestionsResponse Tests")
class QueryQuestionsResponseTest {

    @Test
    @DisplayName("Should create response with questions and pagination")
    void shouldCreateResponseWithQuestionsAndPagination() {
        // GIVEN: Questions and pagination metadata
        List<QuestionDTO> questions = List.of(
                new QuestionDTO(
                        1L,
                        "What is 2 + 2?",
                        "MCQ",
                        "EASY",
                        Map.of("options", List.of("3", "4", "5")),
                        null,
                        Instant.now(),
                        Instant.now()
                ),
                new QuestionDTO(
                        2L,
                        "What is the capital of France?",
                        "MCQ",
                        "EASY",
                        Map.of("options", List.of("Paris", "London")),
                        null,
                        Instant.now(),
                        Instant.now()
                )
        );

        PaginationMetadata pagination = new PaginationMetadata(0, 20, 50, 3);

        // WHEN: Creating response
        QueryQuestionsResponse response = new QueryQuestionsResponse(questions, pagination);

        // THEN: Should contain all data
        assertThat(response.questions()).hasSize(2);
        assertThat(response.pagination().currentPage()).isZero();
        assertThat(response.pagination().totalItems()).isEqualTo(50);
    }

    @Test
    @DisplayName("Should create response with empty questions list")
    void shouldCreateResponseWithEmptyQuestionsList() {
        // GIVEN: Empty questions list
        List<QuestionDTO> emptyQuestions = List.of();
        PaginationMetadata pagination = new PaginationMetadata(0, 20, 0, 0);

        // WHEN: Creating response
        QueryQuestionsResponse response = new QueryQuestionsResponse(emptyQuestions, pagination);

        // THEN: Should have empty list
        assertThat(response.questions()).isEmpty();
        assertThat(response.pagination().totalItems()).isZero();
    }
}
```

#### Task 1.6: Run Tests (Should FAIL)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=*DTOTest
```

**Expected Result**: Tests should FAIL because DTOs don't exist yet.

---

## Phase 2: GREEN (Make Tests Pass)

### Objective
Implement DTOs to make all tests pass.

### Tasks

#### Task 2.1: Create QuestionDTO

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/dto/QuestionDTO.java`

```java
package com.quizfun.questionbankquery.application.dto;

import java.time.Instant;
import java.util.Map;

/**
 * Data Transfer Object representing a question in query responses.
 *
 * <p>This is a simplified read model optimized for query operations,
 * without the complexity of domain aggregates.
 *
 * @param questionId Unique identifier for the question
 * @param questionText The text content of the question
 * @param questionType Type of question (MCQ, TRUE_FALSE, ESSAY, etc.)
 * @param difficultyLevel Difficulty level (EASY, MEDIUM, HARD, EXPERT)
 * @param typeSpecificData Type-specific fields (options, correctAnswer, etc.)
 * @param taxonomy Associated taxonomy (categories, tags, quizzes)
 * @param createdAt Timestamp when question was created
 * @param updatedAt Timestamp when question was last updated
 */
public record QuestionDTO(
        Long questionId,
        String questionText,
        String questionType,
        String difficultyLevel,
        Map<String, Object> typeSpecificData,
        TaxonomyDTO taxonomy,
        Instant createdAt,
        Instant updatedAt
) {
}
```

#### Task 2.2: Create TaxonomyDTO

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/dto/TaxonomyDTO.java`

```java
package com.quizfun.questionbankquery.application.dto;

import java.util.List;

/**
 * Data Transfer Object representing taxonomy information for a question.
 *
 * <p>Taxonomy includes:
 * <ul>
 *   <li>Categories: Hierarchical classification (AND logic)</li>
 *   <li>Tags: Flat labels for filtering (OR logic)</li>
 *   <li>Quizzes: Associated quiz collections (OR logic)</li>
 * </ul>
 *
 * @param categories List of hierarchical categories (e.g., ["Math", "Algebra", "Equations"])
 * @param tags List of tags for filtering (e.g., ["beginner", "practice"])
 * @param quizzes List of associated quizzes (e.g., ["midterm-2024", "practice-set-1"])
 */
public record TaxonomyDTO(
        List<String> categories,
        List<String> tags,
        List<String> quizzes
) {
}
```

#### Task 2.3: Create PaginationMetadata

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/dto/PaginationMetadata.java`

```java
package com.quizfun.questionbankquery.application.dto;

/**
 * Data Transfer Object containing pagination metadata for query responses.
 *
 * @param currentPage Current page number (zero-indexed)
 * @param pageSize Number of items per page
 * @param totalItems Total number of items across all pages
 * @param totalPages Total number of pages
 */
public record PaginationMetadata(
        int currentPage,
        int pageSize,
        long totalItems,
        int totalPages
) {
}
```

#### Task 2.4: Create QueryQuestionsRequest

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/dto/QueryQuestionsRequest.java`

```java
package com.quizfun.questionbankquery.application.dto;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import lombok.Builder;
import lombok.Getter;

import java.util.List;

/**
 * Request DTO for querying questions with filters and pagination.
 *
 * <p>Filter Logic:
 * <ul>
 *   <li>Categories: AND logic across levels (all must match)</li>
 *   <li>Tags: OR logic (at least one must match)</li>
 *   <li>Quizzes: OR logic (at least one must match)</li>
 *   <li>Combined: AND logic between different types</li>
 * </ul>
 */
@Getter
@Builder
public class QueryQuestionsRequest {

    @NotNull(message = "User ID must not be null")
    private final Long userId;

    @NotNull(message = "Question Bank ID must not be null")
    private final Long questionBankId;

    /**
     * Filter by hierarchical categories (AND logic).
     * Example: ["Math", "Algebra"] requires both levels.
     */
    private final List<String> categories;

    /**
     * Filter by tags (OR logic).
     * Example: ["beginner", "practice"] matches questions with either tag.
     */
    private final List<String> tags;

    /**
     * Filter by quiz collections (OR logic).
     * Example: ["midterm-2024", "practice-set-1"] matches questions in either quiz.
     */
    private final List<String> quizzes;

    /**
     * Full-text search on question text.
     */
    private final String searchText;

    /**
     * Page number (zero-indexed).
     */
    @Min(value = 0, message = "Page must be greater than or equal to 0")
    @Builder.Default
    private final Integer page = 0;

    /**
     * Number of items per page.
     */
    @Min(value = 1, message = "Size must be greater than or equal to 1")
    @Max(value = 100, message = "Size must be less than or equal to 100")
    @Builder.Default
    private final Integer size = 20;

    /**
     * Sort field (createdAt, updatedAt, questionText).
     */
    @Pattern(
            regexp = "^(createdAt|updatedAt|questionText)$",
            message = "Sort by must be one of: createdAt, updatedAt, questionText"
    )
    @Builder.Default
    private final String sortBy = "createdAt";

    /**
     * Sort direction (asc, desc).
     */
    @Pattern(
            regexp = "^(asc|desc)$",
            message = "Sort direction must be either 'asc' or 'desc'"
    )
    @Builder.Default
    private final String sortDirection = "desc";
}
```

#### Task 2.5: Create QueryQuestionsResponse

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/dto/QueryQuestionsResponse.java`

```java
package com.quizfun.questionbankquery.application.dto;

import java.util.List;

/**
 * Response DTO containing query results with pagination metadata.
 *
 * @param questions List of questions matching the query
 * @param pagination Pagination metadata (current page, total pages, etc.)
 */
public record QueryQuestionsResponse(
        List<QuestionDTO> questions,
        PaginationMetadata pagination
) {
}
```

#### Task 2.6: Add Validation Dependency to POM

**File**: `internal-layer/question-bank-query/pom.xml`

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

#### Task 2.7: Run Tests (Should PASS)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=*DTOTest
```

**Expected Result**: All DTO tests should PASS.

---

## Phase 3: REFACTOR (Improve Code Quality)

### Objective
Improve code quality, add builder pattern, and enhance documentation.

### Tasks

#### Task 3.1: Add Custom Validator for SortBy Field

Create a custom validation annotation for better error messages.

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/validation/ValidSortField.java`

```java
package com.quizfun.questionbankquery.application.validation;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Validates that the sort field is one of the allowed values.
 */
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = SortFieldValidator.class)
@Documented
public @interface ValidSortField {
    String message() default "Invalid sort field";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/validation/SortFieldValidator.java`

```java
package com.quizfun.questionbankquery.application.validation;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.util.Set;

/**
 * Validator for sort field values.
 */
public class SortFieldValidator implements ConstraintValidator<ValidSortField, String> {

    private static final Set<String> VALID_FIELDS = Set.of(
            "createdAt",
            "updatedAt",
            "questionText"
    );

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // Let @NotNull handle null validation
        }
        return VALID_FIELDS.contains(value);
    }
}
```

#### Task 3.2: Add Utility Method for Pagination Calculation

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/dto/PaginationMetadata.java`

```java
package com.quizfun.questionbankquery.application.dto;

/**
 * Data Transfer Object containing pagination metadata for query responses.
 *
 * @param currentPage Current page number (zero-indexed)
 * @param pageSize Number of items per page
 * @param totalItems Total number of items across all pages
 * @param totalPages Total number of pages
 */
public record PaginationMetadata(
        int currentPage,
        int pageSize,
        long totalItems,
        int totalPages
) {
    /**
     * Factory method to calculate pagination metadata from total count.
     *
     * @param currentPage Current page number (zero-indexed)
     * @param pageSize Number of items per page
     * @param totalItems Total number of items
     * @return Pagination metadata with calculated total pages
     */
    public static PaginationMetadata of(int currentPage, int pageSize, long totalItems) {
        int totalPages = (int) Math.ceil((double) totalItems / pageSize);
        return new PaginationMetadata(currentPage, pageSize, totalItems, totalPages);
    }
}
```

#### Task 3.3: Add Test for Pagination Factory Method

**File**: Update `PaginationMetadataTest.java`

```java
@Test
@DisplayName("Should create pagination metadata using factory method")
void shouldCreatePaginationMetadataUsingFactoryMethod() {
    // GIVEN: Page info and total items
    int currentPage = 2;
    int pageSize = 20;
    long totalItems = 95;

    // WHEN: Using factory method
    PaginationMetadata metadata = PaginationMetadata.of(currentPage, pageSize, totalItems);

    // THEN: Should calculate total pages correctly
    assertThat(metadata.currentPage()).isEqualTo(2);
    assertThat(metadata.pageSize()).isEqualTo(20);
    assertThat(metadata.totalItems()).isEqualTo(95);
    assertThat(metadata.totalPages()).isEqualTo(5); // Math.ceil(95/20) = 5
}
```

#### Task 3.4: Run All Tests with Coverage

```bash
mvn clean verify -pl internal-layer/question-bank-query
```

Verify:
- ✅ All tests pass
- ✅ JaCoCo coverage > 70%
- ✅ No Checkstyle violations

#### Task 3.5: Generate Allure Report

```bash
mvn allure:report -pl internal-layer/question-bank-query
```

Verify in Allure report:
- ✅ Epic: "Use Case Query List of Questions of Question Bank"
- ✅ Story: "1011.query-dtos-and-pagination-logic"
- ✅ All DTO tests displayed correctly

---

## Definition of Done

- [ ] All DTOs created with proper structure
- [ ] Validation annotations applied correctly
- [ ] All tests pass with green status
- [ ] JaCoCo code coverage >= 70%
- [ ] Allure annotations correctly applied
- [ ] Allure report generated successfully
- [ ] Code properly documented with Javadoc
- [ ] Builder pattern implemented for request DTO
- [ ] Factory method for pagination metadata
- [ ] No Checkstyle violations
- [ ] No SonarLint warnings
- [ ] Code reviewed and approved

---

## Testing Checklist

### Unit Tests
- [ ] ✅ QuestionDTO creation with all fields
- [ ] ✅ QuestionDTO with null optional fields
- [ ] ✅ TaxonomyDTO with all fields
- [ ] ✅ TaxonomyDTO with empty lists
- [ ] ✅ PaginationMetadata creation
- [ ] ✅ PaginationMetadata calculation
- [ ] ✅ PaginationMetadata factory method
- [ ] ✅ QueryQuestionsRequest validation (userId null)
- [ ] ✅ QueryQuestionsRequest validation (questionBankId null)
- [ ] ✅ QueryQuestionsRequest validation (page negative)
- [ ] ✅ QueryQuestionsRequest validation (size exceeds max)
- [ ] ✅ QueryQuestionsRequest validation (size below min)
- [ ] ✅ QueryQuestionsRequest default values
- [ ] ✅ QueryQuestionsRequest empty filter lists
- [ ] ✅ QueryQuestionsRequest sortBy validation
- [ ] ✅ QueryQuestionsRequest sortDirection validation
- [ ] ✅ QueryQuestionsResponse with questions
- [ ] ✅ QueryQuestionsResponse with empty list

---

## Estimated Effort

- **RED Phase**: 2 hours
- **GREEN Phase**: 1.5 hours
- **REFACTOR Phase**: 1 hour
- **Total**: 4.5 hours

---

## Dependencies

- **1010.testcontainer-mongodb-setup-and-configuration**: Must be completed first for test infrastructure

---

## Notes

### Design Decisions

1. **Record Types**: Used Java records for immutable DTOs (QuestionDTO, TaxonomyDTO, PaginationMetadata, QueryQuestionsResponse)
2. **Builder Pattern**: Used Lombok @Builder for request DTO to handle many optional parameters
3. **Validation**: Used Jakarta validation annotations for compile-time safety
4. **Default Values**: Pagination defaults to page=0, size=20, sortBy=createdAt, sortDirection=desc
5. **Filter Logic**: Categories use AND, tags/quizzes use OR (documented in Javadoc)

### Why No Domain Layer?

The query side doesn't need domain complexity because:
- Read operations don't enforce business rules
- No invariant protection needed
- No state transitions or domain events
- Direct mapping from database to DTOs is sufficient
