# US-009: HTTP API Integration

## Story Overview
**As a** content creator
**I want** a reliable HTTP API endpoint for question management
**So that** I can create and update questions through web requests with proper error handling and status codes

## Business Value
- Provides web API access to question management functionality
- Ensures proper HTTP semantics and RESTful design principles
- Enables integration with frontend applications and external systems
- Supports comprehensive error handling with appropriate HTTP status codes

## Work Breakdown Structure (WBS)

### 1. REST Controller Implementation
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: US-008 CQRS Command Handler complete

#### Tasks:
- [ ] **1.1** Design QuestionController class structure
- [ ] **1.2** Implement POST endpoint with path parameter extraction
- [ ] **1.3** Add request body validation and binding
- [ ] **1.4** Integrate with mediator for command processing
- [ ] **1.5** Implement comprehensive error handling
- [ ] **1.6** Add HTTP status code mapping

#### Implementation Details:
```java
// Location: internal-layer/orchestration-layer/src/main/java/com/quizfun/orchestrationlayer/controllers/QuestionController.java
@RestController
@RequestMapping("/api/users/{userId}/questionbanks/{questionbankId}")
@Validated
@Slf4j
public class QuestionController {

    private final IMediator mediator;

    public QuestionController(IMediator mediator) {
        this.mediator = mediator;
        log.info("QuestionController initialized with mediator");
    }

    @PostMapping("/questions")
    public ResponseEntity<Result<QuestionResponseDto>> upsertQuestion(
            @PathVariable @Positive Long userId,
            @PathVariable @Positive Long questionbankId,
            @Valid @RequestBody UpsertQuestionRequestDto request,
            HttpServletRequest httpRequest) {

        log.info("Received upsert question request for user: {} and question bank: {} from IP: {}",
                userId, questionbankId, getClientIpAddress(httpRequest));

        try {
            // Create command with path parameters and request body
            var command = new UpsertQuestionCommand(userId, questionbankId, request);

            // Send command through mediator
            var result = mediator.send(command);

            if (result.isSuccess()) {
                log.info("Successfully processed upsert question request for source ID: {} with operation: {}",
                        request.getSourceQuestionId(), result.getValue().getOperation());

                return ResponseEntity.ok()
                    .header("X-Operation", result.getValue().getOperation())
                    .header("X-Question-Id", result.getValue().getQuestionId())
                    .body(result);
            } else {
                log.warn("Failed to process upsert question request for source ID: {} with error: {}",
                        request.getSourceQuestionId(), result.getError());

                return createErrorResponse(result);
            }

        } catch (IllegalArgumentException ex) {
            log.warn("Invalid request parameters for user: {} and question bank: {}: {}",
                    userId, questionbankId, ex.getMessage());

            var errorResult = Result.<QuestionResponseDto>failure(
                "INVALID_REQUEST", "Invalid request parameters: " + ex.getMessage());
            return ResponseEntity.badRequest().body(errorResult);

        } catch (Exception ex) {
            log.error("Unexpected error processing upsert question request for user: {} and question bank: {}",
                     userId, questionbankId, ex);

            var errorResult = Result.<QuestionResponseDto>failure(
                "INTERNAL_ERROR", "An unexpected error occurred");
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResult);
        }
    }

    private ResponseEntity<Result<QuestionResponseDto>> createErrorResponse(Result<QuestionResponseDto> result) {
        var error = result.getError();

        // Map error codes to HTTP status codes
        if (error.startsWith("UNAUTHORIZED_ACCESS") || error.startsWith("QUESTION_BANK_NOT_FOUND")) {
            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(result);
        } else if (error.startsWith("TAXONOMY_REFERENCE_NOT_FOUND")) {
            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(result);
        } else if (error.startsWith("MISSING_REQUIRED_FIELD") ||
                   error.startsWith("TYPE_DATA_MISMATCH") ||
                   error.startsWith("INVALID_QUESTION_TYPE")) {
            return ResponseEntity.badRequest().body(result);
        } else if (error.startsWith("DUPLICATE_SOURCE_QUESTION_ID")) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(result);
        } else if (error.startsWith("DATABASE_ERROR") ||
                   error.startsWith("TRANSACTION_FAILED")) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
        } else {
            // Default to bad request for unknown errors
            return ResponseEntity.badRequest().body(result);
        }
    }

    private String getClientIpAddress(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        String xRealIp = request.getHeader("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }
        return request.getRemoteAddr();
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Result<QuestionResponseDto>> handleValidationErrors(MethodArgumentNotValidException ex) {
        log.warn("Validation error in request: {}", ex.getMessage());

        var errors = ex.getBindingResult().getFieldErrors().stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.joining(", "));

        var errorResult = Result.<QuestionResponseDto>failure(
            "VALIDATION_ERROR", "Request validation failed: " + errors);

        return ResponseEntity.badRequest().body(errorResult);
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<Result<QuestionResponseDto>> handleConstraintViolation(ConstraintViolationException ex) {
        log.warn("Constraint violation in request: {}", ex.getMessage());

        var errorResult = Result.<QuestionResponseDto>failure(
            "CONSTRAINT_VIOLATION", "Request constraint violation: " + ex.getMessage());

        return ResponseEntity.badRequest().body(errorResult);
    }
}
```

#### Acceptance Criteria:
- REST endpoint follows RESTful design principles
- Path parameters properly extracted and validated
- Request body validation with comprehensive error messages
- HTTP status codes correctly mapped to business errors
- Comprehensive logging for debugging and monitoring

#### Test Requirements:
- [ ] Unit test: successful request processing
- [ ] Unit test: path parameter validation
- [ ] Unit test: request body validation
- [ ] Unit test: error code to HTTP status mapping
- [ ] Unit test: exception handling

---

### 2. Request DTO Implementation and Validation
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 1 structure complete

#### Tasks:
- [ ] **2.1** Define UpsertQuestionRequestDto structure
- [ ] **2.2** Add comprehensive Bean Validation annotations
- [ ] **2.3** Implement custom validation for taxonomy data
- [ ] **2.4** Add JSON deserialization configuration
- [ ] **2.5** Create request DTO builder for testing

#### Implementation Details:
```java
// Location: internal-layer/orchestration-layer/src/main/java/com/quizfun/orchestrationlayer/dto/UpsertQuestionRequestDto.java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class UpsertQuestionRequestDto {

    @NotBlank(message = "Source question ID is required")
    @Size(max = 100, message = "Source question ID cannot exceed 100 characters")
    @JsonProperty("source_question_id")
    private String sourceQuestionId;

    @NotBlank(message = "Question type is required")
    @Pattern(regexp = "^(mcq|essay|true_false)$", message = "Question type must be mcq, essay, or true_false")
    @JsonProperty("question_type")
    private String questionType;

    @NotBlank(message = "Title is required")
    @Size(max = 500, message = "Title cannot exceed 500 characters")
    private String title;

    @NotBlank(message = "Content is required")
    @Size(max = 10000, message = "Content cannot exceed 10000 characters")
    private String content;

    @Min(value = 0, message = "Points cannot be negative")
    @Max(value = 1000, message = "Points cannot exceed 1000")
    private Integer points;

    @Pattern(regexp = "^(draft|published|archived)$", message = "Status must be draft, published, or archived")
    private String status;

    @Size(max = 2000, message = "Solution explanation cannot exceed 2000 characters")
    @JsonProperty("solution_explanation")
    private String solutionExplanation;

    @Min(value = 1, message = "Display order must be positive")
    @JsonProperty("display_order")
    private Integer displayOrder;

    @NotNull(message = "Taxonomy data is required")
    @Valid
    private TaxonomyDataDto taxonomy;

    @Valid
    @JsonProperty("mcq_data")
    private McqDataDto mcqData;

    @Valid
    @JsonProperty("essay_data")
    private EssayDataDto essayData;

    @Valid
    @JsonProperty("true_false_data")
    private TrueFalseDataDto trueFalseData;

    @Valid
    private List<AttachmentDto> attachments;

    @Valid
    @JsonProperty("question_settings")
    private QuestionSettingsDto questionSettings;

    @Valid
    private QuestionMetadataDto metadata;

    // Custom validation method
    @AssertTrue(message = "Type-specific data must match question type")
    public boolean isTypeSpecificDataValid() {
        if (questionType == null) {
            return true; // Let @NotBlank handle this
        }

        switch (questionType.toLowerCase()) {
            case "mcq":
                return mcqData != null && essayData == null && trueFalseData == null;
            case "essay":
                return essayData != null && mcqData == null && trueFalseData == null;
            case "true_false":
                return trueFalseData != null && mcqData == null && essayData == null;
            default:
                return false;
        }
    }

    // Default constructor for Jackson
    public UpsertQuestionRequestDto() {}

    // Builder pattern for testing
    public static class Builder {
        private final UpsertQuestionRequestDto dto = new UpsertQuestionRequestDto();

        public Builder sourceQuestionId(String sourceQuestionId) {
            dto.sourceQuestionId = sourceQuestionId;
            return this;
        }

        public Builder questionType(String questionType) {
            dto.questionType = questionType;
            return this;
        }

        public Builder title(String title) {
            dto.title = title;
            return this;
        }

        public Builder content(String content) {
            dto.content = content;
            return this;
        }

        public Builder points(Integer points) {
            dto.points = points;
            return this;
        }

        public Builder status(String status) {
            dto.status = status;
            return this;
        }

        public Builder taxonomy(TaxonomyDataDto taxonomy) {
            dto.taxonomy = taxonomy;
            return this;
        }

        public Builder mcqData(McqDataDto mcqData) {
            dto.mcqData = mcqData;
            return this;
        }

        public Builder essayData(EssayDataDto essayData) {
            dto.essayData = essayData;
            return this;
        }

        public Builder trueFalseData(TrueFalseDataDto trueFalseData) {
            dto.trueFalseData = trueFalseData;
            return this;
        }

        public UpsertQuestionRequestDto build() {
            return dto;
        }
    }

    // Getters and setters
    public String getSourceQuestionId() { return sourceQuestionId; }
    public void setSourceQuestionId(String sourceQuestionId) { this.sourceQuestionId = sourceQuestionId; }

    public String getQuestionType() { return questionType; }
    public void setQuestionType(String questionType) { this.questionType = questionType; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }

    public Integer getPoints() { return points; }
    public void setPoints(Integer points) { this.points = points; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getSolutionExplanation() { return solutionExplanation; }
    public void setSolutionExplanation(String solutionExplanation) { this.solutionExplanation = solutionExplanation; }

    public Integer getDisplayOrder() { return displayOrder; }
    public void setDisplayOrder(Integer displayOrder) { this.displayOrder = displayOrder; }

    public TaxonomyDataDto getTaxonomy() { return taxonomy; }
    public void setTaxonomy(TaxonomyDataDto taxonomy) { this.taxonomy = taxonomy; }

    public McqDataDto getMcqData() { return mcqData; }
    public void setMcqData(McqDataDto mcqData) { this.mcqData = mcqData; }

    public EssayDataDto getEssayData() { return essayData; }
    public void setEssayData(EssayDataDto essayData) { this.essayData = essayData; }

    public TrueFalseDataDto getTrueFalseData() { return trueFalseData; }
    public void setTrueFalseData(TrueFalseDataDto trueFalseData) { this.trueFalseData = trueFalseData; }

    public List<AttachmentDto> getAttachments() { return attachments; }
    public void setAttachments(List<AttachmentDto> attachments) { this.attachments = attachments; }

    public QuestionSettingsDto getQuestionSettings() { return questionSettings; }
    public void setQuestionSettings(QuestionSettingsDto questionSettings) { this.questionSettings = questionSettings; }

    public QuestionMetadataDto getMetadata() { return metadata; }
    public void setMetadata(QuestionMetadataDto metadata) { this.metadata = metadata; }
}
```

#### Acceptance Criteria:
- Comprehensive Bean Validation annotations for all fields
- Custom validation for type-specific data consistency
- JSON deserialization configured correctly
- Builder pattern enables easy testing
- Clear validation error messages

#### Test Requirements:
- [ ] Unit test: successful DTO creation and validation
- [ ] Unit test: validation failure scenarios for all fields
- [ ] Unit test: type-specific data validation
- [ ] Unit test: JSON deserialization
- [ ] Unit test: builder pattern functionality

---

### 3. Error Response Formatting and HTTP Status Mapping
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 2 complete

#### Tasks:
- [ ] **3.1** Implement comprehensive error response formatting
- [ ] **3.2** Create HTTP status code mapping strategy
- [ ] **3.3** Add error response consistency validation
- [ ] **3.4** Implement error response logging
- [ ] **3.5** Add error response documentation

#### Implementation Details:
```java
// Location: internal-layer/orchestration-layer/src/main/java/com/quizfun/orchestrationlayer/dto/ErrorResponseDto.java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponseDto {

    @JsonProperty("status")
    private final String status = "error";

    @JsonProperty("error_code")
    private final String errorCode;

    @JsonProperty("message")
    private final String message;

    @JsonProperty("details")
    private final Map<String, Object> details;

    @JsonProperty("timestamp")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
    private final Instant timestamp;

    @JsonProperty("path")
    private final String path;

    public ErrorResponseDto(String errorCode, String message, String path) {
        this(errorCode, message, path, null);
    }

    public ErrorResponseDto(String errorCode, String message, String path, Map<String, Object> details) {
        this.errorCode = errorCode;
        this.message = message;
        this.path = path;
        this.details = details;
        this.timestamp = Instant.now();
    }

    // Getters
    public String getStatus() { return status; }
    public String getErrorCode() { return errorCode; }
    public String getMessage() { return message; }
    public Map<String, Object> getDetails() { return details; }
    public Instant getTimestamp() { return timestamp; }
    public String getPath() { return path; }
}

// HTTP Status Code Mapping Utility
@Component
public class HttpStatusMapper {

    private static final Logger log = LoggerFactory.getLogger(HttpStatusMapper.class);

    private static final Map<String, HttpStatus> ERROR_CODE_TO_STATUS = Map.of(
        "UNAUTHORIZED_ACCESS", HttpStatus.UNPROCESSABLE_ENTITY,
        "QUESTION_BANK_NOT_FOUND", HttpStatus.UNPROCESSABLE_ENTITY,
        "TAXONOMY_REFERENCE_NOT_FOUND", HttpStatus.UNPROCESSABLE_ENTITY,
        "MISSING_REQUIRED_FIELD", HttpStatus.BAD_REQUEST,
        "TYPE_DATA_MISMATCH", HttpStatus.BAD_REQUEST,
        "INVALID_QUESTION_TYPE", HttpStatus.BAD_REQUEST,
        "DUPLICATE_SOURCE_QUESTION_ID", HttpStatus.CONFLICT,
        "DATABASE_ERROR", HttpStatus.INTERNAL_SERVER_ERROR,
        "TRANSACTION_FAILED", HttpStatus.INTERNAL_SERVER_ERROR
    );

    public HttpStatus mapErrorCodeToStatus(String errorCode) {
        if (errorCode == null) {
            log.warn("Null error code provided, defaulting to BAD_REQUEST");
            return HttpStatus.BAD_REQUEST;
        }

        // Extract the error code prefix (before the first colon)
        String errorPrefix = errorCode.split(":")[0];

        HttpStatus status = ERROR_CODE_TO_STATUS.getOrDefault(errorPrefix, HttpStatus.BAD_REQUEST);

        log.debug("Mapped error code '{}' to HTTP status '{}'", errorCode, status);

        return status;
    }

    public boolean isClientError(String errorCode) {
        HttpStatus status = mapErrorCodeToStatus(errorCode);
        return status.is4xxClientError();
    }

    public boolean isServerError(String errorCode) {
        HttpStatus status = mapErrorCodeToStatus(errorCode);
        return status.is5xxServerError();
    }
}
```

#### Acceptance Criteria:
- Consistent error response format across all endpoints
- HTTP status codes correctly mapped to business error types
- Error responses include all necessary debugging information
- Error response logging for monitoring and debugging
- Documentation for error codes and HTTP status mapping

#### Test Requirements:
- [ ] Unit test: error response DTO creation
- [ ] Unit test: HTTP status code mapping for all error types
- [ ] Unit test: error response JSON serialization
- [ ] Unit test: error logging verification

---

### 4. Integration Testing and API Documentation
**Estimated Effort**: 1 day
**Priority**: Medium
**Dependencies**: Tasks 1, 2, 3 complete

#### Tasks:
- [ ] **4.1** Create comprehensive HTTP API integration tests
- [ ] **4.2** Test all HTTP status code scenarios
- [ ] **4.3** Validate request/response JSON formats
- [ ] **4.4** Add OpenAPI/Swagger documentation
- [ ] **4.5** Create API usage examples and documentation

#### Implementation Details:
```java
// Location: internal-layer/orchestration-layer/src/test/java/com/quizfun/orchestrationlayer/controllers/QuestionControllerIntegrationTest.java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class QuestionControllerIntegrationTest extends BaseTestConfiguration {

    @Autowired
    private TestRestTemplate restTemplate;

    @LocalServerPort
    private int port;

    @Test
    @Epic("Question Management")
    @Feature("HTTP API Integration")
    @Story("HTTP API Integration")
    @DisplayName("Should accept valid POST request and return 200 OK with created operation")
    void shouldAcceptValidPostRequestAndReturn200OkWithCreatedOperation() {
        // Given
        var request = createValidMcqRequest();
        var url = String.format("http://localhost:%d/api/users/3/questionbanks/123/questions", port);

        var httpHeaders = new HttpHeaders();
        httpHeaders.setContentType(MediaType.APPLICATION_JSON);

        var httpEntity = new HttpEntity<>(request, httpHeaders);

        // When
        var response = restTemplate.postForEntity(url, httpEntity, String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        var responseBody = parseJsonResponse(response.getBody());
        assertThat(responseBody.get("status")).isEqualTo("success");

        var data = (Map<String, Object>) responseBody.get("data");
        assertThat(data.get("operation")).isEqualTo("created");
        assertThat(data.get("source_question_id")).isEqualTo(request.getSourceQuestionId());
        assertThat(data.get("question_id")).isNotNull();
        assertThat(data.get("taxonomy_relationships_count")).isNotNull();
    }

    @Test
    @DisplayName("Should return 400 Bad Request for missing required fields")
    void shouldReturn400BadRequestForMissingRequiredFields() {
        // Given
        var request = createRequestWithMissingTitle();
        var url = String.format("http://localhost:%d/api/users/3/questionbanks/123/questions", port);

        var httpEntity = new HttpEntity<>(request, createJsonHeaders());

        // When
        var response = restTemplate.postForEntity(url, httpEntity, String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);

        var responseBody = parseJsonResponse(response.getBody());
        assertThat(responseBody.get("status")).isEqualTo("error");
        assertThat(responseBody.get("error_code")).isEqualTo("VALIDATION_ERROR");
        assertThat(responseBody.get("message")).asString().contains("title");
    }

    @Test
    @DisplayName("Should return 422 Unprocessable Entity for unauthorized access")
    void shouldReturn422UnprocessableEntityForUnauthorizedAccess() {
        // Given
        var request = createValidMcqRequest();
        var url = String.format("http://localhost:%d/api/users/999/questionbanks/123/questions", port);

        var httpEntity = new HttpEntity<>(request, createJsonHeaders());

        // When
        var response = restTemplate.postForEntity(url, httpEntity, String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNPROCESSABLE_ENTITY);

        var responseBody = parseJsonResponse(response.getBody());
        assertThat(responseBody.get("status")).isEqualTo("error");
        assertThat(responseBody.get("error_code")).asString().startsWith("UNAUTHORIZED_ACCESS");
    }

    @Test
    @DisplayName("Should return 422 Unprocessable Entity for invalid taxonomy references")
    void shouldReturn422UnprocessableEntityForInvalidTaxonomyReferences() {
        // Given
        var request = createRequestWithInvalidTaxonomyReferences();
        var url = String.format("http://localhost:%d/api/users/3/questionbanks/123/questions", port);

        var httpEntity = new HttpEntity<>(request, createJsonHeaders());

        // When
        var response = restTemplate.postForEntity(url, httpEntity, String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNPROCESSABLE_ENTITY);

        var responseBody = parseJsonResponse(response.getBody());
        assertThat(responseBody.get("status")).isEqualTo("error");
        assertThat(responseBody.get("error_code")).asString().startsWith("TAXONOMY_REFERENCE_NOT_FOUND");
    }

    @Test
    @DisplayName("Should update existing question and return updated operation")
    void shouldUpdateExistingQuestionAndReturnUpdatedOperation() {
        // Given
        var request = createValidMcqRequest();
        request.setSourceQuestionId("existing-question-for-update-test"); // From test data
        request.setTitle("Updated Question Title");

        var url = String.format("http://localhost:%d/api/users/3/questionbanks/123/questions", port);
        var httpEntity = new HttpEntity<>(request, createJsonHeaders());

        // When
        var response = restTemplate.postForEntity(url, httpEntity, String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        var responseBody = parseJsonResponse(response.getBody());
        var data = (Map<String, Object>) responseBody.get("data");
        assertThat(data.get("operation")).isEqualTo("updated");
    }

    @Test
    @DisplayName("Should handle malformed JSON requests gracefully")
    void shouldHandleMalformedJsonRequestsGracefully() {
        // Given
        var malformedJson = "{ invalid json }";
        var url = String.format("http://localhost:%d/api/users/3/questionbanks/123/questions", port);

        var httpEntity = new HttpEntity<>(malformedJson, createJsonHeaders());

        // When
        var response = restTemplate.postForEntity(url, httpEntity, String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
    }

    private HttpHeaders createJsonHeaders() {
        var headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return headers;
    }

    private Map<String, Object> parseJsonResponse(String json) {
        try {
            var objectMapper = new ObjectMapper();
            return objectMapper.readValue(json, Map.class);
        } catch (Exception ex) {
            throw new RuntimeException("Failed to parse JSON response", ex);
        }
    }
}
```

#### OpenAPI Documentation:
```java
// Location: internal-layer/orchestration-layer/src/main/java/com/quizfun/orchestrationlayer/config/OpenApiConfig.java
@Configuration
@OpenAPIDefinition(
    info = @Info(
        title = "Quiz CMS API",
        version = "1.0",
        description = "API for managing quiz questions and taxonomies"
    )
)
public class OpenApiConfig {

    @Bean
    public OpenAPI questionManagementOpenAPI() {
        return new OpenAPI()
            .addServersItem(new Server().url("http://localhost:8765").description("Development server"))
            .info(new Info()
                .title("Quiz CMS Question Management API")
                .description("RESTful API for creating and updating quiz questions with complex taxonomy relationships")
                .version("1.0.0")
                .license(new License().name("MIT").url("http://opensource.org/licenses/MIT")))
            .addTagsItem(new Tag().name("Questions").description("Question management operations"));
    }
}

// Add to QuestionController
@Tag(name = "Questions", description = "Question management operations")
@Operation(
    summary = "Create or update a question",
    description = "Creates a new question or updates an existing question based on the source_question_id. " +
                 "The operation determines whether to create or update based on whether a question with the " +
                 "given source_question_id already exists for the user and question bank.",
    responses = {
        @ApiResponse(responseCode = "200", description = "Question successfully created or updated",
                    content = @Content(mediaType = "application/json",
                    schema = @Schema(implementation = QuestionResponseDto.class))),
        @ApiResponse(responseCode = "400", description = "Invalid request data",
                    content = @Content(mediaType = "application/json",
                    schema = @Schema(implementation = ErrorResponseDto.class))),
        @ApiResponse(responseCode = "422", description = "Business rule violation",
                    content = @Content(mediaType = "application/json",
                    schema = @Schema(implementation = ErrorResponseDto.class))),
        @ApiResponse(responseCode = "500", description = "Internal server error",
                    content = @Content(mediaType = "application/json",
                    schema = @Schema(implementation = ErrorResponseDto.class)))
    }
)
@PostMapping("/questions")
public ResponseEntity<Result<QuestionResponseDto>> upsertQuestion(
    @Parameter(description = "User ID", required = true, example = "3")
    @PathVariable @Positive Long userId,

    @Parameter(description = "Question Bank ID", required = true, example = "123")
    @PathVariable @Positive Long questionbankId,

    @Parameter(description = "Question data", required = true)
    @Valid @RequestBody UpsertQuestionRequestDto request,

    HttpServletRequest httpRequest) {
    // Implementation...
}
```

#### Acceptance Criteria:
- All HTTP status code scenarios tested and validated
- Request and response JSON formats verified
- OpenAPI/Swagger documentation complete and accurate
- API usage examples provided
- Performance benchmarks established

#### Test Requirements:
- [ ] Integration test: all HTTP status codes (200, 400, 422, 500)
- [ ] Integration test: request/response JSON validation
- [ ] Integration test: malformed request handling
- [ ] Integration test: complete workflow scenarios
- [ ] Performance test: API response times

---

## Acceptance Criteria Summary

### Functional Requirements
- [ ] REST endpoint accepts POST requests at `/api/users/{userId}/questionbanks/{questionbankId}/questions`
- [ ] Path parameters properly extracted and validated
- [ ] Request body validation with comprehensive error messages
- [ ] HTTP status codes correctly mapped to business error types
- [ ] Response format consistent with API specification
- [ ] Complete integration with CQRS command handling

### Non-Functional Requirements
- [ ] API response time <500ms for typical requests
- [ ] Request validation time <50ms
- [ ] JSON serialization/deserialization time <10ms
- [ ] API documentation complete and accurate

### Definition of Done
- [ ] QuestionController with complete HTTP handling implemented
- [ ] Request and response DTOs with validation
- [ ] Error handling returns appropriate HTTP status codes
- [ ] Comprehensive integration tests covering all scenarios
- [ ] OpenAPI documentation generated and validated
- [ ] Performance benchmarks established
- [ ] Code review completed

## Dependencies and Risks

### Dependencies
- US-008 CQRS Command Handler complete
- global-shared-library mediator working
- Spring Boot web starter configuration
- Bean Validation framework setup

### Risks
- **Risk**: HTTP status code mapping complexity
  **Mitigation**: Comprehensive mapping utility with clear documentation

- **Risk**: Request validation performance overhead
  **Mitigation**: Optimize validation rules and add performance monitoring

- **Risk**: Error response consistency across different error types
  **Mitigation**: Standardized error response formatting

## Testing Strategy

### Unit Testing
- Controller method logic with mocked dependencies
- Request DTO validation scenarios
- Error response formatting
- HTTP status code mapping

### Integration Testing
- Complete HTTP workflow with real dependencies
- Request/response JSON serialization
- Error handling across all layers
- API documentation accuracy

### Test Data Requirements
- Valid request payloads for all question types
- Invalid request payloads for validation testing
- Error scenario test cases
- Performance test datasets

## Technical Notes

### Design Patterns Used
- **MVC Pattern**: Spring MVC controller implementation
- **DTO Pattern**: Request and response data transfer objects
- **Builder Pattern**: DTO creation for testing
- **Strategy Pattern**: Error code to HTTP status mapping

### Performance Considerations
- Efficient JSON serialization/deserialization
- Optimized request validation
- Minimal object creation in controller methods
- Response compression for large payloads

### Security Considerations
- Input validation prevents malicious data
- Path parameter validation prevents injection attacks
- Comprehensive error handling prevents information leakage
- Request logging for security auditing