# US-003: Validation Chain Implementation

## Story Overview
**As a** system administrator
**I want** comprehensive validation to ensure data integrity and security
**So that** only valid, authorized requests can modify question data with fail-fast error reporting

## Business Value
- Prevents unauthorized access to question banks
- Ensures taxonomy reference integrity
- Provides clear, fast failure feedback
- Maintains data consistency across operations

## Work Breakdown Structure (WBS)

### 1. Validation Chain Infrastructure Setup
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: US-000 ValidationHandler complete

#### Tasks:
- [ ] **1.1** Extend ValidationHandler from shared module
- [ ] **1.2** Create UpsertQuestionCommand class
- [ ] **1.3** Define validation error codes enumeration
- [ ] **1.4** Implement fail-fast behavior
- [ ] **1.5** Add logging and debugging support

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/commands/UpsertQuestionCommand.java
public class UpsertQuestionCommand implements ICommand<QuestionResponseDto> {
    private final Long userId;
    private final Long questionBankId;
    private final String sourceQuestionId;
    private final QuestionType questionType;
    private final String title;
    private final String content;
    private final TaxonomyData taxonomy;
    // ... other fields

    public UpsertQuestionCommand(Long userId, Long questionBankId, UpsertQuestionRequestDto request) {
        this.userId = userId;
        this.questionBankId = questionBankId;
        this.sourceQuestionId = request.getSourceQuestionId();
        this.questionType = QuestionType.valueOf(request.getQuestionType().toUpperCase());
        this.title = request.getTitle();
        this.content = request.getContent();
        this.taxonomy = request.getTaxonomy();
    }

    public List<String> extractTaxonomyIds() {
        var ids = new ArrayList<String>();

        // Extract category IDs
        if (taxonomy.getCategories().getLevel1() != null) {
            ids.add(taxonomy.getCategories().getLevel1().getId());
        }
        // ... other levels

        // Extract tag IDs
        taxonomy.getTags().forEach(tag -> ids.add(tag.getId()));

        // Extract quiz IDs
        taxonomy.getQuizzes().forEach(quiz -> ids.add(quiz.getQuizId().toString()));

        // Extract difficulty level
        ids.add(taxonomy.getDifficultyLevel().getLevel());

        return ids;
    }
}

// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/validation/ValidationErrorCode.java
public enum ValidationErrorCode {
    UNAUTHORIZED_ACCESS("User doesn't own the question bank"),
    TAXONOMY_REFERENCE_NOT_FOUND("Taxonomy reference not found"),
    MISSING_REQUIRED_FIELD("Required field is missing"),
    TYPE_DATA_MISMATCH("Question type doesn't match provided data"),
    INVALID_QUESTION_TYPE("Invalid question type"),
    DUPLICATE_SOURCE_QUESTION_ID("Source question ID already exists");

    private final String message;

    ValidationErrorCode(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}
```

#### Acceptance Criteria:
- UpsertQuestionCommand contains all required data
- Validation error codes properly defined
- Fail-fast behavior configured
- Logging framework integrated

#### TDD Cycle and Verification Approach:

**Red Phase (Write Failing Tests First):**
```java
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ValidationChainInfrastructureTest {

    @Test
    @DisplayName("Should create UpsertQuestionCommand from valid request")
    void shouldCreateUpsertQuestionCommandFromValidRequest() {
        // Test will fail initially - command doesn't exist
        var request = UpsertQuestionRequestDto.builder()
            .sourceQuestionId("Q123")
            .questionType("MCQ")
            .title("Sample MCQ Question")
            .content("What is 2+2?")
            .taxonomy(createValidTaxonomy())
            .build();

        var command = new UpsertQuestionCommand(1001L, 2002L, request);

        assertThat(command.getUserId()).isEqualTo(1001L);
        assertThat(command.getQuestionBankId()).isEqualTo(2002L);
        assertThat(command.getSourceQuestionId()).isEqualTo("Q123");
        assertThat(command.getQuestionType()).isEqualTo(QuestionType.MCQ);
        assertThat(command.getTitle()).isEqualTo("Sample MCQ Question");
    }

    @Test
    @DisplayName("Should extract all taxonomy IDs correctly")
    void shouldExtractAllTaxonomyIdsCorrectly() {
        var request = createRequestWithCompleteTaxonomy();
        var command = new UpsertQuestionCommand(1001L, 2002L, request);

        var taxonomyIds = command.extractTaxonomyIds();

        assertThat(taxonomyIds).contains(
            "cat-level-1-id", "cat-level-2-id",
            "tag-1-id", "tag-2-id",
            "quiz-1", "quiz-2",
            "intermediate"
        );
        assertThat(taxonomyIds).hasSize(7);
    }

    @ParameterizedTest
    @EnumSource(ValidationErrorCode.class)
    @DisplayName("Should have proper error messages for all error codes")
    void shouldHaveProperErrorMessagesForAllErrorCodes(ValidationErrorCode errorCode) {
        assertThat(errorCode.getMessage()).isNotBlank();
        assertThat(errorCode.getMessage().length()).isGreaterThan(10);
    }

    @Test
    @DisplayName("Should handle malformed request gracefully")
    void shouldHandleMalformedRequestGracefully() {
        var invalidRequest = UpsertQuestionRequestDto.builder()
            .sourceQuestionId("")  // Invalid empty ID
            .questionType("INVALID_TYPE")
            .build();

        assertThatThrownBy(() ->
            new UpsertQuestionCommand(1001L, 2002L, invalidRequest)
        ).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    @DisplayName("Should validate command immutability")
    void shouldValidateCommandImmutability() {
        var originalTaxonomy = createValidTaxonomy();
        var request = UpsertQuestionRequestDto.builder()
            .taxonomy(originalTaxonomy)
            .build();

        var command = new UpsertQuestionCommand(1001L, 2002L, request);

        // Attempt to modify original taxonomy
        originalTaxonomy.getTags().clear();

        // Command should be unaffected
        assertThat(command.getTaxonomy().getTags()).isNotEmpty();
    }
}
```

**Green Phase (Minimal Implementation):**
- Implement basic UpsertQuestionCommand with defensive copying
- Add taxonomy ID extraction logic
- Create validation error codes with messages

**Refactor Phase:**
- Optimize object creation and copying
- Add comprehensive validation
- Improve error message clarity

**Verification Criteria:**
- [ ] All command tests pass (100% coverage)
- [ ] Immutability verified through mutation testing
- [ ] Taxonomy extraction handles all edge cases
- [ ] Performance: Command creation <100Âµs

---

### 2. Question Bank Ownership Validator
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: Task 1, Supporting repositories interface

#### Tasks:
- [ ] **2.1** Implement QuestionBankOwnershipValidator class
- [ ] **2.2** Inject QuestionBanksPerUserRepository using constructor injection
- [ ] **2.3** Implement ownership validation logic
- [ ] **2.4** Handle validation errors with specific error codes
- [ ] **2.5** Add comprehensive logging for debugging
- [ ] **2.6** Implement performance optimization for ownership checks

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/QuestionBankOwnershipValidator.java
@Component
public class QuestionBankOwnershipValidator extends ValidationHandler {

    private static final Logger logger = LoggerFactory.getLogger(QuestionBankOwnershipValidator.class);
    private final QuestionBanksPerUserRepository questionBanksPerUserRepository;

    public QuestionBankOwnershipValidator(QuestionBanksPerUserRepository questionBanksPerUserRepository) {
        this.questionBanksPerUserRepository = questionBanksPerUserRepository;
    }

    @Override
    public Result<Void> validate(Object command) {
        if (!(command instanceof UpsertQuestionCommand)) {
            return checkNext(command);
        }

        var upsertCommand = (UpsertQuestionCommand) command;

        logger.debug("Validating question bank ownership for user {} and question bank {}",
                    upsertCommand.getUserId(), upsertCommand.getQuestionBankId());

        boolean ownsQuestionBank = questionBanksPerUserRepository.validateOwnership(
            upsertCommand.getUserId(),
            upsertCommand.getQuestionBankId()
        );

        if (!ownsQuestionBank) {
            logger.warn("Unauthorized access attempt: User {} does not own question bank {}",
                       upsertCommand.getUserId(), upsertCommand.getQuestionBankId());

            return Result.failure(
                ValidationErrorCode.UNAUTHORIZED_ACCESS.name(),
                String.format("User %d doesn't own question bank %d",
                            upsertCommand.getUserId(), upsertCommand.getQuestionBankId())
            );
        }

        logger.debug("Question bank ownership validation passed for user {} and question bank {}",
                    upsertCommand.getUserId(), upsertCommand.getQuestionBankId());

        return checkNext(command);
    }
}
```

#### Acceptance Criteria:
- Constructor injection used for repository dependency
- Ownership validation checks user-question bank relationship
- UNAUTHORIZED_ACCESS error returned with detailed message
- Comprehensive logging for security auditing
- Performance optimized for common cases

#### TDD Cycle and Verification Approach:

**Red Phase (Write Failing Tests First):**
```java
@ExtendWith(MockitoExtension.class)
class QuestionBankOwnershipValidatorTest {

    @Mock
    private QuestionBanksPerUserRepository repository;

    private QuestionBankOwnershipValidator validator;
    private UpsertQuestionCommand validCommand;

    @BeforeEach
    void setUp() {
        validator = new QuestionBankOwnershipValidator(repository);
        validCommand = new UpsertQuestionCommand(
            1001L, 2002L, createValidRequest()
        );
    }

    @Test
    @DisplayName("Should pass validation when user owns question bank")
    void shouldPassValidationWhenUserOwnsQuestionBank() {
        // Test will fail initially - validator doesn't exist yet
        when(repository.validateOwnership(1001L, 2002L))
            .thenReturn(Result.success(true));

        var result = validator.validate(validCommand);

        assertThat(result.isSuccess()).isTrue();
        verify(repository).validateOwnership(1001L, 2002L);
    }

    @Test
    @DisplayName("Should fail validation when user doesn't own question bank")
    void shouldFailValidationWhenUserDoesntOwnQuestionBank() {
        when(repository.validateOwnership(1001L, 2002L))
            .thenReturn(Result.success(false));

        var result = validator.validate(validCommand);

        assertThat(result.isFailure()).isTrue();
        assertThat(result.getErrorCode()).isEqualTo("UNAUTHORIZED_ACCESS");
        assertThat(result.getError()).contains("User 1001 doesn't own question bank 2002");
        verify(repository).validateOwnership(1001L, 2002L);
    }

    @Test
    @DisplayName("Should handle repository failure gracefully")
    void shouldHandleRepositoryFailureGracefully() {
        when(repository.validateOwnership(1001L, 2002L))
            .thenReturn(Result.failure("DATABASE_ERROR", "Connection failed"));

        var result = validator.validate(validCommand);

        assertThat(result.isFailure()).isTrue();
        assertThat(result.getErrorCode()).isEqualTo("DATABASE_ERROR");
        assertThat(result.getError()).isEqualTo("Connection failed");
    }

    @Test
    @DisplayName("Should skip validation for non-UpsertQuestionCommand")
    void shouldSkipValidationForNonUpsertQuestionCommand() {
        var otherCommand = new Object();

        var result = validator.validate(otherCommand);

        assertThat(result.isSuccess()).isTrue();
        verifyNoInteractions(repository);
    }

    @Test
    @DisplayName("Should log validation attempts for security auditing")
    void shouldLogValidationAttemptsForSecurityAuditing() {
        when(repository.validateOwnership(1001L, 2002L))
            .thenReturn(Result.success(true));

        var appender = LogbackTestUtils.getListAppender(QuestionBankOwnershipValidator.class);

        validator.validate(validCommand);

        assertThat(appender.list).hasSize(2);
        assertThat(appender.list.get(0).getFormattedMessage())
            .contains("Validating question bank ownership for user 1001 and question bank 2002");
        assertThat(appender.list.get(1).getFormattedMessage())
            .contains("Question bank ownership validation passed");
    }

    @Test
    @DisplayName("Should handle edge cases and boundary conditions")
    void shouldHandleEdgeCasesAndBoundaryConditions() {
        // Test with max long values
        var extremeCommand = new UpsertQuestionCommand(
            Long.MAX_VALUE, Long.MAX_VALUE, createValidRequest()
        );

        when(repository.validateOwnership(Long.MAX_VALUE, Long.MAX_VALUE))
            .thenReturn(Result.success(true));

        var result = validator.validate(extremeCommand);

        assertThat(result.isSuccess()).isTrue();
        verify(repository).validateOwnership(Long.MAX_VALUE, Long.MAX_VALUE);
    }

    @Test
    @DisplayName("Should maintain performance under load")
    void shouldMaintainPerformanceUnderLoad() throws InterruptedException {
        when(repository.validateOwnership(anyLong(), anyLong()))
            .thenReturn(Result.success(true));

        var results = new ConcurrentLinkedQueue<Boolean>();
        var executor = Executors.newFixedThreadPool(10);
        var latch = new CountDownLatch(100);

        var startTime = Instant.now();

        for (int i = 0; i < 100; i++) {
            executor.submit(() -> {
                try {
                    var result = validator.validate(validCommand);
                    results.add(result.isSuccess());
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await(5, TimeUnit.SECONDS);
        var duration = Duration.between(startTime, Instant.now());

        assertThat(results).hasSize(100);
        assertThat(results.stream().allMatch(success -> success)).isTrue();
        assertThat(duration.toMillis()).isLessThan(1000); // Should complete within 1 second
    }

    private UpsertQuestionRequestDto createValidRequest() {
        return UpsertQuestionRequestDto.builder()
            .sourceQuestionId("Q123")
            .questionType("MCQ")
            .title("Test Question")
            .content("Test Content")
            .taxonomy(createValidTaxonomy())
            .build();
    }
}
```

**Green Phase (Minimal Implementation):**
- Implement basic QuestionBankOwnershipValidator with constructor injection
- Add repository interaction for ownership validation
- Implement basic error handling and logging
- Ensure proper Result pattern usage

**Refactor Phase:**
- Optimize repository call patterns
- Add comprehensive error handling
- Improve logging for security auditing
- Add performance optimizations

**Verification Criteria:**
- [ ] All ownership validation tests pass (100% coverage)
- [ ] Repository interactions properly mocked and verified
- [ ] Security logging captures all validation attempts
- [ ] Performance <10ms per validation call
- [ ] Error messages provide clear feedback
- [ ] Thread safety verified under concurrent load

---

### 3. Taxonomy Reference Validator
**Estimated Effort**: 1.5 days
**Priority**: High
**Dependencies**: Task 2, TaxonomySetRepository interface

#### Tasks:
- [ ] **3.1** Implement TaxonomyReferenceValidator class
- [ ] **3.2** Inject TaxonomySetRepository using constructor injection
- [ ] **3.3** Implement taxonomy ID extraction and validation
- [ ] **3.4** Handle complex taxonomy structure validation
- [ ] **3.5** Provide specific error messages for missing references
- [ ] **3.6** Optimize validation for large taxonomy sets

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/TaxonomyReferenceValidator.java
@Component
public class TaxonomyReferenceValidator extends ValidationHandler {

    private static final Logger logger = LoggerFactory.getLogger(TaxonomyReferenceValidator.class);
    private final TaxonomySetRepository taxonomySetRepository;

    public TaxonomyReferenceValidator(TaxonomySetRepository taxonomySetRepository) {
        this.taxonomySetRepository = taxonomySetRepository;
    }

    @Override
    public Result<Void> validate(Object command) {
        if (!(command instanceof UpsertQuestionCommand)) {
            return checkNext(command);
        }

        var upsertCommand = (UpsertQuestionCommand) command;

        logger.debug("Validating taxonomy references for user {} and question bank {}",
                    upsertCommand.getUserId(), upsertCommand.getQuestionBankId());

        // Extract all taxonomy IDs from the command
        List<String> taxonomyIds = upsertCommand.extractTaxonomyIds();

        if (taxonomyIds.isEmpty()) {
            logger.warn("No taxonomy references found in command for question {}",
                       upsertCommand.getSourceQuestionId());
            return Result.failure(
                ValidationErrorCode.MISSING_REQUIRED_FIELD.name(),
                "At least one taxonomy reference is required"
            );
        }

        // Validate all taxonomy references exist
        boolean allReferencesValid = taxonomySetRepository.validateTaxonomyReferences(
            upsertCommand.getUserId(),
            upsertCommand.getQuestionBankId(),
            taxonomyIds
        );

        if (!allReferencesValid) {
            // Find specific invalid references for detailed error message
            var invalidReferences = findInvalidReferences(
                upsertCommand.getUserId(),
                upsertCommand.getQuestionBankId(),
                taxonomyIds
            );

            logger.warn("Invalid taxonomy references found: {} for user {} and question bank {}",
                       invalidReferences, upsertCommand.getUserId(), upsertCommand.getQuestionBankId());

            return Result.failure(
                ValidationErrorCode.TAXONOMY_REFERENCE_NOT_FOUND.name(),
                String.format("Invalid taxonomy references found: %s", String.join(", ", invalidReferences))
            );
        }

        logger.debug("Taxonomy reference validation passed for user {} and question bank {}",
                    upsertCommand.getUserId(), upsertCommand.getQuestionBankId());

        return checkNext(command);
    }

    private List<String> findInvalidReferences(Long userId, Long questionBankId, List<String> taxonomyIds) {
        return taxonomyIds.stream()
            .filter(id -> !taxonomySetRepository.validateTaxonomyReference(userId, questionBankId, id))
            .collect(Collectors.toList());
    }
}
```

#### Acceptance Criteria:
- All taxonomy references validated against user's taxonomy set
- Specific invalid references identified in error messages
- Performance optimized for bulk validation
- Comprehensive logging for debugging
- TAXONOMY_REFERENCE_NOT_FOUND error with details

#### Test Requirements:
- [ ] Unit test: valid taxonomy references pass validation
- [ ] Unit test: invalid taxonomy references fail with specific errors
- [ ] Unit test: empty taxonomy list validation
- [ ] Unit test: mixed valid/invalid references handling
- [ ] Integration test: with actual taxonomy data

---

### 4. Question Data Integrity Validator
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: Task 3 complete

#### Tasks:
- [ ] **4.1** Implement QuestionDataIntegrityValidator class
- [ ] **4.2** Add required field validation
- [ ] **4.3** Implement type-specific data validation
- [ ] **4.4** Add business rule validation
- [ ] **4.5** Handle edge cases and boundary conditions
- [ ] **4.6** Optimize validation performance

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/QuestionDataIntegrityValidator.java
@Component
public class QuestionDataIntegrityValidator extends ValidationHandler {

    private static final Logger logger = LoggerFactory.getLogger(QuestionDataIntegrityValidator.class);

    @Override
    public Result<Void> validate(Object command) {
        if (!(command instanceof UpsertQuestionCommand)) {
            return checkNext(command);
        }

        var upsertCommand = (UpsertQuestionCommand) command;

        logger.debug("Validating question data integrity for question {}",
                    upsertCommand.getSourceQuestionId());

        // Validate required fields
        var requiredFieldResult = validateRequiredFields(upsertCommand);
        if (requiredFieldResult.isFailure()) {
            return requiredFieldResult;
        }

        // Validate type-specific data
        var typeDataResult = validateTypeSpecificData(upsertCommand);
        if (typeDataResult.isFailure()) {
            return typeDataResult;
        }

        // Validate business rules
        var businessRuleResult = validateBusinessRules(upsertCommand);
        if (businessRuleResult.isFailure()) {
            return businessRuleResult;
        }

        logger.debug("Question data integrity validation passed for question {}",
                    upsertCommand.getSourceQuestionId());

        return checkNext(command);
    }

    private Result<Void> validateRequiredFields(UpsertQuestionCommand command) {
        if (command.getSourceQuestionId() == null || command.getSourceQuestionId().trim().isEmpty()) {
            return Result.failure(ValidationErrorCode.MISSING_REQUIRED_FIELD.name(),
                                 "source_question_id is required");
        }

        if (command.getQuestionType() == null) {
            return Result.failure(ValidationErrorCode.MISSING_REQUIRED_FIELD.name(),
                                 "question_type is required");
        }

        if (command.getTitle() == null || command.getTitle().trim().isEmpty()) {
            return Result.failure(ValidationErrorCode.MISSING_REQUIRED_FIELD.name(),
                                 "title is required");
        }

        if (command.getContent() == null || command.getContent().trim().isEmpty()) {
            return Result.failure(ValidationErrorCode.MISSING_REQUIRED_FIELD.name(),
                                 "content is required");
        }

        return Result.success(null);
    }

    private Result<Void> validateTypeSpecificData(UpsertQuestionCommand command) {
        switch (command.getQuestionType()) {
            case MCQ:
                if (command.getMcqData() == null) {
                    return Result.failure(ValidationErrorCode.TYPE_DATA_MISMATCH.name(),
                                         "mcq_data is required for MCQ questions");
                }
                return validateMcqData(command.getMcqData());

            case ESSAY:
                if (command.getEssayData() == null) {
                    return Result.failure(ValidationErrorCode.TYPE_DATA_MISMATCH.name(),
                                         "essay_data is required for essay questions");
                }
                return validateEssayData(command.getEssayData());

            case TRUE_FALSE:
                if (command.getTrueFalseData() == null) {
                    return Result.failure(ValidationErrorCode.TYPE_DATA_MISMATCH.name(),
                                         "true_false_data is required for true/false questions");
                }
                return validateTrueFalseData(command.getTrueFalseData());

            default:
                return Result.failure(ValidationErrorCode.INVALID_QUESTION_TYPE.name(),
                                     "Unsupported question type: " + command.getQuestionType());
        }
    }

    private Result<Void> validateMcqData(McqData mcqData) {
        if (mcqData.getOptions() == null || mcqData.getOptions().isEmpty()) {
            return Result.failure(ValidationErrorCode.TYPE_DATA_MISMATCH.name(),
                                 "MCQ questions must have at least one option");
        }

        boolean hasCorrectAnswer = mcqData.getOptions().stream()
            .anyMatch(option -> option.isCorrect());

        if (!hasCorrectAnswer) {
            return Result.failure(ValidationErrorCode.TYPE_DATA_MISMATCH.name(),
                                 "MCQ questions must have at least one correct answer");
        }

        return Result.success(null);
    }

    private Result<Void> validateEssayData(EssayData essayData) {
        if (essayData.getPrompt() == null || essayData.getPrompt().trim().isEmpty()) {
            return Result.failure(ValidationErrorCode.TYPE_DATA_MISMATCH.name(),
                                 "Essay questions must have a prompt");
        }

        return Result.success(null);
    }

    private Result<Void> validateTrueFalseData(TrueFalseData trueFalseData) {
        if (trueFalseData.getStatement() == null || trueFalseData.getStatement().trim().isEmpty()) {
            return Result.failure(ValidationErrorCode.TYPE_DATA_MISMATCH.name(),
                                 "True/False questions must have a statement");
        }

        return Result.success(null);
    }

    private Result<Void> validateBusinessRules(UpsertQuestionCommand command) {
        // Add business-specific validation rules here
        if (command.getPoints() != null && command.getPoints() < 0) {
            return Result.failure(ValidationErrorCode.MISSING_REQUIRED_FIELD.name(),
                                 "Points cannot be negative");
        }

        return Result.success(null);
    }
}
```

#### Acceptance Criteria:
- All required fields validated
- Type-specific data validation for MCQ, Essay, True/False
- Business rules enforced
- Specific error codes and messages
- Performance optimized for common cases

#### Test Requirements:
- [ ] Unit test: required field validation for all fields
- [ ] Unit test: MCQ data validation scenarios
- [ ] Unit test: Essay data validation scenarios
- [ ] Unit test: True/False data validation scenarios
- [ ] Unit test: business rule validation
- [ ] Unit test: error code accuracy

---

### 5. Validation Chain Configuration
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Tasks 2, 3, 4 complete

#### Tasks:
- [ ] **5.1** Create ValidationChainConfig Spring configuration
- [ ] **5.2** Configure validation chain order
- [ ] **5.3** Set up Spring dependency injection
- [ ] **5.4** Add chain debugging and monitoring
- [ ] **5.5** Implement chain performance optimization

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/infrastructure/configuration/ValidationChainConfig.java
@Configuration
public class ValidationChainConfig {

    @Bean
    @Primary
    public ValidationHandler validationChain(
        QuestionBankOwnershipValidator ownershipValidator,
        TaxonomyReferenceValidator taxonomyValidator,
        QuestionDataIntegrityValidator dataValidator) {

        // Chain order: Ownership -> Taxonomy -> Data Integrity
        ownershipValidator
            .setNext(taxonomyValidator)
            .setNext(dataValidator);

        return ownershipValidator;
    }

    @Bean
    public ValidationChainMetrics validationChainMetrics() {
        return new ValidationChainMetrics();
    }
}

// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/infrastructure/monitoring/ValidationChainMetrics.java
@Component
public class ValidationChainMetrics {

    private final MeterRegistry meterRegistry;
    private final Counter validationSuccessCounter;
    private final Counter validationFailureCounter;
    private final Timer validationTimer;

    public ValidationChainMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.validationSuccessCounter = Counter.builder("validation.success")
            .description("Number of successful validations")
            .register(meterRegistry);
        this.validationFailureCounter = Counter.builder("validation.failure")
            .description("Number of failed validations")
            .tag("error_code", "unknown")
            .register(meterRegistry);
        this.validationTimer = Timer.builder("validation.duration")
            .description("Validation execution time")
            .register(meterRegistry);
    }

    public void recordSuccess() {
        validationSuccessCounter.increment();
    }

    public void recordFailure(String errorCode) {
        Counter.builder("validation.failure")
            .tag("error_code", errorCode)
            .register(meterRegistry)
            .increment();
    }

    public Timer.Sample startTimer() {
        return Timer.start(meterRegistry);
    }
}
```

#### Acceptance Criteria:
- Validation chain configured in correct order
- Spring dependency injection working
- Performance monitoring enabled
- Configuration testable and maintainable

#### Test Requirements:
- [ ] Integration test: complete validation chain execution
- [ ] Integration test: Spring configuration loading
- [ ] Unit test: chain order verification
- [ ] Performance test: validation chain timing

---

## Acceptance Criteria Summary

### Functional Requirements
- [ ] Validation chain executes in correct order: Ownership -> Taxonomy -> Data Integrity
- [ ] Fail-fast behavior stops at first validation failure
- [ ] All validation scenarios return appropriate error codes
- [ ] Constructor injection used for all repository dependencies
- [ ] Comprehensive logging for debugging and auditing

### Non-Functional Requirements
- [ ] Validation chain execution time <100ms for typical requests
- [ ] Memory usage <10MB for validation operations
- [ ] Thread-safe validator implementations
- [ ] Code coverage >95% for validation logic

### Definition of Done
- [ ] All three validators implemented and tested
- [ ] Spring configuration enables proper dependency injection
- [ ] Integration tests verify complete validation chain
- [ ] Performance monitoring and metrics enabled
- [ ] Code review completed
- [ ] Documentation updated with validation rules

## Dependencies and Risks

### Dependencies
- US-000 ValidationHandler base class
- Repository interfaces for ownership and taxonomy validation
- UpsertQuestionCommand class design
- Spring configuration understanding

### Risks
- **Risk**: Performance impact of chain validation
  **Mitigation**: Optimize common validation paths and add performance monitoring

- **Risk**: Complex taxonomy validation logic
  **Mitigation**: Break down into smaller, testable methods

- **Risk**: Error message consistency
  **Mitigation**: Centralized error code management and standardized message format

## Testing Strategy

### Unit Testing
- Individual validator logic with mocked dependencies
- Error scenario coverage for all validation rules
- Chain behavior testing with different failure points

### Integration Testing
- Complete validation chain with real repository implementations
- Spring configuration loading and dependency injection
- Performance testing under various load conditions

### Test Data Requirements
- Valid and invalid question bank ownership scenarios
- Valid and invalid taxonomy reference data
- Edge cases for required field validation
- Type-specific data validation scenarios

## Technical Notes

### Design Patterns Used
- **Chain of Responsibility**: Core validation pattern
- **Strategy Pattern**: Type-specific validation methods
- **Dependency Injection**: Spring-managed validator dependencies

### Performance Considerations
- Early validation exit on first failure
- Optimized repository queries for ownership/taxonomy checks
- Minimal object creation during validation

### Security Considerations
- Comprehensive authorization checking
- Input validation and sanitization
- Audit logging for security events