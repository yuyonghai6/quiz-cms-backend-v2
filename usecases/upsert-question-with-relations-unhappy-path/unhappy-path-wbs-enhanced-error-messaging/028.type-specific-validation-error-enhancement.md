# US-028: Type-Specific Validation Error Enhancement

## User Story
**As a** API consumer developing quiz creation interfaces
**I want** detailed, type-specific validation error messages for question creation failures
**So that** users can quickly identify and correct specific issues with their question data

## Epic
Enhanced Error Messaging

## Story
Enhance existing US-004 QuestionTypeValidationStrategy with detailed error messages and field-level validation feedback

## Acceptance Criteria

### Type-Specific Error Messages
- [ ] **AC-028.1**: Multiple-choice questions must provide specific validation errors for options, correct answers, and distractors
- [ ] **AC-028.2**: True/false questions must provide clear guidance when answer format is incorrect
- [ ] **AC-028.3**: Short-answer questions must specify validation requirements for acceptable answer patterns
- [ ] **AC-028.4**: Essay questions must detail word count, formatting, and rubric-related validation errors

### Enhanced Validation Detail
- [ ] **AC-028.5**: Field-level validation must identify specific invalid fields with context
- [ ] **AC-028.6**: Error messages must include suggested corrections where applicable
- [ ] **AC-028.7**: Validation errors must integrate with existing US-004 QuestionTypeValidationStrategy pattern
- [ ] **AC-028.8**: Error response must maintain existing Result<T> pattern from US-003 ValidationHandler

### Error Message Structure
- [ ] **AC-028.9**: Error messages must follow consistent structure across all question types
- [ ] **AC-028.10**: Error responses must include field path for nested validation failures
- [ ] **AC-028.11**: Multiple validation errors must be aggregated in single response
- [ ] **AC-028.12**: Error severity levels must be indicated (WARNING vs ERROR)

## Test-Driven Development Cycle

### Epic and Story Annotations for Tests
- **@Epic**: `"Enhanced Error Messaging"`
- **@Story**: `"028.type-specific-validation-error-enhancement"`

### Red-Green-Refactor Cycle

#### Phase 1: RED - Write Failing Tests for Multiple Choice Validation
**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/validation/EnhancedMultipleChoiceValidationStrategyTest.java`

```java
@SpringBootTest
@ActiveProfiles("test")
@ExtendWith(AllureExtension.class)
@TestMethodOrder(OrderAnnotation.class)
class EnhancedMultipleChoiceValidationStrategyTest {

    @Container
    static MongoDBContainer mongoDBContainer = new MongoDBContainer(DockerImageName.parse("mongo:6.0"))
            .withReuse(true);

    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoDBContainer::getReplicaSetUrl);
    }

    @Autowired
    private EnhancedMultipleChoiceValidationStrategy validationStrategy;

    @Test
    @Order(1)
    @Epic("Enhanced Error Messaging")
    @Story("028.type-specific-validation-error-enhancement")
    @DisplayName("Should provide detailed error for insufficient MCQ options")
    @Description("Validates that MCQ with fewer than 2 options gets specific error message with suggestions")
    void shouldProvideDetailedErrorForInsufficientOptions() {
        // RED: This test should fail initially
        var mcQuestion = MultipleChoiceQuestion.builder()
            .questionText("What is JavaScript?")
            .options(List.of("A programming language"))  // Only 1 option
            .correctAnswerIndices(List.of(0))
            .build();

        var result = validationStrategy.validate(mcQuestion);

        assertThat(result.isFailure()).isTrue();
        assertThat(result.getErrorCode()).isEqualTo(ValidationErrorCode.QUESTION_TYPE_VALIDATION_FAILED);

        var errorDetails = result.getDetailedErrorResponse();
        assertThat(errorDetails.getFieldErrors()).hasSize(1);
        assertThat(errorDetails.getFieldErrors().get(0).getFieldPath()).isEqualTo("options");
        assertThat(errorDetails.getFieldErrors().get(0).getMessage())
            .contains("Multiple-choice questions require at least 2 answer options");
        assertThat(errorDetails.getFieldErrors().get(0).getSuggestion())
            .contains("Add answer options using the 'options' field");
    }

    @Test
    @Order(2)
    @Epic("Enhanced Error Messaging")
    @Story("028.type-specific-validation-error-enhancement")
    @DisplayName("Should provide field-level errors for empty options")
    @Description("Validates that empty options get specific field-level error messages")
    void shouldProvideFieldLevelErrorsForEmptyOptions() {
        // RED: This test should fail initially
        var mcQuestion = MultipleChoiceQuestion.builder()
            .questionText("What is JavaScript?")
            .options(List.of("A programming language", "", "A markup language"))  // Empty option at index 1
            .correctAnswerIndices(List.of(0))
            .build();

        var result = validationStrategy.validate(mcQuestion);

        assertThat(result.isFailure()).isTrue();

        var errorDetails = result.getDetailedErrorResponse();
        var optionError = errorDetails.getFieldErrors().stream()
            .filter(error -> error.getFieldPath().equals("options[1]"))
            .findFirst()
            .orElseThrow();

        assertThat(optionError.getMessage()).contains("Option 2 cannot be empty");
        assertThat(optionError.getSuggestion()).contains("Provide text content for each answer option");
    }

    @Test
    @Order(3)
    @Epic("Enhanced Error Messaging")
    @Story("028.type-specific-validation-error-enhancement")
    @DisplayName("Should provide multiple aggregated errors in single response")
    @Description("Validates that multiple validation failures are collected and returned together")
    void shouldProvideMultipleAggregatedErrors() {
        // RED: This test should fail initially
        var mcQuestion = MultipleChoiceQuestion.builder()
            .questionText("What is JavaScript?")
            .options(List.of(""))  // Empty option AND insufficient options
            .correctAnswerIndices(List.of())  // AND no correct answers
            .build();

        var result = validationStrategy.validate(mcQuestion);

        assertThat(result.isFailure()).isTrue();

        var errorDetails = result.getDetailedErrorResponse();
        assertThat(errorDetails.getFieldErrors()).hasSizeGreaterThan(2);

        // Should contain errors for: insufficient options, empty option, missing correct answers
        var fieldPaths = errorDetails.getFieldErrors().stream()
            .map(DetailedValidationError::getFieldPath)
            .collect(Collectors.toList());

        assertThat(fieldPaths).contains("options", "options[0]", "correctAnswers");
    }
}
```

#### Phase 2: GREEN - Implement Enhanced Validation Strategy
**File**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/enhanced/EnhancedMultipleChoiceValidationStrategy.java`

```java
@Component
public class EnhancedMultipleChoiceValidationStrategy extends EnhancedQuestionTypeValidationStrategy {

    @Override
    public Result<Void> validate(Question question) {
        if (!(question instanceof MultipleChoiceQuestion)) {
            return Result.failure("Invalid question type for MCQ validation",
                                ValidationErrorCode.QUESTION_TYPE_MISMATCH);
        }

        var mcQuestion = (MultipleChoiceQuestion) question;
        var errors = new ValidationErrorCollection();

        // Perform all validations and collect errors
        validateQuestionText(mcQuestion, errors);
        validateTypeSpecificContent(mcQuestion, errors);
        validateAnswerConfiguration(mcQuestion, errors);

        if (errors.hasErrors()) {
            return Result.failure(
                buildDetailedErrorMessage(errors),
                ValidationErrorCode.QUESTION_TYPE_VALIDATION_FAILED,
                createDetailedErrorResponse(errors)
            );
        }

        return Result.success(null);
    }

    @Override
    protected void validateTypeSpecificContent(Question question, ValidationErrorCollection errors) {
        var mcQuestion = (MultipleChoiceQuestion) question;

        // 1. Options validation
        if (mcQuestion.getOptions() == null || mcQuestion.getOptions().isEmpty()) {
            errors.addError(
                "options",
                "Multiple-choice questions require at least 2 answer options",
                ValidationSeverity.ERROR,
                "Add answer options using the 'options' field"
            );
        } else if (mcQuestion.getOptions().size() < 2) {
            errors.addError(
                "options",
                String.format("Multiple-choice questions need at least 2 options, but %d provided",
                            mcQuestion.getOptions().size()),
                ValidationSeverity.ERROR,
                "Add more answer options to create a valid multiple choice question"
            );
        } else {
            validateIndividualOptions(mcQuestion.getOptions(), errors);
            validateOptionUniqueness(mcQuestion.getOptions(), errors);
        }
    }

    @Override
    protected void validateAnswerConfiguration(Question question, ValidationErrorCollection errors) {
        var mcQuestion = (MultipleChoiceQuestion) question;

        // 1. Correct answers validation
        if (mcQuestion.getCorrectAnswerIndices() == null || mcQuestion.getCorrectAnswerIndices().isEmpty()) {
            errors.addError(
                "correctAnswers",
                "Multiple-choice questions must specify at least one correct answer",
                ValidationSeverity.ERROR,
                "Set correct answers using option indices (e.g., [0, 2] for first and third options)"
            );
        } else {
            validateCorrectAnswerIndices(mcQuestion, errors);
        }
    }

    private void validateIndividualOptions(List<String> options, ValidationErrorCollection errors) {
        for (int i = 0; i < options.size(); i++) {
            String option = options.get(i);
            String fieldPath = String.format("options[%d]", i);

            if (option == null || option.trim().isEmpty()) {
                errors.addError(
                    fieldPath,
                    String.format("Option %d cannot be empty", i + 1),
                    ValidationSeverity.ERROR,
                    "Provide text content for each answer option"
                );
            } else if (option.length() > 500) {
                errors.addError(
                    fieldPath,
                    String.format("Option %d exceeds 500 character limit (%d characters)", i + 1, option.length()),
                    ValidationSeverity.ERROR,
                    "Shorten option text to 500 characters or less"
                );
            }
        }
    }
}
```

#### Phase 3: REFACTOR - Enhance Error Collection and Response Building
- Extract common validation patterns to base class methods
- Optimize error message generation performance
- Add internationalization support for error messages
- Implement caching for frequently validated patterns

### Verification Approach for Each Acceptance Criterion

#### AC-028.1 Verification: MCQ-Specific Error Messages
```java
@Test
@Epic("Enhanced Error Messaging")
@Story("028.type-specific-validation-error-enhancement")
@DisplayName("Verify MCQ provides specific validation errors for options, correct answers, and distractors")
void verifyMcqSpecificErrorMessages() {
    // Test option-specific errors (empty, too long, invalid format)
    // Test correct answer errors (missing, invalid indices, conflicting settings)
    // Test distractor errors (insufficient distractors, duplicate distractors)
}
```

#### AC-028.5 Verification: Field-Level Validation
```java
@Test
@Epic("Enhanced Error Messaging")
@Story("028.type-specific-validation-error-enhancement")
@DisplayName("Verify field-level validation identifies specific invalid fields with context")
void verifyFieldLevelValidation() {
    // Create question with multiple field-level issues
    // Verify each error has specific field path
    // Verify context includes field value and constraint information
}
```

#### AC-028.11 Verification: Error Aggregation
```java
@Test
@Epic("Enhanced Error Messaging")
@Story("028.type-specific-validation-error-enhancement")
@DisplayName("Verify multiple validation errors aggregated in single response")
void verifyErrorAggregation() {
    // Create question with multiple validation issues
    // Verify single response contains all errors
    // Verify errors are properly categorized and prioritized
}
```

## Technical Requirements

### Concrete File Locations
- **Enhanced Strategy Base**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/enhanced/EnhancedQuestionTypeValidationStrategy.java`
- **MCQ Implementation**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/enhanced/EnhancedMultipleChoiceValidationStrategy.java`
- **Error Collection**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/validation/error/ValidationErrorCollection.java`
- **Test Suite**: `/home/joyfulday/nus-proj/quiz-cms/internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/validation/EnhancedValidationStrategyTest.java`

### Implementation Order
1. Create `ValidationErrorCollection` and `DetailedValidationError` data structures
2. Create abstract `EnhancedQuestionTypeValidationStrategy` base class
3. Implement `EnhancedMultipleChoiceValidationStrategy` with detailed error collection
4. Create similar enhanced strategies for True/False, Short Answer, and Essay questions
5. Update `QuestionTypeValidationService` to use enhanced strategies
6. Write comprehensive test suite covering all error scenarios

### Maven Commands for TDD Cycle
```bash
# Run specific validation strategy test during RED phase (should fail)
mvn -Dtest=EnhancedMultipleChoiceValidationStrategyTest#shouldProvideDetailedErrorForInsufficientOptions test -pl internal-layer/question-bank

# Run all enhanced validation tests during GREEN phase
mvn -Dtest=EnhancedMultipleChoiceValidationStrategyTest test -pl internal-layer/question-bank

# Run integration tests during REFACTOR phase
mvn test -pl internal-layer/question-bank

# Verify error message quality and performance
mvn verify -pl internal-layer/question-bank
```

## Technical Requirements

### Enhanced Validation Strategy
```java
public abstract class EnhancedQuestionTypeValidationStrategy extends QuestionTypeValidationStrategy {

    protected final ValidationErrorCollector errorCollector;

    public Result<Void> validate(Question question) {
        var errors = new ValidationErrorCollection();

        // 1. Basic type validation (from original US-004)
        var basicValidation = performBasicValidation(question);
        if (!basicValidation.isSuccess()) {
            errors.addAll(basicValidation.getErrors());
        }

        // 2. Enhanced field-level validation
        validateQuestionText(question, errors);
        validateTypeSpecificContent(question, errors);
        validateAnswerConfiguration(question, errors);
        validateScoringRubric(question, errors);

        // 3. Cross-field validation
        performCrossFieldValidation(question, errors);

        if (errors.hasErrors()) {
            return Result.failure(
                buildDetailedErrorMessage(errors),
                ValidationErrorCode.QUESTION_TYPE_VALIDATION_FAILED,
                errors.toErrorDetails()
            );
        }

        return Result.success(null);
    }

    protected abstract void validateTypeSpecificContent(Question question, ValidationErrorCollection errors);
    protected abstract void validateAnswerConfiguration(Question question, ValidationErrorCollection errors);
}
```

### Multiple-Choice Enhanced Validation
```java
@Component
public class EnhancedMultipleChoiceValidationStrategy extends EnhancedQuestionTypeValidationStrategy {

    @Override
    protected void validateTypeSpecificContent(Question question, ValidationErrorCollection errors) {
        var mcQuestion = (MultipleChoiceQuestion) question;

        // 1. Options validation
        if (mcQuestion.getOptions() == null || mcQuestion.getOptions().isEmpty()) {
            errors.addError(
                "options",
                "Multiple-choice questions require at least 2 answer options",
                ValidationSeverity.ERROR,
                "Add answer options using the 'options' field"
            );
        } else {
            validateIndividualOptions(mcQuestion.getOptions(), errors);
            validateOptionUniqueness(mcQuestion.getOptions(), errors);
        }
    }

    @Override
    protected void validateAnswerConfiguration(Question question, ValidationErrorCollection errors) {
        var mcQuestion = (MultipleChoiceQuestion) question;

        // 1. Correct answers validation
        if (mcQuestion.getCorrectAnswers() == null || mcQuestion.getCorrectAnswers().isEmpty()) {
            errors.addError(
                "correctAnswers",
                "Multiple-choice questions must specify at least one correct answer",
                ValidationSeverity.ERROR,
                "Set correct answers using option indices (e.g., [0, 2] for first and third options)"
            );
        } else {
            validateCorrectAnswerIndices(mcQuestion, errors);
            validateAnswerDistribution(mcQuestion, errors);
        }
    }

    private void validateIndividualOptions(List<String> options, ValidationErrorCollection errors) {
        for (int i = 0; i < options.size(); i++) {
            String option = options.get(i);
            String fieldPath = String.format("options[%d]", i);

            if (option == null || option.trim().isEmpty()) {
                errors.addError(
                    fieldPath,
                    String.format("Option %d cannot be empty", i + 1),
                    ValidationSeverity.ERROR,
                    "Provide text content for each answer option"
                );
            } else if (option.length() > 500) {
                errors.addError(
                    fieldPath,
                    String.format("Option %d exceeds 500 character limit (%d characters)", i + 1, option.length()),
                    ValidationSeverity.ERROR,
                    "Shorten option text to 500 characters or less"
                );
            }
        }
    }
}
```

### Validation Error Collection System
```java
public class ValidationErrorCollection {
    private final List<DetailedValidationError> errors = new ArrayList<>();
    private final List<DetailedValidationError> warnings = new ArrayList<>();

    public void addError(String fieldPath, String message, ValidationSeverity severity, String suggestion) {
        var error = DetailedValidationError.builder()
            .fieldPath(fieldPath)
            .message(message)
            .severity(severity)
            .suggestion(suggestion)
            .timestamp(LocalDateTime.now())
            .build();

        if (severity == ValidationSeverity.ERROR) {
            errors.add(error);
        } else {
            warnings.add(error);
        }
    }

    public boolean hasErrors() {
        return !errors.isEmpty();
    }

    public List<ErrorDetail> toErrorDetails() {
        return Stream.concat(errors.stream(), warnings.stream())
            .map(this::toErrorDetail)
            .collect(Collectors.toList());
    }
}

@Value
@Builder
public class DetailedValidationError {
    String fieldPath;
    String message;
    ValidationSeverity severity;
    String suggestion;
    LocalDateTime timestamp;
}
```

### Integration Points
- **US-004**: Enhances existing QuestionTypeValidationStrategy pattern
- **US-003**: Uses ValidationHandler Result<T> pattern and ValidationErrorCode
- **US-007**: Integrates with QuestionApplicationService for coordinated validation

## Business Rules

### Error Message Standards
1. **Clarity**: Error messages must be clear and actionable for API consumers
2. **Specificity**: Messages must identify exact validation failure with field context
3. **Helpful Suggestions**: Include correction guidance where technically feasible
4. **Consistency**: Follow consistent error message format across all question types

### Validation Scope
1. **Field-Level**: Individual field validation with specific error messages
2. **Cross-Field**: Relationships between fields validated with contextual errors
3. **Type-Specific**: Question type business rules validated with detailed feedback
4. **Severity-Based**: Distinguish between blocking errors and advisory warnings

### Error Response Structure
1. **Hierarchical**: Nested field paths for complex object validation
2. **Aggregated**: Multiple errors returned in single response
3. **Actionable**: Each error includes suggested remediation steps
4. **Traceable**: Error context sufficient for debugging and resolution

## Definition of Done

### Enhanced Validation Implementation
- [ ] EnhancedQuestionTypeValidationStrategy base class implemented
- [ ] Type-specific enhanced validation for all question types (multiple-choice, true/false, short-answer, essay)
- [ ] ValidationErrorCollection system for detailed error aggregation
- [ ] Field-level validation with specific error messages and suggestions

### Integration Complete
- [ ] Enhanced validators integrate seamlessly with existing US-004 QuestionTypeValidationStrategy pattern
- [ ] Error responses maintain US-003 Result<T> pattern compatibility
- [ ] US-007 QuestionApplicationService coordinated validation updated
- [ ] All existing validation functionality preserved and enhanced

### Error Message Quality
- [ ] Clear, actionable error messages for all validation scenarios
- [ ] Field path identification for nested object validation failures
- [ ] Suggested corrections provided where technically feasible
- [ ] Consistent error message structure across all question types

### Testing Complete
- [ ] Unit tests covering all enhanced validation scenarios for each question type
- [ ] Integration tests validating error message quality and structure
- [ ] API consumer testing with real-world invalid question data
- [ ] Performance testing ensuring enhanced validation speed requirements

## Dependencies

### Prerequisites
- **US-004**: QuestionTypeValidationStrategy pattern and existing type-specific validators
- **US-003**: ValidationHandler Result<T> pattern and ValidationErrorCode enumeration
- **US-007**: QuestionApplicationService coordination pattern
- **US-005**: Repository layer for validation data queries if needed

### External Dependencies
- JSON schema validation libraries for structured error responses
- Internationalization support for multilingual error messages (future enhancement)

## Risk Mitigation

### Technical Risks
- **Performance Impact**: Optimized validation logic with early termination for critical errors
- **Breaking Changes**: Enhanced errors maintain backward compatibility with existing error codes
- **Complexity Management**: Clear separation of concerns between basic and enhanced validation
- **Memory Usage**: Efficient error collection with bounded error message sizes

### Integration Risks
- **Existing Functionality**: All existing US-004 validation preserved and enhanced
- **API Compatibility**: Enhanced error responses maintain existing Result<T> structure
- **Service Coordination**: Enhanced validation integrates cleanly with US-007 service patterns
- **Error Handling**: Enhanced errors processed correctly by existing error handling infrastructure

## Success Metrics

### Error Message Quality
- API consumer satisfaction score >90% for error message clarity and actionability
- Average time to resolve validation errors reduced by 50%
- Support ticket volume related to validation confusion reduced by 60%
- Error message actionability score >95% based on developer feedback

### System Integration
- All existing validation functionality remains 100% operational
- Enhanced validation processing time <50ms per question
- Error response structure compatibility 100% with existing API consumers
- Zero regression in existing validation behavior

### Developer Experience
- API documentation clarity score >95% for enhanced error messages
- Developer onboarding time for validation understanding reduced by 40%
- Validation error resolution success rate on first attempt >80%
- Question creation success rate after first validation failure >90%