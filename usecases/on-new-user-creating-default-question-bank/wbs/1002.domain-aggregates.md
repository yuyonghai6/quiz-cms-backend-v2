# WBS 1002: Domain Aggregates

## User Story
**As a** domain layer
**I want** factory methods for creating default question bank aggregates
**So that** domain invariants are enforced during default creation

---

## Acceptance Criteria
- [ ] QuestionBanksPerUserAggregate has `createDefault()` factory method
- [ ] TaxonomySetAggregate has `createDefault()` factory method
- [ ] Factory methods validate all business rules
- [ ] Aggregates use existing domain entities (QuestionBank, Tag, etc.)
- [ ] Created aggregates have proper timestamps
- [ ] Domain invariants enforced (active bank, valid hierarchy, etc.)

---

## TDD Cycle

### Epic and Story Annotation
```java
@Epic("Use Case On New User Create Default Question Bank Happy Path")
@Story("1002.domain-aggregates")
```

### Test Coverage Requirements
- **Unit Tests**: 100% coverage for new factory methods
- **Test Count**: 12-15 tests
- **No Integration Tests**: Pure domain logic

---

## Task Breakdown

### Task 2.1: RED - Write Tests for QuestionBanksPerUserAggregate Factory

**File**: `QuestionBanksPerUserAggregateDefaultCreationTest.java`
**Location**: `internal-layer/question-bank/src/test/java/com/quizfun/questionbank/domain/aggregates/`

```java
package com.quizfun.questionbank.domain.aggregates;

import com.quizfun.questionbank.domain.entities.QuestionBank;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.*;

@Epic("Use Case On New User Create Default Question Bank Happy Path")
@Story("1002.domain-aggregates")
@DisplayName("QuestionBanksPerUserAggregate Default Creation Tests")
class QuestionBanksPerUserAggregateDefaultCreationTest {

    @Test
    @DisplayName("Should create default aggregate with valid inputs")
    void shouldCreateDefaultAggregateWithValidInputs() {
        // Given
        Long userId = 123456789L;
        Long questionBankId = 1730832000000000L;
        Instant now = Instant.now();

        // When
        QuestionBanksPerUserAggregate aggregate =
            QuestionBanksPerUserAggregate.createDefault(userId, questionBankId, now);

        // Then
        assertThat(aggregate).isNotNull();
        assertThat(aggregate.getUserId()).isEqualTo(userId);
        assertThat(aggregate.getDefaultQuestionBankId()).isEqualTo(questionBankId);
        assertThat(aggregate.getQuestionBanks()).hasSize(1);
    }

    @Test
    @DisplayName("Should create question bank with correct default values")
    void shouldCreateQuestionBankWithCorrectDefaultValues() {
        // Given
        Long userId = 123L;
        Long questionBankId = 1730832000000000L;
        Instant now = Instant.now();

        // When
        QuestionBanksPerUserAggregate aggregate =
            QuestionBanksPerUserAggregate.createDefault(userId, questionBankId, now);

        // Then
        QuestionBank bank = aggregate.getQuestionBanks().get(0);
        assertThat(bank.getBankId()).isEqualTo(questionBankId);
        assertThat(bank.getName()).isEqualTo("Default Question Bank");
        assertThat(bank.getDescription())
            .isEqualTo("Your default question bank for getting started with quiz creation");
        assertThat(bank.isActive()).isTrue();
        assertThat(bank.getCreatedAt()).isEqualTo(now);
        assertThat(bank.getUpdatedAt()).isEqualTo(now);
    }

    @Test
    @DisplayName("Should set default question bank ID to match created bank ID")
    void shouldSetDefaultQuestionBankIdToMatchCreatedBankId() {
        // Given
        Long userId = 123L;
        Long questionBankId = 1730832000000000L;

        // When
        QuestionBanksPerUserAggregate aggregate =
            QuestionBanksPerUserAggregate.createDefault(userId, questionBankId, Instant.now());

        // Then
        assertThat(aggregate.getDefaultQuestionBankId())
            .isEqualTo(aggregate.getQuestionBanks().get(0).getBankId());
    }

    @Test
    @DisplayName("Should validate ownership after default creation")
    void shouldValidateOwnershipAfterDefaultCreation() {
        // Given
        Long userId = 123L;
        Long questionBankId = 1730832000000000L;

        // When
        QuestionBanksPerUserAggregate aggregate =
            QuestionBanksPerUserAggregate.createDefault(userId, questionBankId, Instant.now());

        // Then
        assertThat(aggregate.validateOwnership(userId, questionBankId)).isTrue();
        assertThat(aggregate.validateOwnership(userId, 999L)).isFalse();
        assertThat(aggregate.validateOwnership(999L, questionBankId)).isFalse();
    }

    @Test
    @DisplayName("Should identify default question bank correctly")
    void shouldIdentifyDefaultQuestionBankCorrectly() {
        // Given
        Long userId = 123L;
        Long questionBankId = 1730832000000000L;

        // When
        QuestionBanksPerUserAggregate aggregate =
            QuestionBanksPerUserAggregate.createDefault(userId, questionBankId, Instant.now());

        // Then
        assertThat(aggregate.isDefaultQuestionBank(questionBankId)).isTrue();
        assertThat(aggregate.isDefaultQuestionBank(999L)).isFalse();
    }

    @Test
    @DisplayName("Should throw exception when userId is null")
    void shouldThrowExceptionWhenUserIdIsNull() {
        // When & Then
        assertThatThrownBy(() ->
            QuestionBanksPerUserAggregate.createDefault(null, 123L, Instant.now()))
            .isInstanceOf(NullPointerException.class)
            .hasMessageContaining("User ID cannot be null");
    }

    @Test
    @DisplayName("Should throw exception when questionBankId is null")
    void shouldThrowExceptionWhenQuestionBankIdIsNull() {
        // When & Then
        assertThatThrownBy(() ->
            QuestionBanksPerUserAggregate.createDefault(123L, null, Instant.now()))
            .isInstanceOf(NullPointerException.class)
            .hasMessageContaining("Question Bank ID cannot be null");
    }

    @Test
    @DisplayName("Should throw exception when timestamp is null")
    void shouldThrowExceptionWhenTimestampIsNull() {
        // When & Then
        assertThatThrownBy(() ->
            QuestionBanksPerUserAggregate.createDefault(123L, 456L, null))
            .isInstanceOf(NullPointerException.class)
            .hasMessageContaining("Timestamp cannot be null");
    }
}
```

**Expected Result**: Tests FAIL (method doesn't exist yet)

---

### Task 2.2: GREEN - Implement QuestionBanksPerUserAggregate Factory

**File**: Modify existing `QuestionBanksPerUserAggregate.java`
**Location**: `internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/aggregates/`

```java
package com.quizfun.questionbank.domain.aggregates;

import com.quizfun.questionbank.domain.entities.QuestionBank;
import com.quizfun.shared.domain.AggregateRoot;
import org.bson.types.ObjectId;

import java.time.Instant;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

public class QuestionBanksPerUserAggregate extends AggregateRoot {
    private ObjectId id;
    private Long userId;
    private Long defaultQuestionBankId;
    private List<QuestionBank> questionBanks;

    // Existing constructor
    private QuestionBanksPerUserAggregate() {
        // Private constructor for frameworks
    }

    // Existing create method
    public static QuestionBanksPerUserAggregate create(
            ObjectId id,
            Long userId,
            Long defaultQuestionBankId,
            List<QuestionBank> questionBanks) {

        QuestionBanksPerUserAggregate aggregate = new QuestionBanksPerUserAggregate();
        aggregate.id = Objects.requireNonNull(id, "ID cannot be null");
        aggregate.userId = Objects.requireNonNull(userId, "User ID cannot be null");
        aggregate.defaultQuestionBankId = Objects.requireNonNull(defaultQuestionBankId, "Default Question Bank ID cannot be null");
        aggregate.questionBanks = Objects.requireNonNull(questionBanks, "Question Banks cannot be null");
        aggregate.markCreatedNow();

        return aggregate;
    }

    /**
     * Factory method for creating default question bank aggregate for new users.
     *
     * Creates a single default question bank with standard name and description,
     * sets it as the default bank, and marks it as active.
     *
     * @param userId The user ID for the new user
     * @param questionBankId The generated question bank ID
     * @param timestamp The creation timestamp
     * @return New aggregate with default question bank
     * @throws NullPointerException if any parameter is null
     */
    public static QuestionBanksPerUserAggregate createDefault(
            Long userId,
            Long questionBankId,
            Instant timestamp) {

        Objects.requireNonNull(userId, "User ID cannot be null");
        Objects.requireNonNull(questionBankId, "Question Bank ID cannot be null");
        Objects.requireNonNull(timestamp, "Timestamp cannot be null");

        // Create default question bank entity
        QuestionBank defaultBank = new QuestionBank(
            questionBankId,
            "Default Question Bank",
            "Your default question bank for getting started with quiz creation",
            true,  // isActive
            timestamp,
            timestamp
        );

        // Create aggregate with default bank
        return create(
            new ObjectId(),
            userId,
            questionBankId,
            List.of(defaultBank)
        );
    }

    // Existing methods remain unchanged
    public boolean validateOwnership(Long userId, Long questionBankId) {
        if (!this.userId.equals(userId)) {
            return false;
        }

        return questionBanks.stream()
            .anyMatch(bank -> bank.getBankId().equals(questionBankId) && bank.isActive());
    }

    public boolean isDefaultQuestionBank(Long questionBankId) {
        return defaultQuestionBankId.equals(questionBankId);
    }

    public Optional<QuestionBank> findQuestionBank(Long questionBankId) {
        return questionBanks.stream()
            .filter(bank -> bank.getBankId().equals(questionBankId))
            .findFirst();
    }

    public List<QuestionBank> getActiveQuestionBanks() {
        return questionBanks.stream()
            .filter(QuestionBank::isActive)
            .collect(Collectors.toList());
    }

    public boolean belongsToUser(Long userId) {
        return this.userId.equals(userId);
    }

    // Getters
    public ObjectId getId() { return id; }
    public Long getUserId() { return userId; }
    public Long getDefaultQuestionBankId() { return defaultQuestionBankId; }
    public List<QuestionBank> getQuestionBanks() { return questionBanks; }
}
```

**Expected Result**: QuestionBanksPerUserAggregate tests PASS

---

### Task 2.3: RED - Write Tests for TaxonomySetAggregate Factory

**File**: `TaxonomySetAggregateDefaultCreationTest.java`
**Location**: `internal-layer/question-bank/src/test/java/com/quizfun/questionbank/domain/aggregates/`

```java
package com.quizfun.questionbank.domain.aggregates;

import com.quizfun.questionbank.domain.entities.CategoryLevels;
import com.quizfun.questionbank.domain.entities.DifficultyLevel;
import com.quizfun.questionbank.domain.entities.Tag;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.*;

@Epic("Use Case On New User Create Default Question Bank Happy Path")
@Story("1002.domain-aggregates")
@DisplayName("TaxonomySetAggregate Default Creation Tests")
class TaxonomySetAggregateDefaultCreationTest {

    @Test
    @DisplayName("Should create default taxonomy aggregate with valid inputs")
    void shouldCreateDefaultTaxonomyAggregateWithValidInputs() {
        // Given
        Long userId = 123456789L;
        Long questionBankId = 1730832000000000L;
        Instant now = Instant.now();

        // When
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(userId, questionBankId, now);

        // Then
        assertThat(aggregate).isNotNull();
        assertThat(aggregate.getUserId()).isEqualTo(userId);
        assertThat(aggregate.getQuestionBankId()).isEqualTo(questionBankId);
    }

    @Test
    @DisplayName("Should create default category level 1 only")
    void shouldCreateDefaultCategoryLevel1Only() {
        // Given
        Long userId = 123L;
        Long questionBankId = 456L;

        // When
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(userId, questionBankId, Instant.now());

        // Then
        CategoryLevels categories = aggregate.getCategories();
        assertThat(categories.getLevel1()).isNotNull();
        assertThat(categories.getLevel1().getId()).isEqualTo("general");
        assertThat(categories.getLevel1().getName()).isEqualTo("General");
        assertThat(categories.getLevel1().getSlug()).isEqualTo("general");
        assertThat(categories.getLevel1().getParentId()).isNull();

        assertThat(categories.getLevel2()).isNull();
        assertThat(categories.getLevel3()).isNull();
        assertThat(categories.getLevel4()).isNull();
    }

    @Test
    @DisplayName("Should create three default tags")
    void shouldCreateThreeDefaultTags() {
        // When
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // Then
        assertThat(aggregate.getTags()).hasSize(3);

        Tag beginnerTag = findTagById(aggregate, "beginner");
        assertThat(beginnerTag.getName()).isEqualTo("Beginner");
        assertThat(beginnerTag.getColor()).isEqualTo("#28a745");

        Tag practiceTag = findTagById(aggregate, "practice");
        assertThat(practiceTag.getName()).isEqualTo("Practice");
        assertThat(practiceTag.getColor()).isEqualTo("#007bff");

        Tag quickTestTag = findTagById(aggregate, "quick-test");
        assertThat(quickTestTag.getName()).isEqualTo("Quick Test");
        assertThat(quickTestTag.getColor()).isEqualTo("#6f42c1");
    }

    @Test
    @DisplayName("Should create empty quizzes list")
    void shouldCreateEmptyQuizzesList() {
        // When
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // Then
        assertThat(aggregate.getQuizzes()).isEmpty();
    }

    @Test
    @DisplayName("Should set current difficulty level to easy")
    void shouldSetCurrentDifficultyLevelToEasy() {
        // When
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // Then
        DifficultyLevel currentLevel = aggregate.getCurrentDifficultyLevel();
        assertThat(currentLevel.getLevel()).isEqualTo("easy");
        assertThat(currentLevel.getNumericValue()).isEqualTo(1);
        assertThat(currentLevel.getDescription())
            .isEqualTo("Suitable for beginners and initial learning");
    }

    @Test
    @DisplayName("Should create three available difficulty levels")
    void shouldCreateThreeAvailableDifficultyLevels() {
        // When
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // Then
        assertThat(aggregate.getAvailableDifficultyLevels()).hasSize(3);

        DifficultyLevel easy = findDifficultyByLevel(aggregate, "easy");
        assertThat(easy.getNumericValue()).isEqualTo(1);

        DifficultyLevel medium = findDifficultyByLevel(aggregate, "medium");
        assertThat(medium.getNumericValue()).isEqualTo(2);

        DifficultyLevel hard = findDifficultyByLevel(aggregate, "hard");
        assertThat(hard.getNumericValue()).isEqualTo(3);
    }

    @Test
    @DisplayName("Should validate taxonomy references for default values")
    void shouldValidateTaxonomyReferencesForDefaultValues() {
        // Given
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // When & Then - All default values should be valid
        assertThat(aggregate.validateSingleTaxonomyReference("general")).isTrue();
        assertThat(aggregate.validateSingleTaxonomyReference("beginner")).isTrue();
        assertThat(aggregate.validateSingleTaxonomyReference("practice")).isTrue();
        assertThat(aggregate.validateSingleTaxonomyReference("quick-test")).isTrue();
        assertThat(aggregate.validateSingleTaxonomyReference("easy")).isTrue();
        assertThat(aggregate.validateSingleTaxonomyReference("medium")).isTrue();
        assertThat(aggregate.validateSingleTaxonomyReference("hard")).isTrue();
    }

    @Test
    @DisplayName("Should validate category hierarchy is valid")
    void shouldValidateCategoryHierarchyIsValid() {
        // When
        TaxonomySetAggregate aggregate =
            TaxonomySetAggregate.createDefault(123L, 456L, Instant.now());

        // Then - Hierarchy should be valid (only level_1, no gaps)
        assertThat(aggregate.validateCategoryHierarchy()).isTrue();
    }

    @Test
    @DisplayName("Should throw exception when userId is null")
    void shouldThrowExceptionWhenUserIdIsNull() {
        // When & Then
        assertThatThrownBy(() ->
            TaxonomySetAggregate.createDefault(null, 123L, Instant.now()))
            .isInstanceOf(NullPointerException.class)
            .hasMessageContaining("User ID cannot be null");
    }

    @Test
    @DisplayName("Should throw exception when questionBankId is null")
    void shouldThrowExceptionWhenQuestionBankIdIsNull() {
        // When & Then
        assertThatThrownBy(() ->
            TaxonomySetAggregate.createDefault(123L, null, Instant.now()))
            .isInstanceOf(NullPointerException.class)
            .hasMessageContaining("Question Bank ID cannot be null");
    }

    @Test
    @DisplayName("Should throw exception when timestamp is null")
    void shouldThrowExceptionWhenTimestampIsNull() {
        // When & Then
        assertThatThrownBy(() ->
            TaxonomySetAggregate.createDefault(123L, 456L, null))
            .isInstanceOf(NullPointerException.class)
            .hasMessageContaining("Timestamp cannot be null");
    }

    // Helper methods
    private Tag findTagById(TaxonomySetAggregate aggregate, String id) {
        return aggregate.getTags().stream()
            .filter(tag -> tag.getId().equals(id))
            .findFirst()
            .orElseThrow(() -> new AssertionError("Tag not found: " + id));
    }

    private DifficultyLevel findDifficultyByLevel(TaxonomySetAggregate aggregate, String level) {
        return aggregate.getAvailableDifficultyLevels().stream()
            .filter(diff -> diff.getLevel().equals(level))
            .findFirst()
            .orElseThrow(() -> new AssertionError("Difficulty not found: " + level));
    }
}
```

**Expected Result**: Tests FAIL (method doesn't exist yet)

---

### Task 2.4: GREEN - Implement TaxonomySetAggregate Factory

**File**: Modify existing `TaxonomySetAggregate.java`

```java
package com.quizfun.questionbank.domain.aggregates;

import com.quizfun.questionbank.domain.entities.CategoryLevels;
import com.quizfun.questionbank.domain.entities.DifficultyLevel;
import com.quizfun.questionbank.domain.entities.Quiz;
import com.quizfun.questionbank.domain.entities.Tag;
import com.quizfun.shared.domain.AggregateRoot;
import org.bson.types.ObjectId;

import java.time.Instant;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public class TaxonomySetAggregate extends AggregateRoot {
    private ObjectId id;
    private Long userId;
    private Long questionBankId;
    private CategoryLevels categories;
    private List<Tag> tags;
    private List<Quiz> quizzes;
    private DifficultyLevel currentDifficultyLevel;
    private List<DifficultyLevel> availableDifficultyLevels;

    // Existing private constructor
    private TaxonomySetAggregate() {
        // Private constructor for frameworks
    }

    // Existing create method (keep unchanged)
    public static TaxonomySetAggregate create(
            ObjectId id,
            Long userId,
            Long questionBankId,
            CategoryLevels categories,
            List<Tag> tags,
            List<Quiz> quizzes,
            DifficultyLevel currentDifficultyLevel,
            List<DifficultyLevel> availableDifficultyLevels) {

        TaxonomySetAggregate aggregate = new TaxonomySetAggregate();
        aggregate.id = Objects.requireNonNull(id, "ID cannot be null");
        aggregate.userId = Objects.requireNonNull(userId, "User ID cannot be null");
        aggregate.questionBankId = Objects.requireNonNull(questionBankId, "Question Bank ID cannot be null");
        aggregate.categories = categories;
        aggregate.tags = tags;
        aggregate.quizzes = quizzes;
        aggregate.currentDifficultyLevel = currentDifficultyLevel;
        aggregate.availableDifficultyLevels = availableDifficultyLevels;
        aggregate.markCreatedNow();

        return aggregate;
    }

    /**
     * Factory method for creating default taxonomy set for new users.
     *
     * Creates minimal taxonomy structure:
     * - Single category (level_1: "general")
     * - Three tags: "beginner", "practice", "quick-test"
     * - Empty quizzes list
     * - Three difficulty levels (easy, medium, hard)
     * - Current difficulty set to "easy"
     *
     * @param userId The user ID
     * @param questionBankId The question bank ID
     * @param timestamp The creation timestamp
     * @return New aggregate with default taxonomy
     * @throws NullPointerException if any parameter is null
     */
    public static TaxonomySetAggregate createDefault(
            Long userId,
            Long questionBankId,
            Instant timestamp) {

        Objects.requireNonNull(userId, "User ID cannot be null");
        Objects.requireNonNull(questionBankId, "Question Bank ID cannot be null");
        Objects.requireNonNull(timestamp, "Timestamp cannot be null");

        // Create default category (only level_1)
        CategoryLevels categories = new CategoryLevels();
        CategoryLevels.Category generalCategory = new CategoryLevels.Category(
            "general",
            "General",
            "general",
            null  // No parent for level_1
        );
        categories.setLevel1(generalCategory);

        // Create default tags
        List<Tag> tags = List.of(
            new Tag("beginner", "Beginner", "#28a745"),
            new Tag("practice", "Practice", "#007bff"),
            new Tag("quick-test", "Quick Test", "#6f42c1")
        );

        // Empty quizzes list
        List<Quiz> quizzes = List.of();

        // Create difficulty levels
        DifficultyLevel easy = new DifficultyLevel(
            "easy",
            1,
            "Suitable for beginners and initial learning"
        );

        DifficultyLevel medium = new DifficultyLevel(
            "medium",
            2,
            "Intermediate knowledge required"
        );

        DifficultyLevel hard = new DifficultyLevel(
            "hard",
            3,
            "Advanced understanding needed"
        );

        List<DifficultyLevel> availableLevels = List.of(easy, medium, hard);

        // Create aggregate with default values
        return create(
            new ObjectId(),
            userId,
            questionBankId,
            categories,
            tags,
            quizzes,
            easy,  // Current level is "easy"
            availableLevels
        );
    }

    // Existing methods (keep all unchanged)
    public boolean validateTaxonomyReferences(List<String> taxonomyIds) { /* ... */ }
    public boolean validateSingleTaxonomyReference(String taxonomyId) { /* ... */ }
    public List<String> findInvalidTaxonomyReferences(List<String> taxonomyIds) { /* ... */ }
    public boolean validateCategoryHierarchy() { /* ... */ }

    // ... all other existing methods

    // Getters
    public ObjectId getId() { return id; }
    public Long getUserId() { return userId; }
    public Long getQuestionBankId() { return questionBankId; }
    public CategoryLevels getCategories() { return categories; }
    public List<Tag> getTags() { return tags; }
    public List<Quiz> getQuizzes() { return quizzes; }
    public DifficultyLevel getCurrentDifficultyLevel() { return currentDifficultyLevel; }
    public List<DifficultyLevel> getAvailableDifficultyLevels() { return availableDifficultyLevels; }
}
```

**Expected Result**: All TaxonomySetAggregate tests PASS

---

### Task 2.5: REFACTOR - Extract Constants

**Refactoring**: Extract magic strings to constants

```java
public class TaxonomySetAggregate extends AggregateRoot {

    // Default taxonomy constants
    private static final String DEFAULT_CATEGORY_ID = "general";
    private static final String DEFAULT_CATEGORY_NAME = "General";
    private static final String DEFAULT_CATEGORY_SLUG = "general";

    private static final String DEFAULT_TAG_BEGINNER_ID = "beginner";
    private static final String DEFAULT_TAG_PRACTICE_ID = "practice";
    private static final String DEFAULT_TAG_QUICKTEST_ID = "quick-test";

    private static final String DIFFICULTY_EASY = "easy";
    private static final String DIFFICULTY_MEDIUM = "medium";
    private static final String DIFFICULTY_HARD = "hard";

    // ... rest of class
}
```

**After Refactoring**: Re-run all tests - MUST STILL PASS

---

## Definition of Done

- [x] Tests written BEFORE implementation (TDD Red)
- [x] QuestionBanksPerUserAggregate.createDefault() implemented (TDD Green)
- [x] TaxonomySetAggregate.createDefault() implemented (TDD Green)
- [x] Code refactored with constants (TDD Refactor)
- [x] 100% coverage for new factory methods
- [x] All tests pass with proper Allure annotations
- [x] Factory methods validate all inputs
- [x] Domain invariants enforced
- [x] Javadoc added to factory methods
- [x] No external dependencies

---

## Dependencies
- **WBS 1001**: Command object (for understanding flow)
- **Existing aggregates**: QuestionBanksPerUserAggregate, TaxonomySetAggregate

---

## Estimated Effort
**3-4 hours** (0.5 day)

---

## Testing Checklist

### Pre-Implementation
- [ ] Write all 18+ test cases (8 for QuestionBanks + 10 for Taxonomy)
- [ ] Verify tests fail (method doesn't exist)

### Implementation
- [ ] Implement QuestionBanksPerUserAggregate.createDefault()
- [ ] Run tests - verify QuestionBanks tests pass
- [ ] Implement TaxonomySetAggregate.createDefault()
- [ ] Run tests - verify Taxonomy tests pass
- [ ] Check coverage (100% for new methods)

### Refactoring
- [ ] Extract magic strings to constants
- [ ] Re-run all tests (must still pass)
- [ ] Review code quality

### Final Verification
- [ ] Run `mvn clean test -pl internal-layer/question-bank`
- [ ] Check Allure report
- [ ] Verify coverage report
- [ ] Code review ready

---

## Notes
- Factory methods use existing domain entities (no new entity creation)
- Category hierarchy is minimal (level_1 only) to avoid validation complexity
- Default values match JSON templates exactly
- Timestamps passed in to ensure consistency across aggregates
