# User Story 1012: Simple MongoDB Query Repository

## User Story

**As a** backend developer
**I want** to implement a simple MongoDB repository that queries questions without filters
**So that** I can establish the foundation for basic pagination and sorting functionality

## Acceptance Criteria

- [ ] Repository interface created for question queries (output port)
- [ ] MongoDB document model created for questions (read model)
- [ ] MongoDB repository implementation created (adapter)
- [ ] Mapper created to convert documents to DTOs
- [ ] Repository can query questions by userId and questionBankId
- [ ] Repository supports pagination (page number and size)
- [ ] Repository supports sorting (by createdAt, updatedAt, questionText)
- [ ] Repository can count total questions for pagination metadata
- [ ] Integration tests verify basic query functionality with Testcontainer
- [ ] All tests pass with JaCoCo coverage > 70%
- [ ] Allure annotations correctly applied

---

## TDD Cycle

### Allure Annotations Format

```java
@Epic("Use Case Query List of Questions of Question Bank")
@Story("1012.simple-mongodb-query-repository")
```

---

## Phase 1: RED (Write Failing Tests)

### Objective
Write failing integration tests for basic repository operations.

### Tasks

#### Task 1.1: Create Repository Interface (Output Port)

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/application/ports/out/IQuestionQueryRepository.java`

```java
package com.quizfun.questionbankquery.application.ports.out;

import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;

import java.util.List;

/**
 * Output port for querying questions from the data store.
 *
 * <p>This interface defines the contract for question query operations
 * without specifying implementation details (hexagonal architecture).
 */
public interface IQuestionQueryRepository {

    /**
     * Queries questions with pagination and sorting, without taxonomy filters.
     *
     * @param request Query request containing userId, questionBankId, pagination, and sorting
     * @return List of questions matching the query
     */
    List<QuestionDTO> queryQuestions(QueryQuestionsRequest request);

    /**
     * Counts total number of questions for the given user and question bank.
     *
     * @param userId User ID
     * @param questionBankId Question Bank ID
     * @return Total count of questions
     */
    long countQuestions(Long userId, Long questionBankId);
}
```

#### Task 1.2: Create MongoDB Document Model

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/infrastructure/persistence/documents/QuestionDocument.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.documents;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import java.time.Instant;
import java.util.List;
import java.util.Map;

/**
 * MongoDB document model for questions in the query module.
 *
 * <p>This is a read-optimized model separate from the command side's domain aggregates.
 * It denormalizes data for query performance.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "questions")
public class QuestionDocument {

    @Id
    private String id;

    @Field("question_id")
    private Long questionId;

    @Field("user_id")
    private Long userId;

    @Field("question_bank_id")
    private Long questionBankId;

    @Field("question_text")
    private String questionText;

    @Field("question_type")
    private String questionType;

    @Field("difficulty_level")
    private String difficultyLevel;

    @Field("type_specific_data")
    private Map<String, Object> typeSpecificData;

    @Field("taxonomy")
    private TaxonomyDocument taxonomy;

    @Field("created_at")
    private Instant createdAt;

    @Field("updated_at")
    private Instant updatedAt;
}
```

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/infrastructure/persistence/documents/TaxonomyDocument.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.documents;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * Embedded document for taxonomy information.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TaxonomyDocument {

    private List<String> categories;
    private List<String> tags;
    private List<String> quizzes;
}
```

#### Task 1.3: Create Integration Test

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/infrastructure/persistence/repositories/MongoQuestionQueryRepositoryIntegrationTest.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.repositories;

import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.ports.out.IQuestionQueryRepository;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MongoDBContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.Instant;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1012.simple-mongodb-query-repository")
@Testcontainers
@SpringBootTest
@DisplayName("Simple MongoDB Query Repository Integration Tests")
class MongoQuestionQueryRepositoryIntegrationTest {

    @Container
    static MongoDBContainer mongoContainer = new MongoDBContainer("mongo:8.0")
            .withExposedPorts(27018)
            .withReuse(false);

    @DynamicPropertySource
    static void mongoProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoContainer::getReplicaSetUrl);
        registry.add("spring.data.mongodb.read-preference", () -> "primary");
    }

    @Autowired
    private MongoTemplate mongoTemplate;

    @Autowired
    private IQuestionQueryRepository questionQueryRepository;

    private static final Long TEST_USER_ID = 12345L;
    private static final Long TEST_QUESTION_BANK_ID = 67890L;
    private static final String COLLECTION_NAME = "questions";

    @BeforeEach
    void setUp() {
        // Clean collection before each test
        mongoTemplate.dropCollection(COLLECTION_NAME);
        mongoTemplate.createCollection(COLLECTION_NAME);
    }

    @AfterEach
    void tearDown() {
        // Clean up after each test
        mongoTemplate.dropCollection(COLLECTION_NAME);
    }

    @Test
    @DisplayName("Should query questions by userId and questionBankId")
    void shouldQueryQuestionsByUserIdAndQuestionBankId() {
        // GIVEN: Questions in the database
        insertTestQuestions(5);

        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .sortBy("createdAt")
                .sortDirection("desc")
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return all matching questions
        assertThat(results).hasSize(5);
        assertThat(results.getFirst().questionText()).isNotNull();
    }

    @Test
    @DisplayName("Should return empty list when no questions match")
    void shouldReturnEmptyListWhenNoQuestionsMatch() {
        // GIVEN: Questions for different user
        insertTestQuestions(3);

        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(99999L) // Different user
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return empty list
        assertThat(results).isEmpty();
    }

    @Test
    @DisplayName("Should support pagination with page and size")
    void shouldSupportPaginationWithPageAndSize() {
        // GIVEN: 25 questions in the database
        insertTestQuestions(25);

        // WHEN: Querying first page (10 items)
        QueryQuestionsRequest request1 = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .build();
        List<QuestionDTO> page1 = questionQueryRepository.queryQuestions(request1);

        // AND: Querying second page (10 items)
        QueryQuestionsRequest request2 = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(1)
                .size(10)
                .build();
        List<QuestionDTO> page2 = questionQueryRepository.queryQuestions(request2);

        // AND: Querying third page (5 items)
        QueryQuestionsRequest request3 = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(2)
                .size(10)
                .build();
        List<QuestionDTO> page3 = questionQueryRepository.queryQuestions(request3);

        // THEN: Pages should have correct sizes
        assertThat(page1).hasSize(10);
        assertThat(page2).hasSize(10);
        assertThat(page3).hasSize(5);

        // AND: Pages should have different questions
        assertThat(page1.getFirst().questionId())
                .isNotEqualTo(page2.getFirst().questionId());
    }

    @Test
    @DisplayName("Should sort by createdAt descending")
    void shouldSortByCreatedAtDescending() {
        // GIVEN: Questions with different timestamps
        Instant now = Instant.now();
        insertQuestionWithTimestamp("Q1", now.minusSeconds(300));
        insertQuestionWithTimestamp("Q2", now.minusSeconds(200));
        insertQuestionWithTimestamp("Q3", now.minusSeconds(100));

        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .sortBy("createdAt")
                .sortDirection("desc")
                .build();

        // WHEN: Querying with sort
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should be sorted newest first
        assertThat(results).hasSize(3);
        assertThat(results.get(0).questionText()).isEqualTo("Q3");
        assertThat(results.get(1).questionText()).isEqualTo("Q2");
        assertThat(results.get(2).questionText()).isEqualTo("Q1");
    }

    @Test
    @DisplayName("Should sort by createdAt ascending")
    void shouldSortByCreatedAtAscending() {
        // GIVEN: Questions with different timestamps
        Instant now = Instant.now();
        insertQuestionWithTimestamp("Q1", now.minusSeconds(300));
        insertQuestionWithTimestamp("Q2", now.minusSeconds(200));
        insertQuestionWithTimestamp("Q3", now.minusSeconds(100));

        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .sortBy("createdAt")
                .sortDirection("asc")
                .build();

        // WHEN: Querying with sort
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should be sorted oldest first
        assertThat(results).hasSize(3);
        assertThat(results.get(0).questionText()).isEqualTo("Q1");
        assertThat(results.get(1).questionText()).isEqualTo("Q2");
        assertThat(results.get(2).questionText()).isEqualTo("Q3");
    }

    @Test
    @DisplayName("Should sort by questionText alphabetically")
    void shouldSortByQuestionTextAlphabetically() {
        // GIVEN: Questions with different text
        Instant now = Instant.now();
        insertQuestionWithTimestamp("Zebra question", now);
        insertQuestionWithTimestamp("Apple question", now);
        insertQuestionWithTimestamp("Mango question", now);

        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .sortBy("questionText")
                .sortDirection("asc")
                .build();

        // WHEN: Querying with text sort
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should be sorted alphabetically
        assertThat(results).hasSize(3);
        assertThat(results.get(0).questionText()).isEqualTo("Apple question");
        assertThat(results.get(1).questionText()).isEqualTo("Mango question");
        assertThat(results.get(2).questionText()).isEqualTo("Zebra question");
    }

    @Test
    @DisplayName("Should count total questions for pagination")
    void shouldCountTotalQuestionsForPagination() {
        // GIVEN: 42 questions in the database
        insertTestQuestions(42);

        // WHEN: Counting questions
        long count = questionQueryRepository.countQuestions(TEST_USER_ID, TEST_QUESTION_BANK_ID);

        // THEN: Should return correct count
        assertThat(count).isEqualTo(42);
    }

    @Test
    @DisplayName("Should return zero count when no questions exist")
    void shouldReturnZeroCountWhenNoQuestionsExist() {
        // GIVEN: No questions in database

        // WHEN: Counting questions
        long count = questionQueryRepository.countQuestions(TEST_USER_ID, TEST_QUESTION_BANK_ID);

        // THEN: Should return zero
        assertThat(count).isZero();
    }

    @Test
    @DisplayName("Should map all question fields correctly")
    void shouldMapAllQuestionFieldsCorrectly() {
        // GIVEN: A question with all fields
        Long questionId = 123456789L;
        QuestionDocument doc = QuestionDocument.builder()
                .questionId(questionId)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("What is the capital of France?")
                .questionType("MCQ")
                .difficultyLevel("EASY")
                .typeSpecificData(Map.of(
                        "options", List.of("Paris", "London", "Berlin"),
                        "correctAnswer", "Paris"
                ))
                .taxonomy(TaxonomyDocument.builder()
                        .categories(List.of("Geography", "Europe"))
                        .tags(List.of("trivia", "beginner"))
                        .quizzes(List.of("geography-101"))
                        .build())
                .createdAt(Instant.now())
                .updatedAt(Instant.now())
                .build();

        mongoTemplate.insert(doc, COLLECTION_NAME);

        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: All fields should be mapped correctly
        assertThat(results).hasSize(1);
        QuestionDTO dto = results.getFirst();
        assertThat(dto.questionId()).isEqualTo(questionId);
        assertThat(dto.questionText()).isEqualTo("What is the capital of France?");
        assertThat(dto.questionType()).isEqualTo("MCQ");
        assertThat(dto.difficultyLevel()).isEqualTo("EASY");
        assertThat(dto.typeSpecificData()).containsKey("options");
        assertThat(dto.taxonomy()).isNotNull();
        assertThat(dto.taxonomy().categories()).containsExactly("Geography", "Europe");
        assertThat(dto.createdAt()).isNotNull();
        assertThat(dto.updatedAt()).isNotNull();
    }

    // Helper methods

    private void insertTestQuestions(int count) {
        Instant now = Instant.now();
        for (int i = 0; i < count; i++) {
            QuestionDocument doc = QuestionDocument.builder()
                    .questionId(1000000000000L + i)
                    .userId(TEST_USER_ID)
                    .questionBankId(TEST_QUESTION_BANK_ID)
                    .questionText("Test Question " + i)
                    .questionType("MCQ")
                    .difficultyLevel("EASY")
                    .typeSpecificData(Map.of("options", List.of("A", "B", "C")))
                    .taxonomy(TaxonomyDocument.builder()
                            .categories(List.of("Test"))
                            .tags(List.of("test-tag"))
                            .quizzes(List.of("test-quiz"))
                            .build())
                    .createdAt(now.minusSeconds(count - i))
                    .updatedAt(now.minusSeconds(count - i))
                    .build();
            mongoTemplate.insert(doc, COLLECTION_NAME);
        }
    }

    private void insertQuestionWithTimestamp(String text, Instant timestamp) {
        QuestionDocument doc = QuestionDocument.builder()
                .questionId(System.currentTimeMillis())
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText(text)
                .questionType("MCQ")
                .createdAt(timestamp)
                .updatedAt(timestamp)
                .build();
        mongoTemplate.insert(doc, COLLECTION_NAME);
    }
}
```

#### Task 1.4: Run Tests (Should FAIL)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=MongoQuestionQueryRepositoryIntegrationTest
```

**Expected Result**: Tests should FAIL because repository implementation doesn't exist yet.

---

## Phase 2: GREEN (Make Tests Pass)

### Objective
Implement repository and mapper to make tests pass.

### Tasks

#### Task 2.1: Create Document to DTO Mapper

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/infrastructure/persistence/mappers/QuestionDocumentMapper.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.mappers;

import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.TaxonomyDTO;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument;
import org.springframework.stereotype.Component;

/**
 * Mapper to convert MongoDB documents to DTOs.
 */
@Component
public class QuestionDocumentMapper {

    /**
     * Converts a QuestionDocument to QuestionDTO.
     *
     * @param document MongoDB document
     * @return Question DTO
     */
    public QuestionDTO toDTO(QuestionDocument document) {
        if (document == null) {
            return null;
        }

        return new QuestionDTO(
                document.getQuestionId(),
                document.getQuestionText(),
                document.getQuestionType(),
                document.getDifficultyLevel(),
                document.getTypeSpecificData(),
                toTaxonomyDTO(document.getTaxonomy()),
                document.getCreatedAt(),
                document.getUpdatedAt()
        );
    }

    /**
     * Converts a TaxonomyDocument to TaxonomyDTO.
     *
     * @param taxonomy Taxonomy document
     * @return Taxonomy DTO
     */
    private TaxonomyDTO toTaxonomyDTO(TaxonomyDocument taxonomy) {
        if (taxonomy == null) {
            return null;
        }

        return new TaxonomyDTO(
                taxonomy.getCategories(),
                taxonomy.getTags(),
                taxonomy.getQuizzes()
        );
    }
}
```

#### Task 2.2: Implement MongoDB Repository

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/infrastructure/persistence/repositories/MongoQuestionQueryRepository.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.repositories;

import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.ports.out.IQuestionQueryRepository;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import com.quizfun.questionbankquery.infrastructure.persistence.mappers.QuestionDocumentMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * MongoDB implementation of question query repository.
 *
 * <p>This is an adapter in hexagonal architecture that implements the output port
 * defined by the application layer.
 */
@Repository
@RequiredArgsConstructor
public class MongoQuestionQueryRepository implements IQuestionQueryRepository {

    private final MongoTemplate mongoTemplate;
    private final QuestionDocumentMapper mapper;

    private static final String COLLECTION_NAME = "questions";
    private static final String FIELD_USER_ID = "user_id";
    private static final String FIELD_QUESTION_BANK_ID = "question_bank_id";
    private static final String FIELD_CREATED_AT = "created_at";
    private static final String FIELD_UPDATED_AT = "updated_at";
    private static final String FIELD_QUESTION_TEXT = "question_text";

    @Override
    public List<QuestionDTO> queryQuestions(QueryQuestionsRequest request) {
        Query query = buildBasicQuery(request.getUserId(), request.getQuestionBankId());

        // Apply pagination
        int skip = request.getPage() * request.getSize();
        query.skip(skip).limit(request.getSize());

        // Apply sorting
        Sort.Direction direction = "asc".equalsIgnoreCase(request.getSortDirection())
                ? Sort.Direction.ASC
                : Sort.Direction.DESC;

        String sortField = mapSortField(request.getSortBy());
        query.with(Sort.by(direction, sortField));

        // Execute query
        List<QuestionDocument> documents = mongoTemplate.find(query, QuestionDocument.class, COLLECTION_NAME);

        // Map to DTOs
        return documents.stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public long countQuestions(Long userId, Long questionBankId) {
        Query query = buildBasicQuery(userId, questionBankId);
        return mongoTemplate.count(query, QuestionDocument.class, COLLECTION_NAME);
    }

    /**
     * Builds a basic query with userId and questionBankId filters.
     */
    private Query buildBasicQuery(Long userId, Long questionBankId) {
        Criteria criteria = Criteria.where(FIELD_USER_ID).is(userId)
                .and(FIELD_QUESTION_BANK_ID).is(questionBankId);
        return new Query(criteria);
    }

    /**
     * Maps logical sort field names to MongoDB document field names.
     */
    private String mapSortField(String sortBy) {
        return switch (sortBy) {
            case "createdAt" -> FIELD_CREATED_AT;
            case "updatedAt" -> FIELD_UPDATED_AT;
            case "questionText" -> FIELD_QUESTION_TEXT;
            default -> FIELD_CREATED_AT;
        };
    }
}
```

#### Task 2.3: Run Tests (Should PASS)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=MongoQuestionQueryRepositoryIntegrationTest
```

**Expected Result**: All 9 tests should PASS.

---

## Phase 3: REFACTOR (Improve Code Quality)

### Objective
Improve code quality, extract constants, add documentation.

### Tasks

#### Task 3.1: Extract Query Builder to Separate Class

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/infrastructure/persistence/repositories/QueryBuilder.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.repositories;

import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;

/**
 * Builder for MongoDB queries with fluent API.
 *
 * <p>This class encapsulates query construction logic for better testability
 * and separation of concerns.
 */
public class QueryBuilder {

    private static final String FIELD_USER_ID = "user_id";
    private static final String FIELD_QUESTION_BANK_ID = "question_bank_id";
    private static final String FIELD_CREATED_AT = "created_at";
    private static final String FIELD_UPDATED_AT = "updated_at";
    private static final String FIELD_QUESTION_TEXT = "question_text";

    private final Query query;

    private QueryBuilder() {
        this.query = new Query();
    }

    /**
     * Creates a new QueryBuilder instance.
     */
    public static QueryBuilder create() {
        return new QueryBuilder();
    }

    /**
     * Adds userId and questionBankId filters.
     */
    public QueryBuilder withUserAndQuestionBank(Long userId, Long questionBankId) {
        Criteria criteria = Criteria.where(FIELD_USER_ID).is(userId)
                .and(FIELD_QUESTION_BANK_ID).is(questionBankId);
        query.addCriteria(criteria);
        return this;
    }

    /**
     * Adds pagination (skip and limit).
     */
    public QueryBuilder withPagination(int page, int size) {
        int skip = page * size;
        query.skip(skip).limit(size);
        return this;
    }

    /**
     * Adds sorting.
     */
    public QueryBuilder withSorting(String sortBy, String sortDirection) {
        Sort.Direction direction = "asc".equalsIgnoreCase(sortDirection)
                ? Sort.Direction.ASC
                : Sort.Direction.DESC;

        String sortField = mapSortField(sortBy);
        query.with(Sort.by(direction, sortField));
        return this;
    }

    /**
     * Builds and returns the Query object.
     */
    public Query build() {
        return query;
    }

    /**
     * Maps logical sort field names to MongoDB document field names.
     */
    private String mapSortField(String sortBy) {
        return switch (sortBy) {
            case "createdAt" -> FIELD_CREATED_AT;
            case "updatedAt" -> FIELD_UPDATED_AT;
            case "questionText" -> FIELD_QUESTION_TEXT;
            default -> FIELD_CREATED_AT;
        };
    }
}
```

#### Task 3.2: Refactor Repository to Use QueryBuilder

Update `MongoQuestionQueryRepository.java`:

```java
@Override
public List<QuestionDTO> queryQuestions(QueryQuestionsRequest request) {
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(request.getUserId(), request.getQuestionBankId())
            .withPagination(request.getPage(), request.getSize())
            .withSorting(request.getSortBy(), request.getSortDirection())
            .build();

    List<QuestionDocument> documents = mongoTemplate.find(query, QuestionDocument.class, COLLECTION_NAME);

    return documents.stream()
            .map(mapper::toDTO)
            .toList();
}

@Override
public long countQuestions(Long userId, Long questionBankId) {
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(userId, questionBankId)
            .build();

    return mongoTemplate.count(query, QuestionDocument.class, COLLECTION_NAME);
}
```

#### Task 3.3: Add Unit Tests for QueryBuilder

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/infrastructure/persistence/repositories/QueryBuilderTest.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.repositories;

import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.data.mongodb.core.query.Query;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1012.simple-mongodb-query-repository")
@DisplayName("QueryBuilder Unit Tests")
class QueryBuilderTest {

    @Test
    @DisplayName("Should build query with user and question bank filters")
    void shouldBuildQueryWithUserAndQuestionBankFilters() {
        // GIVEN: User and question bank IDs
        Long userId = 12345L;
        Long questionBankId = 67890L;

        // WHEN: Building query
        Query query = QueryBuilder.create()
                .withUserAndQuestionBank(userId, questionBankId)
                .build();

        // THEN: Query should have criteria
        assertThat(query.getQueryObject()).isNotNull();
        assertThat(query.getQueryObject().containsKey("user_id")).isTrue();
        assertThat(query.getQueryObject().containsKey("question_bank_id")).isTrue();
    }

    @Test
    @DisplayName("Should build query with pagination")
    void shouldBuildQueryWithPagination() {
        // GIVEN: Pagination parameters
        int page = 2;
        int size = 20;

        // WHEN: Building query
        Query query = QueryBuilder.create()
                .withUserAndQuestionBank(1L, 2L)
                .withPagination(page, size)
                .build();

        // THEN: Query should have skip and limit
        assertThat(query.getSkip()).isEqualTo(40); // page 2 * size 20
        assertThat(query.getLimit()).isEqualTo(20);
    }

    @Test
    @DisplayName("Should build query with sorting")
    void shouldBuildQueryWithSorting() {
        // GIVEN: Sort parameters
        String sortBy = "createdAt";
        String sortDirection = "desc";

        // WHEN: Building query
        Query query = QueryBuilder.create()
                .withUserAndQuestionBank(1L, 2L)
                .withSorting(sortBy, sortDirection)
                .build();

        // THEN: Query should have sort
        assertThat(query.getSortObject()).isNotNull();
        assertThat(query.getSortObject().containsKey("created_at")).isTrue();
    }

    @Test
    @DisplayName("Should build query with all features combined")
    void shouldBuildQueryWithAllFeaturesCombined() {
        // GIVEN: Complete request parameters
        Long userId = 12345L;
        Long questionBankId = 67890L;
        int page = 1;
        int size = 10;
        String sortBy = "updatedAt";
        String sortDirection = "asc";

        // WHEN: Building complete query
        Query query = QueryBuilder.create()
                .withUserAndQuestionBank(userId, questionBankId)
                .withPagination(page, size)
                .withSorting(sortBy, sortDirection)
                .build();

        // THEN: All features should be configured
        assertThat(query.getQueryObject()).isNotNull();
        assertThat(query.getSkip()).isEqualTo(10);
        assertThat(query.getLimit()).isEqualTo(10);
        assertThat(query.getSortObject()).isNotNull();
    }
}
```

#### Task 3.4: Run All Tests with Coverage

```bash
mvn clean verify -pl internal-layer/question-bank-query
```

Verify:
- ✅ All tests pass
- ✅ JaCoCo coverage > 70%

#### Task 3.5: Generate Allure Report

```bash
mvn allure:report -pl internal-layer/question-bank-query
```

---

## Definition of Done

- [ ] Repository interface created (output port)
- [ ] MongoDB document models created
- [ ] Repository implementation created (adapter)
- [ ] Document to DTO mapper created
- [ ] QueryBuilder extracted for better separation
- [ ] All integration tests pass
- [ ] All unit tests pass
- [ ] JaCoCo coverage >= 70%
- [ ] Allure annotations correctly applied
- [ ] Allure report generated successfully
- [ ] Code properly documented
- [ ] No Checkstyle violations
- [ ] No SonarLint warnings
- [ ] Code reviewed and approved

---

## Testing Checklist

### Integration Tests
- [ ] ✅ Query questions by userId and questionBankId
- [ ] ✅ Return empty list when no matches
- [ ] ✅ Pagination with page and size
- [ ] ✅ Sort by createdAt descending
- [ ] ✅ Sort by createdAt ascending
- [ ] ✅ Sort by questionText alphabetically
- [ ] ✅ Count total questions
- [ ] ✅ Return zero count when empty
- [ ] ✅ Map all question fields correctly

### Unit Tests
- [ ] ✅ QueryBuilder with user and question bank filters
- [ ] ✅ QueryBuilder with pagination
- [ ] ✅ QueryBuilder with sorting
- [ ] ✅ QueryBuilder with all features combined

---

## Estimated Effort

- **RED Phase**: 2.5 hours
- **GREEN Phase**: 2 hours
- **REFACTOR Phase**: 1.5 hours
- **Total**: 6 hours

---

## Dependencies

- **1010.testcontainer-mongodb-setup-and-configuration**: Required for test infrastructure
- **1011.query-dtos-and-pagination-logic**: Required for DTOs

---

## Notes

### Why Separate Document Model?

The query module uses a separate document model (not domain aggregates) because:
1. Read models are optimized for query performance
2. Denormalized data reduces joins
3. No need for business logic or invariants
4. Direct mapping to DTOs is simpler

### MongoDB Field Naming

Uses snake_case for MongoDB fields (`user_id`, `question_bank_id`) to match command module conventions and MongoDB best practices.
