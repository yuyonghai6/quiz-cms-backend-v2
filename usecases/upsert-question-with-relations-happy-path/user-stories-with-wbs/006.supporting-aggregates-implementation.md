# US-006: Supporting Aggregates Implementation

## Story Overview
**As a** developer
**I want** supporting domain aggregates for taxonomy validation and relationship management
**So that** the system can validate complex taxonomy structures and manage question-taxonomy relationships properly

## Business Value
- Enables complex taxonomy validation against user's taxonomy sets
- Provides proper domain modeling for many-to-many relationships
- Supports question bank ownership validation for security
- Maintains data consistency across multiple collections

## Work Breakdown Structure (WBS)

### 1. TaxonomySetAggregate Implementation
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: US-000 AggregateRoot, data modeling structure

#### Tasks:
- [ ] **1.1** Design TaxonomySetAggregate structure based on data model
- [ ] **1.2** Implement taxonomy reference validation logic
- [ ] **1.3** Add category hierarchy validation
- [ ] **1.4** Implement tag and quiz validation
- [ ] **1.5** Add difficulty level validation
- [ ] **1.6** Create efficient taxonomy ID extraction methods

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/aggregates/TaxonomySetAggregate.java
public class TaxonomySetAggregate extends AggregateRoot {
    private ObjectId id;
    private Long userId;
    private Long questionBankId;
    private CategoryLevels categories;
    private List<Tag> tags;
    private List<Quiz> quizzes;
    private DifficultyLevel currentDifficultyLevel;
    private List<DifficultyLevel> availableDifficultyLevels;
    private Instant createdAt;
    private Instant updatedAt;

    public boolean validateTaxonomyReferences(List<String> taxonomyIds) {
        var allValidIds = getAllValidTaxonomyIds();
        return taxonomyIds.stream().allMatch(allValidIds::contains);
    }

    public boolean validateSingleTaxonomyReference(String taxonomyId) {
        return getAllValidTaxonomyIds().contains(taxonomyId);
    }

    private Set<String> getAllValidTaxonomyIds() {
        var validIds = new HashSet<String>();

        // Add category IDs from all levels
        if (categories != null) {
            if (categories.getLevel1() != null) validIds.add(categories.getLevel1().getId());
            if (categories.getLevel2() != null) validIds.add(categories.getLevel2().getId());
            if (categories.getLevel3() != null) validIds.add(categories.getLevel3().getId());
            if (categories.getLevel4() != null) validIds.add(categories.getLevel4().getId());
        }

        // Add tag IDs
        if (tags != null) {
            tags.forEach(tag -> validIds.add(tag.getId()));
        }

        // Add quiz IDs (convert to string)
        if (quizzes != null) {
            quizzes.forEach(quiz -> validIds.add(quiz.getQuizId().toString()));
        }

        // Add current difficulty level
        if (currentDifficultyLevel != null) {
            validIds.add(currentDifficultyLevel.getLevel());
        }

        return validIds;
    }

    public List<String> findInvalidTaxonomyReferences(List<String> taxonomyIds) {
        var validIds = getAllValidTaxonomyIds();
        return taxonomyIds.stream()
            .filter(id -> !validIds.contains(id))
            .collect(Collectors.toList());
    }

    public boolean validateCategoryHierarchy() {
        if (categories == null) return true;

        // Validate hierarchy consistency
        if (categories.getLevel2() != null && categories.getLevel1() == null) {
            return false; // Level 2 cannot exist without Level 1
        }
        if (categories.getLevel3() != null && categories.getLevel2() == null) {
            return false; // Level 3 cannot exist without Level 2
        }
        if (categories.getLevel4() != null && categories.getLevel3() == null) {
            return false; // Level 4 cannot exist without Level 3
        }

        return true;
    }

    public boolean belongsToUser(Long userId) {
        return this.userId.equals(userId);
    }

    public boolean belongsToQuestionBank(Long questionBankId) {
        return this.questionBankId.equals(questionBankId);
    }
}
```

#### Acceptance Criteria:
- Validates all taxonomy references against complete taxonomy set
- Supports category hierarchy validation
- Efficiently extracts all valid taxonomy IDs
- Provides methods for individual and bulk validation
- Maintains user and question bank isolation

#### Test Requirements:
- [ ] Unit test: taxonomy reference validation with valid IDs
- [ ] Unit test: taxonomy reference validation with invalid IDs
- [ ] Unit test: category hierarchy validation
- [ ] Unit test: mixed valid/invalid reference scenarios
- [ ] Unit test: user and question bank ownership validation

---

### 2. QuestionTaxonomyRelationshipAggregate Implementation
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: Task 1, US-002 QuestionAggregate

#### Tasks:
- [ ] **2.1** Design relationship aggregate structure
- [ ] **2.2** Implement static factory method for command processing
- [ ] **2.3** Add relationship type handling (category_level_1, tag, quiz, etc.)
- [ ] **2.4** Implement bulk relationship creation logic
- [ ] **2.5** Add validation for relationship integrity
- [ ] **2.6** Handle relationship metadata (timestamps, user context)

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/aggregates/QuestionTaxonomyRelationshipAggregate.java
public class QuestionTaxonomyRelationshipAggregate extends AggregateRoot {
    private ObjectId id;
    private Long userId;
    private Long questionBankId;
    private ObjectId questionId;
    private String taxonomyType;
    private String taxonomyId;
    private Instant createdAt;

    public static List<QuestionTaxonomyRelationshipAggregate> createFromCommand(
            ObjectId questionId, UpsertQuestionCommand command) {

        var relationships = new ArrayList<QuestionTaxonomyRelationshipAggregate>();

        // Create category relationships
        var categories = command.getTaxonomy().getCategories();
        if (categories.getLevel1() != null) {
            relationships.add(createRelationship(questionId, command,
                "category_level_1", categories.getLevel1().getId()));
        }
        if (categories.getLevel2() != null) {
            relationships.add(createRelationship(questionId, command,
                "category_level_2", categories.getLevel2().getId()));
        }
        if (categories.getLevel3() != null) {
            relationships.add(createRelationship(questionId, command,
                "category_level_3", categories.getLevel3().getId()));
        }
        if (categories.getLevel4() != null) {
            relationships.add(createRelationship(questionId, command,
                "category_level_4", categories.getLevel4().getId()));
        }

        // Create tag relationships
        command.getTaxonomy().getTags().forEach(tag -> {
            relationships.add(createRelationship(questionId, command, "tag", tag.getId()));
        });

        // Create quiz relationships
        command.getTaxonomy().getQuizzes().forEach(quiz -> {
            relationships.add(createRelationship(questionId, command,
                "quiz", quiz.getQuizId().toString()));
        });

        // Create difficulty level relationship
        relationships.add(createRelationship(questionId, command,
            "difficulty_level", command.getTaxonomy().getDifficultyLevel().getLevel()));

        return relationships;
    }

    private static QuestionTaxonomyRelationshipAggregate createRelationship(
            ObjectId questionId, UpsertQuestionCommand command,
            String taxonomyType, String taxonomyId) {

        var relationship = new QuestionTaxonomyRelationshipAggregate();
        relationship.userId = command.getUserId();
        relationship.questionBankId = command.getQuestionBankId();
        relationship.questionId = questionId;
        relationship.taxonomyType = taxonomyType;
        relationship.taxonomyId = taxonomyId;
        relationship.createdAt = Instant.now();

        return relationship;
    }

    public boolean isValidRelationshipType() {
        return Arrays.asList(
            "category_level_1", "category_level_2", "category_level_3", "category_level_4",
            "tag", "quiz", "difficulty_level"
        ).contains(this.taxonomyType);
    }

    public boolean belongsToUser(Long userId) {
        return this.userId.equals(userId);
    }

    public boolean belongsToQuestionBank(Long questionBankId) {
        return this.questionBankId.equals(questionBankId);
    }

    public boolean belongsToQuestion(ObjectId questionId) {
        return this.questionId.equals(questionId);
    }
}
```

#### Acceptance Criteria:
- Creates appropriate relationships for all taxonomy types
- Handles multiple relationships per question (one per taxonomy element)
- Maintains referential integrity with question and taxonomy IDs
- Supports user and question bank isolation
- Validates relationship types and data consistency

#### Test Requirements:
- [ ] Unit test: relationship creation from command with all taxonomy types
- [ ] Unit test: category level relationship creation
- [ ] Unit test: tag relationship creation (multiple)
- [ ] Unit test: quiz relationship creation (multiple)
- [ ] Unit test: difficulty level relationship creation
- [ ] Unit test: relationship type validation

---

### 3. QuestionBanksPerUserAggregate Implementation
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 2 complete

#### Tasks:
- [ ] **3.1** Design aggregate based on embedded question bank structure
- [ ] **3.2** Implement ownership validation logic
- [ ] **3.3** Add default question bank identification
- [ ] **3.4** Handle question bank array operations
- [ ] **3.5** Add user validation methods

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/aggregates/QuestionBanksPerUserAggregate.java
public class QuestionBanksPerUserAggregate extends AggregateRoot {
    private ObjectId id;
    private Long userId;
    private Long defaultQuestionBankId;
    private List<QuestionBank> questionBanks;
    private Instant createdAt;
    private Instant updatedAt;

    public boolean validateOwnership(Long userId, Long questionBankId) {
        if (!this.userId.equals(userId)) {
            return false;
        }

        return questionBanks.stream()
            .anyMatch(bank -> bank.getBankId().equals(questionBankId) && bank.isActive());
    }

    public boolean isDefaultQuestionBank(Long questionBankId) {
        return defaultQuestionBankId.equals(questionBankId);
    }

    public Optional<QuestionBank> findQuestionBank(Long questionBankId) {
        return questionBanks.stream()
            .filter(bank -> bank.getBankId().equals(questionBankId))
            .findFirst();
    }

    public List<QuestionBank> getActiveQuestionBanks() {
        return questionBanks.stream()
            .filter(QuestionBank::isActive)
            .collect(Collectors.toList());
    }

    public boolean belongsToUser(Long userId) {
        return this.userId.equals(userId);
    }
}
```

#### Acceptance Criteria:
- Validates user ownership of question banks
- Supports embedded question bank array structure
- Handles default question bank identification
- Provides active question bank filtering
- Maintains user isolation

#### Test Requirements:
- [ ] Unit test: ownership validation for valid user/question bank
- [ ] Unit test: ownership validation failure scenarios
- [ ] Unit test: default question bank identification
- [ ] Unit test: active question bank filtering

---

### 4. Supporting Repository Interfaces
**Estimated Effort**: 0.5 days
**Priority**: Medium
**Dependencies**: Tasks 1, 2, 3 complete

#### Tasks:
- [ ] **4.1** Define TaxonomySetRepository interface
- [ ] **4.2** Define QuestionBanksPerUserRepository interface
- [ ] **4.3** Add validation-focused repository methods
- [ ] **4.4** Implement efficient query contracts
- [ ] **4.5** Add repository documentation

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/ports/out/TaxonomySetRepository.java
public interface TaxonomySetRepository {
    Result<Boolean> validateTaxonomyReferences(Long userId, Long questionBankId, List<String> taxonomyIds);
    Result<Boolean> validateTaxonomyReference(Long userId, Long questionBankId, String taxonomyId);
    Result<Optional<TaxonomySetAggregate>> findByUserAndQuestionBank(Long userId, Long questionBankId);
}

// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/ports/out/QuestionBanksPerUserRepository.java
public interface QuestionBanksPerUserRepository {
    Result<Boolean> validateOwnership(Long userId, Long questionBankId);
    Result<Optional<QuestionBanksPerUserAggregate>> findByUserId(Long userId);
    Result<Optional<QuestionBank>> findQuestionBank(Long userId, Long questionBankId);
}
```

---

### 5. Aggregate Integration Testing
**Estimated Effort**: 0.5 days
**Priority**: Medium
**Dependencies**: All previous tasks complete

#### Tasks:
- [ ] **5.1** Create comprehensive aggregate interaction tests
- [ ] **5.2** Test validation workflows
- [ ] **5.3** Verify relationship creation scenarios
- [ ] **5.4** Add performance validation tests
- [ ] **5.5** Test error scenarios and edge cases

## Acceptance Criteria Summary

### Functional Requirements
- [ ] TaxonomySetAggregate validates all taxonomy references efficiently
- [ ] QuestionTaxonomyRelationshipAggregate creates correct relationships from commands
- [ ] QuestionBanksPerUserAggregate validates ownership correctly
- [ ] All aggregates maintain user and question bank isolation
- [ ] Repository interfaces provide efficient validation methods

### Non-Functional Requirements
- [ ] Taxonomy validation completes within 50ms for typical datasets
- [ ] Relationship creation scales to 20+ relationships per question
- [ ] Memory usage <10MB for aggregate operations
- [ ] Thread-safe aggregate implementations

### Definition of Done
- [ ] All three supporting aggregates implemented and tested
- [ ] Repository interfaces defined with clear contracts
- [ ] Comprehensive unit tests covering all validation scenarios
- [ ] Integration tests with question creation workflow
- [ ] Performance benchmarks established
- [ ] Code review completed

## Dependencies and Risks

### Dependencies
- US-000 AggregateRoot base class
- Data modeling document structure
- UpsertQuestionCommand with taxonomy data
- MongoDB document structure understanding

### Risks
- **Risk**: Complex taxonomy validation performance
  **Mitigation**: Optimize validation algorithms and add caching

- **Risk**: Relationship creation complexity
  **Mitigation**: Break down into smaller, testable methods

- **Risk**: Data consistency across aggregates
  **Mitigation**: Clear aggregate boundaries and validation rules

## Testing Strategy

### Unit Testing
- Individual aggregate business logic
- Validation rule testing
- Edge cases and boundary conditions
- Error scenario coverage

### Integration Testing
- Cross-aggregate validation workflows
- Repository interface behavior
- Performance under load

### Test Data Requirements
- Complete taxonomy sets for validation testing
- Various question bank ownership scenarios
- Complex relationship creation scenarios
- Invalid data for error testing

## Technical Notes

### Design Patterns Used
- **Aggregate Pattern**: Core DDD implementation
- **Factory Method**: Relationship creation from commands
- **Specification Pattern**: Validation logic encapsulation

### Performance Considerations
- Efficient Set operations for taxonomy validation
- Minimal object creation during validation
- Bulk relationship processing optimization

### Security Considerations
- User isolation in all validation methods
- Question bank ownership enforcement
- Input validation for taxonomy references