# US-004: Question Type Strategy Implementation

## Story Overview
**As a** content creator
**I want** the system to handle different question types with their specific validation and processing rules
**So that** I can create MCQ, Essay, and True/False questions with appropriate type-specific validations

## Business Value
- Enables support for multiple question types with specific business rules
- Provides extensible architecture for future question types
- Ensures type-specific data integrity and validation
- Simplifies question processing logic

## Work Breakdown Structure (WBS)

### 1. Strategy Pattern Infrastructure
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: US-002 QuestionAggregate complete

#### Tasks:
- [ ] **1.1** Define QuestionTypeStrategy interface
- [ ] **1.2** Create strategy factory pattern implementation
- [ ] **1.3** Add Spring component auto-discovery
- [ ] **1.4** Implement strategy selection logic
- [ ] **1.5** Add error handling for unsupported types

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/services/QuestionTypeStrategy.java
public interface QuestionTypeStrategy {
    Result<QuestionAggregate> processQuestionData(UpsertQuestionCommand command);
    boolean supports(QuestionType type);
    String getStrategyName();
}

// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/services/QuestionTypeStrategyFactory.java
@Component
public class QuestionTypeStrategyFactory {

    private final Map<QuestionType, QuestionTypeStrategy> strategies;
    private static final Logger logger = LoggerFactory.getLogger(QuestionTypeStrategyFactory.class);

    public QuestionTypeStrategyFactory(List<QuestionTypeStrategy> strategyList) {
        this.strategies = strategyList.stream()
            .collect(Collectors.toMap(
                strategy -> findSupportedType(strategy),
                Function.identity()
            ));

        logger.info("Registered question type strategies: {}",
                   strategies.keySet().stream()
                       .map(QuestionType::getValue)
                       .collect(Collectors.joining(", ")));
    }

    public QuestionTypeStrategy getStrategy(QuestionType type) {
        var strategy = strategies.get(type);
        if (strategy == null) {
            throw new UnsupportedQuestionTypeException(
                String.format("No strategy found for question type: %s", type)
            );
        }
        return strategy;
    }

    public Set<QuestionType> getSupportedTypes() {
        return strategies.keySet();
    }

    private QuestionType findSupportedType(QuestionTypeStrategy strategy) {
        return Arrays.stream(QuestionType.values())
            .filter(strategy::supports)
            .findFirst()
            .orElseThrow(() -> new IllegalStateException(
                "Strategy must support at least one question type: " + strategy.getClass().getSimpleName()
            ));
    }
}
```

#### Acceptance Criteria:
- Strategy interface defines clear contract
- Factory auto-discovers strategies via Spring
- Type-safe strategy selection
- Comprehensive error handling

#### Test Requirements:
- [ ] Unit test: strategy interface contract
- [ ] Unit test: factory auto-discovery
- [ ] Unit test: unsupported type handling

---

### 2. MCQ Question Strategy Implementation
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: Task 1 complete

#### Tasks:
- [ ] **2.1** Implement McqQuestionStrategy class
- [ ] **2.2** Add MCQ-specific validation rules
- [ ] **2.3** Implement option validation logic
- [ ] **2.4** Add correct answer validation
- [ ] **2.5** Handle MCQ business rules
- [ ] **2.6** Integrate with QuestionAggregate creation

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/services/impl/McqQuestionStrategy.java
@Component
public class McqQuestionStrategy implements QuestionTypeStrategy {

    private static final Logger logger = LoggerFactory.getLogger(McqQuestionStrategy.class);

    @Override
    public Result<QuestionAggregate> processQuestionData(UpsertQuestionCommand command) {
        logger.debug("Processing MCQ question data for source ID: {}", command.getSourceQuestionId());

        // Validate MCQ-specific data is present
        if (command.getMcqData() == null) {
            return Result.failure(
                "MCQ_DATA_REQUIRED",
                "MCQ data is required for MCQ questions"
            );
        }

        // Validate MCQ data integrity
        var validationResult = validateMcqData(command.getMcqData());
        if (validationResult.isFailure()) {
            return validationResult;
        }

        try {
            // Create QuestionAggregate
            var questionAggregate = QuestionAggregate.createNew(
                command.getUserId(),
                command.getQuestionBankId(),
                command.getSourceQuestionId(),
                command.getQuestionType(),
                command.getTitle(),
                command.getContent(),
                command.getPoints()
            );

            // Set MCQ-specific data
            questionAggregate.setMcqData(command.getMcqData());

            // Set additional properties
            setAdditionalProperties(questionAggregate, command);

            logger.debug("Successfully processed MCQ question data for source ID: {}",
                        command.getSourceQuestionId());

            return Result.success(questionAggregate);

        } catch (Exception ex) {
            logger.error("Failed to process MCQ question data for source ID: {}",
                        command.getSourceQuestionId(), ex);
            return Result.failure(
                "MCQ_PROCESSING_ERROR",
                "Failed to process MCQ question: " + ex.getMessage()
            );
        }
    }

    private Result<QuestionAggregate> validateMcqData(McqData mcqData) {
        // Validate options exist
        if (mcqData.getOptions() == null || mcqData.getOptions().isEmpty()) {
            return Result.failure(
                "MCQ_NO_OPTIONS",
                "MCQ questions must have at least one option"
            );
        }

        // Validate option count
        if (mcqData.getOptions().size() < 2) {
            return Result.failure(
                "MCQ_INSUFFICIENT_OPTIONS",
                "MCQ questions must have at least 2 options"
            );
        }

        if (mcqData.getOptions().size() > 10) {
            return Result.failure(
                "MCQ_TOO_MANY_OPTIONS",
                "MCQ questions cannot have more than 10 options"
            );
        }

        // Validate correct answers exist
        long correctAnswerCount = mcqData.getOptions().stream()
            .mapToLong(option -> option.isCorrect() ? 1 : 0)
            .sum();

        if (correctAnswerCount == 0) {
            return Result.failure(
                "MCQ_NO_CORRECT_ANSWER",
                "MCQ questions must have at least one correct answer"
            );
        }

        // Validate multiple correct answers if not allowed
        if (correctAnswerCount > 1 && !mcqData.isAllowMultipleCorrect()) {
            return Result.failure(
                "MCQ_MULTIPLE_CORRECT_NOT_ALLOWED",
                "Multiple correct answers not allowed for this MCQ configuration"
            );
        }

        // Validate option text
        for (int i = 0; i < mcqData.getOptions().size(); i++) {
            var option = mcqData.getOptions().get(i);
            if (option.getText() == null || option.getText().trim().isEmpty()) {
                return Result.failure(
                    "MCQ_EMPTY_OPTION",
                    String.format("Option %d cannot be empty", i + 1)
                );
            }
        }

        // Validate time limit
        if (mcqData.getTimeLimitSeconds() != null && mcqData.getTimeLimitSeconds() <= 0) {
            return Result.failure(
                "MCQ_INVALID_TIME_LIMIT",
                "Time limit must be positive if specified"
            );
        }

        return Result.success(null);
    }

    private void setAdditionalProperties(QuestionAggregate aggregate, UpsertQuestionCommand command) {
        if (command.getSolutionExplanation() != null) {
            aggregate.setSolutionExplanation(command.getSolutionExplanation());
        }
        if (command.getStatus() != null) {
            aggregate.setStatus(command.getStatus());
        }
        if (command.getDisplayOrder() != null) {
            aggregate.setDisplayOrder(command.getDisplayOrder());
        }
        if (command.getAttachments() != null) {
            aggregate.setAttachments(command.getAttachments());
        }
        if (command.getQuestionSettings() != null) {
            aggregate.setQuestionSettings(command.getQuestionSettings());
        }
    }

    @Override
    public boolean supports(QuestionType type) {
        return QuestionType.MCQ == type;
    }

    @Override
    public String getStrategyName() {
        return "MCQ Strategy";
    }
}
```

#### Acceptance Criteria:
- MCQ data validation comprehensive
- Option count and content validation
- Correct answer requirement enforced
- Business rules for MCQ questions applied
- Integration with QuestionAggregate successful

#### Test Requirements:
- [ ] Unit test: valid MCQ data processing
- [ ] Unit test: missing MCQ data error
- [ ] Unit test: insufficient options validation
- [ ] Unit test: no correct answer validation
- [ ] Unit test: multiple correct answer handling
- [ ] Unit test: time limit validation

---

### 3. Essay Question Strategy Implementation
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 2 complete

#### Tasks:
- [ ] **3.1** Implement EssayQuestionStrategy class
- [ ] **3.2** Add essay-specific validation rules
- [ ] **3.3** Implement rubric validation logic
- [ ] **3.4** Handle word count requirements
- [ ] **3.5** Validate essay business rules

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/services/impl/EssayQuestionStrategy.java
@Component
public class EssayQuestionStrategy implements QuestionTypeStrategy {

    private static final Logger logger = LoggerFactory.getLogger(EssayQuestionStrategy.class);

    @Override
    public Result<QuestionAggregate> processQuestionData(UpsertQuestionCommand command) {
        logger.debug("Processing Essay question data for source ID: {}", command.getSourceQuestionId());

        // Validate Essay-specific data is present
        if (command.getEssayData() == null) {
            return Result.failure(
                "ESSAY_DATA_REQUIRED",
                "Essay data is required for essay questions"
            );
        }

        // Validate Essay data integrity
        var validationResult = validateEssayData(command.getEssayData());
        if (validationResult.isFailure()) {
            return validationResult;
        }

        try {
            // Create QuestionAggregate
            var questionAggregate = QuestionAggregate.createNew(
                command.getUserId(),
                command.getQuestionBankId(),
                command.getSourceQuestionId(),
                command.getQuestionType(),
                command.getTitle(),
                command.getContent(),
                command.getPoints()
            );

            // Set Essay-specific data
            questionAggregate.setEssayData(command.getEssayData());

            // Set additional properties
            setAdditionalProperties(questionAggregate, command);

            logger.debug("Successfully processed Essay question data for source ID: {}",
                        command.getSourceQuestionId());

            return Result.success(questionAggregate);

        } catch (Exception ex) {
            logger.error("Failed to process Essay question data for source ID: {}",
                        command.getSourceQuestionId(), ex);
            return Result.failure(
                "ESSAY_PROCESSING_ERROR",
                "Failed to process Essay question: " + ex.getMessage()
            );
        }
    }

    private Result<QuestionAggregate> validateEssayData(EssayData essayData) {
        // Validate prompt exists
        if (essayData.getPrompt() == null || essayData.getPrompt().trim().isEmpty()) {
            return Result.failure(
                "ESSAY_NO_PROMPT",
                "Essay questions must have a prompt"
            );
        }

        // Validate word count requirements
        if (essayData.getMinWords() != null && essayData.getMaxWords() != null) {
            if (essayData.getMinWords() > essayData.getMaxWords()) {
                return Result.failure(
                    "ESSAY_INVALID_WORD_COUNT",
                    "Minimum word count cannot be greater than maximum word count"
                );
            }
        }

        if (essayData.getMinWords() != null && essayData.getMinWords() < 0) {
            return Result.failure(
                "ESSAY_NEGATIVE_MIN_WORDS",
                "Minimum word count cannot be negative"
            );
        }

        if (essayData.getMaxWords() != null && essayData.getMaxWords() <= 0) {
            return Result.failure(
                "ESSAY_INVALID_MAX_WORDS",
                "Maximum word count must be positive"
            );
        }

        // Validate rubric if provided
        if (essayData.getRubric() != null && !essayData.getRubric().isEmpty()) {
            var rubricValidation = validateRubric(essayData.getRubric());
            if (rubricValidation.isFailure()) {
                return rubricValidation;
            }
        }

        return Result.success(null);
    }

    private Result<QuestionAggregate> validateRubric(List<RubricCriteria> rubric) {
        int totalMaxPoints = 0;

        for (int i = 0; i < rubric.size(); i++) {
            var criteria = rubric.get(i);

            if (criteria.getCriteria() == null || criteria.getCriteria().trim().isEmpty()) {
                return Result.failure(
                    "ESSAY_EMPTY_RUBRIC_CRITERIA",
                    String.format("Rubric criteria %d cannot be empty", i + 1)
                );
            }

            if (criteria.getMaxPoints() <= 0) {
                return Result.failure(
                    "ESSAY_INVALID_RUBRIC_POINTS",
                    String.format("Rubric criteria %d must have positive max points", i + 1)
                );
            }

            totalMaxPoints += criteria.getMaxPoints();
        }

        // Validate total points don't exceed reasonable limits
        if (totalMaxPoints > 1000) {
            return Result.failure(
                "ESSAY_RUBRIC_TOO_MANY_POINTS",
                "Total rubric points cannot exceed 1000"
            );
        }

        return Result.success(null);
    }

    @Override
    public boolean supports(QuestionType type) {
        return QuestionType.ESSAY == type;
    }

    @Override
    public String getStrategyName() {
        return "Essay Strategy";
    }
}
```

---

### 4. True/False Question Strategy Implementation
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 3 complete

#### Tasks:
- [ ] **4.1** Implement TrueFalseQuestionStrategy class
- [ ] **4.2** Add true/false specific validation
- [ ] **4.3** Validate statement requirements
- [ ] **4.4** Handle explanation validation
- [ ] **4.5** Apply true/false business rules

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/domain/services/impl/TrueFalseQuestionStrategy.java
@Component
public class TrueFalseQuestionStrategy implements QuestionTypeStrategy {

    private static final Logger logger = LoggerFactory.getLogger(TrueFalseQuestionStrategy.class);

    @Override
    public Result<QuestionAggregate> processQuestionData(UpsertQuestionCommand command) {
        logger.debug("Processing True/False question data for source ID: {}", command.getSourceQuestionId());

        // Validate True/False-specific data is present
        if (command.getTrueFalseData() == null) {
            return Result.failure(
                "TRUE_FALSE_DATA_REQUIRED",
                "True/False data is required for true/false questions"
            );
        }

        // Validate True/False data integrity
        var validationResult = validateTrueFalseData(command.getTrueFalseData());
        if (validationResult.isFailure()) {
            return validationResult;
        }

        try {
            // Create QuestionAggregate
            var questionAggregate = QuestionAggregate.createNew(
                command.getUserId(),
                command.getQuestionBankId(),
                command.getSourceQuestionId(),
                command.getQuestionType(),
                command.getTitle(),
                command.getContent(),
                command.getPoints()
            );

            // Set True/False-specific data
            questionAggregate.setTrueFalseData(command.getTrueFalseData());

            // Set additional properties
            setAdditionalProperties(questionAggregate, command);

            logger.debug("Successfully processed True/False question data for source ID: {}",
                        command.getSourceQuestionId());

            return Result.success(questionAggregate);

        } catch (Exception ex) {
            logger.error("Failed to process True/False question data for source ID: {}",
                        command.getSourceQuestionId(), ex);
            return Result.failure(
                "TRUE_FALSE_PROCESSING_ERROR",
                "Failed to process True/False question: " + ex.getMessage()
            );
        }
    }

    private Result<QuestionAggregate> validateTrueFalseData(TrueFalseData trueFalseData) {
        // Validate statement exists
        if (trueFalseData.getStatement() == null || trueFalseData.getStatement().trim().isEmpty()) {
            return Result.failure(
                "TRUE_FALSE_NO_STATEMENT",
                "True/False questions must have a statement"
            );
        }

        // Validate statement length
        if (trueFalseData.getStatement().length() > 1000) {
            return Result.failure(
                "TRUE_FALSE_STATEMENT_TOO_LONG",
                "True/False statement cannot exceed 1000 characters"
            );
        }

        // Validate correct answer is specified
        if (trueFalseData.getCorrectAnswer() == null) {
            return Result.failure(
                "TRUE_FALSE_NO_CORRECT_ANSWER",
                "True/False questions must specify correct answer (true or false)"
            );
        }

        // Validate explanation if provided
        if (trueFalseData.getExplanation() != null &&
            trueFalseData.getExplanation().length() > 2000) {
            return Result.failure(
                "TRUE_FALSE_EXPLANATION_TOO_LONG",
                "True/False explanation cannot exceed 2000 characters"
            );
        }

        return Result.success(null);
    }

    @Override
    public boolean supports(QuestionType type) {
        return QuestionType.TRUE_FALSE == type;
    }

    @Override
    public String getStrategyName() {
        return "True/False Strategy";
    }
}
```

---

### 5. Strategy Integration and Testing
**Estimated Effort**: 0.5 days
**Priority**: Medium
**Dependencies**: Tasks 2, 3, 4 complete

#### Tasks:
- [ ] **5.1** Create comprehensive integration tests
- [ ] **5.2** Add performance benchmarking
- [ ] **5.3** Implement strategy metrics collection
- [ ] **5.4** Add error scenario testing
- [ ] **5.5** Validate Spring configuration

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/test/java/com/quizfun/questionbank/domain/services/QuestionTypeStrategyIntegrationTest.java
@SpringBootTest
@Import(TestcontainersConfig.class)
class QuestionTypeStrategyIntegrationTest extends BaseTestConfiguration {

    @Autowired
    private QuestionTypeStrategyFactory strategyFactory;

    @Test
    @DisplayName("Should process MCQ question successfully")
    void shouldProcessMcqQuestionSuccessfully() {
        // Given
        var command = createValidMcqCommand();

        // When
        var strategy = strategyFactory.getStrategy(QuestionType.MCQ);
        var result = strategy.processQuestionData(command);

        // Then
        assertThat(result.isSuccess()).isTrue();
        var aggregate = result.getValue();
        assertThat(aggregate.getQuestionType()).isEqualTo(QuestionType.MCQ);
        assertThat(aggregate.getMcqData()).isNotNull();
        assertThat(aggregate.hasValidTypeSpecificData()).isTrue();
    }

    @Test
    @DisplayName("Should process Essay question successfully")
    void shouldProcessEssayQuestionSuccessfully() {
        // Similar test for Essay
    }

    @Test
    @DisplayName("Should process True/False question successfully")
    void shouldProcessTrueFalseQuestionSuccessfully() {
        // Similar test for True/False
    }

    @Test
    @DisplayName("Should throw exception for unsupported question type")
    void shouldThrowExceptionForUnsupportedQuestionType() {
        // Test unsupported type handling
    }
}
```

## Acceptance Criteria Summary

### Functional Requirements
- [ ] Strategy pattern implementation for MCQ, Essay, True/False question types
- [ ] Type-specific validation rules enforced for each question type
- [ ] Factory pattern auto-discovers strategies via Spring
- [ ] Comprehensive error handling with specific error codes
- [ ] Integration with QuestionAggregate creation and data setting

### Non-Functional Requirements
- [ ] Strategy processing time <50ms per question
- [ ] Memory usage <5KB per strategy instance
- [ ] Thread-safe strategy implementations
- [ ] Code coverage >90% for strategy logic

### Definition of Done
- [ ] All three strategy implementations complete and tested
- [ ] Strategy factory with auto-discovery working
- [ ] Comprehensive unit and integration tests
- [ ] Performance benchmarks established
- [ ] Error handling validated for all scenarios
- [ ] Code review completed

## Dependencies and Risks

### Dependencies
- US-002 QuestionAggregate with type-specific data setters
- UpsertQuestionCommand with all question data
- Spring component auto-discovery configuration

### Risks
- **Risk**: Strategy selection performance overhead
  **Mitigation**: Cache strategy instances and optimize factory lookup

- **Risk**: Complex validation logic in strategies
  **Mitigation**: Break down validation into smaller, testable methods

- **Risk**: Type-specific data model changes
  **Mitigation**: Clear interface contracts and comprehensive testing

## Testing Strategy

### Unit Testing
- Individual strategy validation logic
- Factory pattern behavior
- Error scenario coverage
- Type-specific business rules

### Integration Testing
- Spring auto-discovery functionality
- End-to-end strategy processing
- Performance benchmarking

### Test Data Requirements
- Valid question data for all types
- Invalid data for validation testing
- Edge cases for boundary testing
- Performance test data sets

## Technical Notes

### Design Patterns Used
- **Strategy Pattern**: Core pattern for type-specific processing
- **Factory Pattern**: Strategy selection and management
- **Template Method**: Common validation patterns across strategies

### Performance Considerations
- Strategy instance caching
- Minimal object creation during validation
- Efficient error message generation

### Security Considerations
- Input validation in all strategies
- Business rule enforcement
- Type safety in strategy selection