# WBS 1001: Command and Validation

## User Story
**As a** system integrator
**I want** a validated command object for creating default question banks
**So that** invalid requests are rejected before processing

---

## Acceptance Criteria
- [ ] Command accepts userId, userEmail, and metadata
- [ ] Command validates userId is positive and non-null
- [ ] Command validates email format (if provided)
- [ ] Command is immutable after creation
- [ ] Command implements ICommand<DefaultQuestionBankResponseDto>
- [ ] All validation errors throw IllegalArgumentException with clear messages

---

## TDD Cycle

### Epic and Story Annotation
```java
@Epic("Use Case On New User Create Default Question Bank Happy Path")
@Story("1001.command-and-validation")
```

### Test Coverage Requirements
- **Unit Tests**: 100% coverage
- **Test Count**: 8-10 tests
- **No Integration Tests**: Pure domain logic, no external dependencies

---

## Task Breakdown

### Task 1.1: RED - Write Failing Tests for Command Creation

**File**: `OnNewUserCreateDefaultQuestionBankCommandTest.java`
**Location**: `internal-layer/question-bank/src/test/java/com/quizfun/questionbank/application/commands/`

#### Test Cases to Write First

```java
package com.quizfun.questionbank.application.commands;

import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.Map;

import static org.assertj.core.api.Assertions.*;

@Epic("Use Case On New User Create Default Question Bank Happy Path")
@Story("1001.command-and-validation")
@DisplayName("OnNewUserCreateDefaultQuestionBankCommand Tests")
class OnNewUserCreateDefaultQuestionBankCommandTest {

    @Test
    @DisplayName("Should create command with valid userId")
    void shouldCreateCommandWithValidUserId() {
        // Given
        Long userId = 123456789L;

        // When
        OnNewUserCreateDefaultQuestionBankCommand command =
            new OnNewUserCreateDefaultQuestionBankCommand(userId, null, null);

        // Then
        assertThat(command.getUserId()).isEqualTo(userId);
        assertThat(command.getUserEmail()).isNull();
        assertThat(command.getMetadata()).isEmpty();
    }

    @Test
    @DisplayName("Should create command with all fields provided")
    void shouldCreateCommandWithAllFieldsProvided() {
        // Given
        Long userId = 123456789L;
        String userEmail = "test@example.com";
        Map<String, String> metadata = Map.of(
            "createdBy", "user-management-system",
            "requestId", "req-12345"
        );

        // When
        OnNewUserCreateDefaultQuestionBankCommand command =
            new OnNewUserCreateDefaultQuestionBankCommand(userId, userEmail, metadata);

        // Then
        assertThat(command.getUserId()).isEqualTo(userId);
        assertThat(command.getUserEmail()).isEqualTo(userEmail);
        assertThat(command.getMetadata()).containsEntry("createdBy", "user-management-system");
        assertThat(command.getMetadata()).containsEntry("requestId", "req-12345");
    }

    @Test
    @DisplayName("Should throw exception when userId is null")
    void shouldThrowExceptionWhenUserIdIsNull() {
        // When & Then
        assertThatThrownBy(() ->
            new OnNewUserCreateDefaultQuestionBankCommand(null, null, null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("userId cannot be null");
    }

    @Test
    @DisplayName("Should throw exception when userId is zero")
    void shouldThrowExceptionWhenUserIdIsZero() {
        // When & Then
        assertThatThrownBy(() ->
            new OnNewUserCreateDefaultQuestionBankCommand(0L, null, null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("userId must be positive");
    }

    @ParameterizedTest
    @DisplayName("Should throw exception when userId is negative")
    @ValueSource(longs = {-1L, -100L, -999999L})
    void shouldThrowExceptionWhenUserIdIsNegative(Long invalidUserId) {
        // When & Then
        assertThatThrownBy(() ->
            new OnNewUserCreateDefaultQuestionBankCommand(invalidUserId, null, null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("userId must be positive");
    }

    @Test
    @DisplayName("Should create immutable metadata map")
    void shouldCreateImmutableMetadataMap() {
        // Given
        Map<String, String> mutableMetadata = Map.of("key", "value");
        OnNewUserCreateDefaultQuestionBankCommand command =
            new OnNewUserCreateDefaultQuestionBankCommand(123L, null, mutableMetadata);

        // When & Then
        assertThatThrownBy(() ->
            command.getMetadata().put("newKey", "newValue"))
            .isInstanceOf(UnsupportedOperationException.class);
    }

    @Test
    @DisplayName("Should handle null metadata as empty map")
    void shouldHandleNullMetadataAsEmptyMap() {
        // Given & When
        OnNewUserCreateDefaultQuestionBankCommand command =
            new OnNewUserCreateDefaultQuestionBankCommand(123L, null, null);

        // Then
        assertThat(command.getMetadata()).isNotNull();
        assertThat(command.getMetadata()).isEmpty();
    }

    @Test
    @DisplayName("Should trim whitespace from userEmail")
    void shouldTrimWhitespaceFromUserEmail() {
        // Given
        String emailWithSpaces = "  test@example.com  ";

        // When
        OnNewUserCreateDefaultQuestionBankCommand command =
            new OnNewUserCreateDefaultQuestionBankCommand(123L, emailWithSpaces, null);

        // Then
        assertThat(command.getUserEmail()).isEqualTo("test@example.com");
    }

    @Test
    @DisplayName("Should validate email format if provided")
    void shouldValidateEmailFormatIfProvided() {
        // When & Then
        assertThatThrownBy(() ->
            new OnNewUserCreateDefaultQuestionBankCommand(123L, "invalid-email", null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Invalid email format");
    }

    @Test
    @DisplayName("Should allow null email")
    void shouldAllowNullEmail() {
        // When
        OnNewUserCreateDefaultQuestionBankCommand command =
            new OnNewUserCreateDefaultQuestionBankCommand(123L, null, null);

        // Then
        assertThat(command.getUserEmail()).isNull();
    }
}
```

**Expected Result**: All tests FAIL (Red phase) - Command class doesn't exist yet

---

### Task 1.2: GREEN - Implement Command Class

**File**: `OnNewUserCreateDefaultQuestionBankCommand.java`
**Location**: `internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/commands/`

```java
package com.quizfun.questionbank.application.commands;

import com.quizfun.globalshared.mediator.ICommand;
import com.quizfun.questionbank.application.dto.DefaultQuestionBankResponseDto;

import java.util.Map;
import java.util.Objects;
import java.util.regex.Pattern;

/**
 * Command for creating default question bank when a new user is registered.
 *
 * This command is sent from external user management system via HTTP POST
 * to create the initial question bank and taxonomy structure for new users.
 *
 * @see DefaultQuestionBankResponseDto
 */
public class OnNewUserCreateDefaultQuestionBankCommand
        implements ICommand<DefaultQuestionBankResponseDto> {

    private static final Pattern EMAIL_PATTERN = Pattern.compile(
        "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"
    );

    private final Long userId;
    private final String userEmail;
    private final Map<String, String> metadata;

    /**
     * Creates a new command for default question bank creation.
     *
     * @param userId The user ID (must be positive and non-null)
     * @param userEmail The user email (optional, validated if provided)
     * @param metadata Additional metadata from external system (optional)
     * @throws IllegalArgumentException if userId is null or non-positive
     * @throws IllegalArgumentException if userEmail format is invalid
     */
    public OnNewUserCreateDefaultQuestionBankCommand(
            Long userId,
            String userEmail,
            Map<String, String> metadata) {

        // Validate userId
        if (userId == null) {
            throw new IllegalArgumentException("userId cannot be null");
        }
        if (userId <= 0) {
            throw new IllegalArgumentException("userId must be positive");
        }

        // Validate and trim email
        this.userEmail = validateAndTrimEmail(userEmail);

        // Store immutable copies
        this.userId = userId;
        this.metadata = metadata != null ? Map.copyOf(metadata) : Map.of();
    }

    private String validateAndTrimEmail(String email) {
        if (email == null) {
            return null;
        }

        String trimmedEmail = email.trim();
        if (trimmedEmail.isEmpty()) {
            return null;
        }

        if (!EMAIL_PATTERN.matcher(trimmedEmail).matches()) {
            throw new IllegalArgumentException("Invalid email format: " + email);
        }

        return trimmedEmail;
    }

    /**
     * @return The user ID for whom to create default question bank
     */
    public Long getUserId() {
        return userId;
    }

    /**
     * @return The user email (may be null)
     */
    public String getUserEmail() {
        return userEmail;
    }

    /**
     * @return Immutable metadata map from external system
     */
    public Map<String, String> getMetadata() {
        return metadata;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OnNewUserCreateDefaultQuestionBankCommand that = (OnNewUserCreateDefaultQuestionBankCommand) o;
        return Objects.equals(userId, that.userId) &&
               Objects.equals(userEmail, that.userEmail) &&
               Objects.equals(metadata, that.metadata);
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, userEmail, metadata);
    }

    @Override
    public String toString() {
        return "OnNewUserCreateDefaultQuestionBankCommand{" +
               "userId=" + userId +
               ", userEmail='" + userEmail + '\'' +
               ", metadataSize=" + metadata.size() +
               '}';
    }
}
```

**Expected Result**: All tests PASS (Green phase)

---

### Task 1.3: REFACTOR - Improve Code Quality

**Refactoring Opportunities**:
1. Extract email validation to separate utility class if needed elsewhere
2. Add JSR-303 Bean Validation annotations (optional)
3. Consider builder pattern if command grows complex
4. Add more comprehensive email validation if needed

**Example Refactoring** (Optional - if email validation reused):

```java
// Extract to utility class
public class EmailValidator {
    private static final Pattern EMAIL_PATTERN = Pattern.compile(
        "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"
    );

    public static String validateAndTrim(String email) {
        // Validation logic
    }
}
```

**After Refactoring**: Re-run tests - ALL MUST STILL PASS

---

### Task 1.4: Create Response DTO

**File**: `DefaultQuestionBankResponseDto.java`
**Location**: `internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/dto/`

```java
package com.quizfun.questionbank.application.dto;

import java.time.Instant;
import java.util.List;

/**
 * Response DTO for default question bank creation.
 */
public class DefaultQuestionBankResponseDto {

    private Long userId;
    private Long questionBankId;
    private String questionBankName;
    private String description;
    private boolean isActive;
    private boolean taxonomySetCreated;
    private AvailableTaxonomy availableTaxonomy;
    private Instant createdAt;

    // Nested class for taxonomy information
    public static class AvailableTaxonomy {
        private List<CategoryInfo> categories;
        private List<TagInfo> tags;
        private List<DifficultyLevelInfo> difficultyLevels;

        // Getters, setters, constructors
    }

    public static class CategoryInfo {
        private String id;
        private String name;
        private String level;
        // Getters, setters, constructors
    }

    public static class TagInfo {
        private String id;
        private String name;
        private String color;
        // Getters, setters, constructors
    }

    public static class DifficultyLevelInfo {
        private String level;
        private Integer numericValue;
        private String description;
        // Getters, setters, constructors
    }

    // Builder pattern for easy construction
    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private final DefaultQuestionBankResponseDto dto = new DefaultQuestionBankResponseDto();

        public Builder userId(Long userId) {
            dto.userId = userId;
            return this;
        }

        public Builder questionBankId(Long questionBankId) {
            dto.questionBankId = questionBankId;
            return this;
        }

        // Other builder methods...

        public DefaultQuestionBankResponseDto build() {
            return dto;
        }
    }

    // Getters and setters
    public Long getUserId() { return userId; }
    public void setUserId(Long userId) { this.userId = userId; }

    public Long getQuestionBankId() { return questionBankId; }
    public void setQuestionBankId(Long questionBankId) { this.questionBankId = questionBankId; }

    // ... other getters/setters
}
```

---

## Definition of Done

- [x] All tests written BEFORE implementation (TDD Red phase)
- [x] Command class implemented with minimal code to pass tests (TDD Green phase)
- [x] Code refactored for quality while keeping tests green (TDD Refactor phase)
- [x] 100% line coverage for command class
- [x] All tests pass with proper Allure annotations
- [x] Command validates userId (positive, non-null)
- [x] Command validates email format if provided
- [x] Command creates immutable metadata
- [x] Response DTO created for use in next stories
- [x] No external dependencies (pure domain logic)
- [x] Javadoc comments added

---

## Dependencies
**None** - This is the foundation story

---

## Estimated Effort
**2-3 hours** (0.5 day)

---

## Testing Checklist

### Pre-Implementation (RED Phase)
- [ ] Write all 10 test cases
- [ ] Verify tests fail with compilation errors (expected)
- [ ] Review test names for clarity

### Implementation (GREEN Phase)
- [ ] Create command class
- [ ] Run tests - verify they pass
- [ ] Check coverage report (should be 100%)

### Refactoring (REFACTOR Phase)
- [ ] Review code for improvements
- [ ] Extract utilities if needed
- [ ] Re-run tests after each refactoring
- [ ] Ensure all tests still pass

### Final Verification
- [ ] Run `mvn clean test -pl internal-layer/question-bank`
- [ ] Check Allure report shows correct Epic/Story
- [ ] Verify coverage >100% for command class
- [ ] Code review ready

---

## Notes
- This story has NO integration tests (pure unit tests)
- Email validation is basic - can be enhanced later if needed
- Metadata map is intentionally simple (String -> String)
- Command is immutable by design (no setters)
