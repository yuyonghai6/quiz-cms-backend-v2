# US-008: CQRS Command Handler Implementation

## Story Overview
**As a** developer
**I want** proper CQRS command handling with mediator pattern integration
**So that** the system maintains clean separation between request handling and business logic execution

## Business Value
- Provides clean separation of concerns between HTTP layer and business logic
- Enables consistent command handling patterns across the application
- Supports mediator pattern for loose coupling between components
- Allows easy testing and debugging of command processing

## Work Breakdown Structure (WBS)

### 1. Command Structure Implementation
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: US-007 Application Service, global-shared-library mediator

#### Tasks:
- [ ] **1.1** Define UpsertQuestionCommand class implementing ICommand<T>
- [ ] **1.2** Add command data validation and integrity checks
- [ ] **1.3** Implement command data access methods
- [ ] **1.4** Add command immutability and thread safety
- [ ] **1.5** Create command builder pattern for testing

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/commands/UpsertQuestionCommand.java
public class UpsertQuestionCommand implements ICommand<QuestionResponseDto> {

    private final Long userId;
    private final Long questionBankId;
    private final String sourceQuestionId;
    private final QuestionType questionType;
    private final String title;
    private final String content;
    private final Integer points;
    private final String status;
    private final String solutionExplanation;
    private final Integer displayOrder;

    // Type-specific data
    private final McqData mcqData;
    private final EssayData essayData;
    private final TrueFalseData trueFalseData;

    // Taxonomy data
    private final TaxonomyData taxonomy;

    // Additional data
    private final List<Attachment> attachments;
    private final QuestionSettings questionSettings;
    private final QuestionMetadata metadata;

    // Constructor with validation
    public UpsertQuestionCommand(Long userId, Long questionBankId, UpsertQuestionRequestDto request) {
        // Validate required parameters
        validateRequiredParameters(userId, questionBankId, request);

        this.userId = userId;
        this.questionBankId = questionBankId;
        this.sourceQuestionId = request.getSourceQuestionId();
        this.questionType = parseQuestionType(request.getQuestionType());
        this.title = request.getTitle();
        this.content = request.getContent();
        this.points = request.getPoints();
        this.status = request.getStatus() != null ? request.getStatus() : "draft";
        this.solutionExplanation = request.getSolutionExplanation();
        this.displayOrder = request.getDisplayOrder();

        // Type-specific data
        this.mcqData = request.getMcqData();
        this.essayData = request.getEssayData();
        this.trueFalseData = request.getTrueFalseData();

        // Taxonomy data
        this.taxonomy = request.getTaxonomy();

        // Additional data
        this.attachments = request.getAttachments() != null ?
            new ArrayList<>(request.getAttachments()) : new ArrayList<>();
        this.questionSettings = request.getQuestionSettings();
        this.metadata = request.getMetadata();
    }

    private void validateRequiredParameters(Long userId, Long questionBankId, UpsertQuestionRequestDto request) {
        if (userId == null) {
            throw new IllegalArgumentException("User ID cannot be null");
        }
        if (questionBankId == null) {
            throw new IllegalArgumentException("Question bank ID cannot be null");
        }
        if (request == null) {
            throw new IllegalArgumentException("Request DTO cannot be null");
        }
        if (request.getSourceQuestionId() == null || request.getSourceQuestionId().trim().isEmpty()) {
            throw new IllegalArgumentException("Source question ID cannot be null or empty");
        }
        if (request.getQuestionType() == null || request.getQuestionType().trim().isEmpty()) {
            throw new IllegalArgumentException("Question type cannot be null or empty");
        }
    }

    private QuestionType parseQuestionType(String questionType) {
        try {
            return QuestionType.valueOf(questionType.toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new IllegalArgumentException("Invalid question type: " + questionType);
        }
    }

    // Taxonomy ID extraction method for validation chain
    public List<String> extractTaxonomyIds() {
        var ids = new ArrayList<String>();

        // Extract category IDs
        if (taxonomy != null && taxonomy.getCategories() != null) {
            var categories = taxonomy.getCategories();
            if (categories.getLevel1() != null) ids.add(categories.getLevel1().getId());
            if (categories.getLevel2() != null) ids.add(categories.getLevel2().getId());
            if (categories.getLevel3() != null) ids.add(categories.getLevel3().getId());
            if (categories.getLevel4() != null) ids.add(categories.getLevel4().getId());
        }

        // Extract tag IDs
        if (taxonomy != null && taxonomy.getTags() != null) {
            taxonomy.getTags().forEach(tag -> ids.add(tag.getId()));
        }

        // Extract quiz IDs
        if (taxonomy != null && taxonomy.getQuizzes() != null) {
            taxonomy.getQuizzes().forEach(quiz -> ids.add(quiz.getQuizId().toString()));
        }

        // Extract difficulty level
        if (taxonomy != null && taxonomy.getDifficultyLevel() != null) {
            ids.add(taxonomy.getDifficultyLevel().getLevel());
        }

        return ids;
    }

    // Command validation method
    public Result<Void> validateCommand() {
        if (title == null || title.trim().isEmpty()) {
            return Result.failure("MISSING_TITLE", "Question title is required");
        }
        if (content == null || content.trim().isEmpty()) {
            return Result.failure("MISSING_CONTENT", "Question content is required");
        }
        if (taxonomy == null) {
            return Result.failure("MISSING_TAXONOMY", "Taxonomy data is required");
        }

        return Result.success(null);
    }

    // Builder pattern for testing
    public static class Builder {
        private Long userId;
        private Long questionBankId;
        private UpsertQuestionRequestDto request;

        public Builder withUserId(Long userId) {
            this.userId = userId;
            return this;
        }

        public Builder withQuestionBankId(Long questionBankId) {
            this.questionBankId = questionBankId;
            return this;
        }

        public Builder withRequest(UpsertQuestionRequestDto request) {
            this.request = request;
            return this;
        }

        public UpsertQuestionCommand build() {
            return new UpsertQuestionCommand(userId, questionBankId, request);
        }
    }

    // Getters (all final, no setters for immutability)
    public Long getUserId() { return userId; }
    public Long getQuestionBankId() { return questionBankId; }
    public String getSourceQuestionId() { return sourceQuestionId; }
    public QuestionType getQuestionType() { return questionType; }
    public String getTitle() { return title; }
    public String getContent() { return content; }
    public Integer getPoints() { return points; }
    public String getStatus() { return status; }
    public String getSolutionExplanation() { return solutionExplanation; }
    public Integer getDisplayOrder() { return displayOrder; }
    public McqData getMcqData() { return mcqData; }
    public EssayData getEssayData() { return essayData; }
    public TrueFalseData getTrueFalseData() { return trueFalseData; }
    public TaxonomyData getTaxonomy() { return taxonomy; }
    public List<Attachment> getAttachments() { return new ArrayList<>(attachments); }
    public QuestionSettings getQuestionSettings() { return questionSettings; }
    public QuestionMetadata getMetadata() { return metadata; }
}
```

#### Acceptance Criteria:
- Command implements ICommand<QuestionResponseDto> interface from global-shared-library
- Command is immutable with all required data validation
- Taxonomy ID extraction works correctly for validation chain
- Builder pattern enables easy testing
- Command validation provides clear error messages

#### Test Requirements:
- [ ] Unit test: command creation with valid data
- [ ] Unit test: command validation failure scenarios
- [ ] Unit test: taxonomy ID extraction functionality
- [ ] Unit test: command immutability verification
- [ ] Unit test: builder pattern functionality

---

### 2. Command Handler Implementation
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 1, US-007 Application Service

#### Tasks:
- [ ] **2.1** Implement UpsertQuestionCommandHandler class
- [ ] **2.2** Add constructor injection for application service dependency
- [ ] **2.3** Implement handle() method with error handling
- [ ] **2.4** Add comprehensive logging and monitoring
- [ ] **2.5** Ensure Spring component registration

#### Implementation Details:
```java
// Location: internal-layer/orchestration-layer/src/main/java/com/quizfun/orchestrationlayer/commands/handlers/UpsertQuestionCommandHandler.java
@Service
public class UpsertQuestionCommandHandler implements ICommandHandler<UpsertQuestionCommand, QuestionResponseDto> {

    private static final Logger logger = LoggerFactory.getLogger(UpsertQuestionCommandHandler.class);

    private final QuestionApplicationService questionApplicationService;

    public UpsertQuestionCommandHandler(QuestionApplicationService questionApplicationService) {
        this.questionApplicationService = questionApplicationService;
        logger.info("UpsertQuestionCommandHandler initialized with QuestionApplicationService");
    }

    @Override
    public Result<QuestionResponseDto> handle(UpsertQuestionCommand command) {
        logger.info("Handling UpsertQuestionCommand for source question ID: {} by user: {} in question bank: {}",
                   command.getSourceQuestionId(), command.getUserId(), command.getQuestionBankId());

        try {
            // Validate command before processing
            var commandValidationResult = command.validateCommand();
            if (commandValidationResult.isFailure()) {
                logger.warn("Command validation failed for source question ID: {} with error: {}",
                           command.getSourceQuestionId(), commandValidationResult.getError());
                return Result.failure(commandValidationResult.getError());
            }

            // Delegate to application service
            var result = questionApplicationService.upsertQuestion(command);

            if (result.isSuccess()) {
                logger.info("Successfully handled UpsertQuestionCommand for source question ID: {} with operation: {}",
                           command.getSourceQuestionId(), result.getValue().getOperation());
                recordCommandSuccess(command.getQuestionType().toString());
            } else {
                logger.warn("Failed to handle UpsertQuestionCommand for source question ID: {} with error: {}",
                           command.getSourceQuestionId(), result.getError());
                recordCommandFailure(command.getQuestionType().toString(), result.getError());
            }

            return result;

        } catch (Exception ex) {
            logger.error("Unexpected error while handling UpsertQuestionCommand for source question ID: {}",
                        command.getSourceQuestionId(), ex);

            recordCommandError(command.getQuestionType().toString(), ex.getClass().getSimpleName());

            return Result.failure("COMMAND_HANDLER_ERROR",
                                 "Unexpected error in command handler: " + ex.getMessage());
        }
    }

    private void recordCommandSuccess(String questionType) {
        // Metrics recording for monitoring - implementation depends on monitoring framework
        logger.debug("Recording command success for question type: {}", questionType);
    }

    private void recordCommandFailure(String questionType, String error) {
        // Metrics recording for monitoring
        logger.debug("Recording command failure for question type: {} with error: {}", questionType, error);
    }

    private void recordCommandError(String questionType, String exceptionType) {
        // Metrics recording for monitoring
        logger.debug("Recording command error for question type: {} with exception: {}", questionType, exceptionType);
    }
}
```

#### Acceptance Criteria:
- Handler implements ICommandHandler<UpsertQuestionCommand, QuestionResponseDto>
- Constructor injection used for QuestionApplicationService dependency
- Command validation executed before delegation
- Comprehensive logging for debugging and monitoring
- Error handling maintains consistent Result<T> pattern

#### Test Requirements:
- [ ] Unit test: successful command handling
- [ ] Unit test: command validation failure handling
- [ ] Unit test: application service delegation
- [ ] Unit test: error scenario handling
- [ ] Unit test: logging verification

---

### 3. Mediator Integration Configuration
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 2, global-shared-library mediator

#### Tasks:
- [ ] **3.1** Configure command handler registration with mediator
- [ ] **3.2** Verify automatic handler discovery via Spring
- [ ] **3.3** Add mediator configuration validation
- [ ] **3.4** Test command routing functionality
- [ ] **3.5** Add debugging support for mediator operations

#### Implementation Details:
```java
// Location: internal-layer/orchestration-layer/src/main/java/com/quizfun/orchestrationlayer/configuration/MediatorConfig.java
@Configuration
public class MediatorConfig {

    private static final Logger logger = LoggerFactory.getLogger(MediatorConfig.class);

    @Bean
    public IMediator mediator(ApplicationContext applicationContext) {
        var mediator = new MediatorImpl(applicationContext);

        // Verify handler registration
        verifyHandlerRegistration(mediator);

        return mediator;
    }

    private void verifyHandlerRegistration(MediatorImpl mediator) {
        try {
            // Verify UpsertQuestionCommandHandler is registered
            var handlerCount = mediator.getRegisteredHandlerCount();
            logger.info("Mediator initialized with {} registered handlers", handlerCount);

            // Verify specific handler registration
            var hasUpsertHandler = mediator.hasHandlerFor(UpsertQuestionCommand.class);
            if (hasUpsertHandler) {
                logger.info("UpsertQuestionCommandHandler successfully registered with mediator");
            } else {
                logger.error("UpsertQuestionCommandHandler NOT registered with mediator");
                throw new IllegalStateException("Required command handler not registered");
            }

        } catch (Exception ex) {
            logger.error("Failed to verify mediator handler registration", ex);
            throw new IllegalStateException("Mediator configuration failed", ex);
        }
    }

    @EventListener(ApplicationReadyEvent.class)
    public void logMediatorStatus() {
        logger.info("Application ready - mediator configuration complete");
    }
}
```

#### Spring Configuration for Cross-Module Scanning:
```java
// Update to orchestration-layer main application class
@SpringBootApplication(scanBasePackages = {
    "com.quizfun.orchestrationlayer",
    "com.quizfun.internallayer",
    "com.quizfun.globalshared",
    "com.quizfun.questionbank"  // Add question-bank module scanning
})
@EnableTransactionManagement
public class OrchestrationLayerApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrchestrationLayerApplication.class, args);
    }
}
```

#### Acceptance Criteria:
- Mediator automatically discovers and registers UpsertQuestionCommandHandler
- Command routing works correctly through mediator
- Cross-module Spring component scanning configured
- Handler registration validation prevents startup failures
- Comprehensive logging for mediator operations

#### Test Requirements:
- [ ] Integration test: mediator handler registration
- [ ] Integration test: command routing through mediator
- [ ] Integration test: Spring configuration loading
- [ ] Unit test: mediator configuration validation

---

### 4. Response DTO Implementation
**Estimated Effort**: 0.25 days
**Priority**: Medium
**Dependencies**: Task 3 complete

#### Tasks:
- [ ] **4.1** Define QuestionResponseDto structure
- [ ] **4.2** Add JSON serialization annotations
- [ ] **4.3** Implement builder pattern for response creation
- [ ] **4.4** Add response validation methods
- [ ] **4.5** Create response mapping utilities

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/dto/QuestionResponseDto.java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class QuestionResponseDto {

    @JsonProperty("question_id")
    private final String questionId;

    @JsonProperty("source_question_id")
    private final String sourceQuestionId;

    @JsonProperty("operation")
    private final String operation;

    @JsonProperty("taxonomy_relationships_count")
    private final Integer taxonomyRelationshipsCount;

    @JsonProperty("question_type")
    private final String questionType;

    @JsonProperty("title")
    private final String title;

    @JsonProperty("status")
    private final String status;

    @JsonProperty("created_at")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
    private final Instant createdAt;

    @JsonProperty("updated_at")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
    private final Instant updatedAt;

    private QuestionResponseDto(Builder builder) {
        this.questionId = builder.questionId;
        this.sourceQuestionId = builder.sourceQuestionId;
        this.operation = builder.operation;
        this.taxonomyRelationshipsCount = builder.taxonomyRelationshipsCount;
        this.questionType = builder.questionType;
        this.title = builder.title;
        this.status = builder.status;
        this.createdAt = builder.createdAt;
        this.updatedAt = builder.updatedAt;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private String questionId;
        private String sourceQuestionId;
        private String operation;
        private Integer taxonomyRelationshipsCount;
        private String questionType;
        private String title;
        private String status;
        private Instant createdAt;
        private Instant updatedAt;

        public Builder questionId(String questionId) {
            this.questionId = questionId;
            return this;
        }

        public Builder sourceQuestionId(String sourceQuestionId) {
            this.sourceQuestionId = sourceQuestionId;
            return this;
        }

        public Builder operation(String operation) {
            this.operation = operation;
            return this;
        }

        public Builder taxonomyRelationshipsCount(Integer count) {
            this.taxonomyRelationshipsCount = count;
            return this;
        }

        public Builder questionType(String questionType) {
            this.questionType = questionType;
            return this;
        }

        public Builder title(String title) {
            this.title = title;
            return this;
        }

        public Builder status(String status) {
            this.status = status;
            return this;
        }

        public Builder createdAt(Instant createdAt) {
            this.createdAt = createdAt;
            return this;
        }

        public Builder updatedAt(Instant updatedAt) {
            this.updatedAt = updatedAt;
            return this;
        }

        public QuestionResponseDto build() {
            validateRequiredFields();
            return new QuestionResponseDto(this);
        }

        private void validateRequiredFields() {
            if (questionId == null || questionId.trim().isEmpty()) {
                throw new IllegalArgumentException("Question ID is required");
            }
            if (sourceQuestionId == null || sourceQuestionId.trim().isEmpty()) {
                throw new IllegalArgumentException("Source question ID is required");
            }
            if (operation == null || operation.trim().isEmpty()) {
                throw new IllegalArgumentException("Operation type is required");
            }
        }
    }

    // Getters
    public String getQuestionId() { return questionId; }
    public String getSourceQuestionId() { return sourceQuestionId; }
    public String getOperation() { return operation; }
    public Integer getTaxonomyRelationshipsCount() { return taxonomyRelationshipsCount; }
    public String getQuestionType() { return questionType; }
    public String getTitle() { return title; }
    public String getStatus() { return status; }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }
}
```

#### Acceptance Criteria:
- Response DTO structure matches API specification
- JSON serialization configured correctly
- Builder pattern enables flexible response creation
- Response validation prevents invalid responses
- Immutable response structure

#### Test Requirements:
- [ ] Unit test: response DTO creation with builder
- [ ] Unit test: JSON serialization/deserialization
- [ ] Unit test: response validation
- [ ] Unit test: builder pattern validation

---

### 5. Integration Testing and Validation
**Estimated Effort**: 0.5 days
**Priority**: Medium
**Dependencies**: All previous tasks complete

#### Tasks:
- [ ] **5.1** Create comprehensive CQRS integration tests
- [ ] **5.2** Test mediator command routing end-to-end
- [ ] **5.3** Validate error propagation through CQRS layers
- [ ] **5.4** Add performance testing for command handling
- [ ] **5.5** Verify Spring configuration integration

#### Implementation Details:
```java
// Location: internal-layer/orchestration-layer/src/test/java/com/quizfun/orchestrationlayer/cqrs/CqrsIntegrationTest.java
@SpringBootTest
@Import(TestcontainersConfig.class)
class CqrsIntegrationTest extends BaseTestConfiguration {

    @Autowired
    private IMediator mediator;

    @Test
    @Epic("Question Management")
    @Feature("CQRS Command Handling")
    @Story("CQRS Command Handler Implementation")
    @DisplayName("Should handle UpsertQuestionCommand through mediator successfully")
    void shouldHandleUpsertQuestionCommandThroughMediatorSuccessfully() {
        // Given
        var command = createValidUpsertQuestionCommand();

        // When
        var result = mediator.send(command);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.isSuccess()).isTrue();

        var response = result.getValue();
        assertThat(response.getQuestionId()).isNotNull();
        assertThat(response.getSourceQuestionId()).isEqualTo(command.getSourceQuestionId());
        assertThat(response.getOperation()).isIn("created", "updated");
        assertThat(response.getTaxonomyRelationshipsCount()).isGreaterThan(0);
    }

    @Test
    @DisplayName("Should propagate validation errors through CQRS layers")
    void shouldPropagateValidationErrorsThroughCqrsLayers() {
        // Given
        var invalidCommand = createInvalidUpsertQuestionCommand();

        // When
        var result = mediator.send(invalidCommand);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.isSuccess()).isFalse();
        assertThat(result.getError()).isNotNull();
    }

    @Test
    @DisplayName("Should handle command processing errors gracefully")
    void shouldHandleCommandProcessingErrorsGracefully() {
        // Given
        var command = createCommandThatWillCauseError();

        // When
        var result = mediator.send(command);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.isSuccess()).isFalse();
        assertThat(result.getError()).contains("error message");
    }

    private UpsertQuestionCommand createValidUpsertQuestionCommand() {
        var request = createValidMcqRequest();
        return new UpsertQuestionCommand.Builder()
            .withUserId(3L)
            .withQuestionBankId(123L)
            .withRequest(request)
            .build();
    }
}
```

#### Acceptance Criteria:
- Complete CQRS workflow tested end-to-end
- Mediator command routing verified
- Error propagation through all layers confirmed
- Performance benchmarks established
- Spring configuration integration validated

#### Test Requirements:
- [ ] Integration test: complete CQRS workflow
- [ ] Integration test: mediator command routing
- [ ] Integration test: error propagation
- [ ] Performance test: command handling throughput
- [ ] Integration test: Spring configuration loading

---

## Acceptance Criteria Summary

### Functional Requirements
- [ ] UpsertQuestionCommand implements ICommand<QuestionResponseDto> interface
- [ ] UpsertQuestionCommandHandler implements ICommandHandler interface with proper delegation
- [ ] Mediator integration routes commands to correct handlers automatically
- [ ] Command and response DTOs provide clean data contracts
- [ ] Error handling maintains Result<T> pattern throughout CQRS layers

### Non-Functional Requirements
- [ ] Command handling time <50ms overhead over application service
- [ ] Memory usage <20MB for command processing
- [ ] Thread-safe command and handler implementations
- [ ] Code coverage >90% for CQRS components

### Definition of Done
- [ ] Command and command handler implemented and tested
- [ ] Mediator integration working correctly
- [ ] Response DTOs with proper JSON serialization
- [ ] Comprehensive error handling for all scenarios
- [ ] Integration tests covering complete CQRS workflow
- [ ] Performance benchmarks established
- [ ] Code review completed

## Dependencies and Risks

### Dependencies
- global-shared-library mediator implementation
- US-007 QuestionApplicationService complete
- Spring configuration for cross-module scanning
- ICommand and ICommandHandler interfaces

### Risks
- **Risk**: Mediator configuration complexity across modules
  **Mitigation**: Comprehensive configuration validation and testing

- **Risk**: Command routing performance overhead
  **Mitigation**: Performance testing and optimization

- **Risk**: Error handling consistency across CQRS layers
  **Mitigation**: Standardized Result<T> pattern usage

## Testing Strategy

### Unit Testing
- Command creation and validation
- Command handler delegation logic
- Response DTO creation and serialization
- Error scenario handling

### Integration Testing
- Complete CQRS workflow with mediator
- Cross-module Spring configuration
- Error propagation through all layers
- Performance under load

### Test Data Requirements
- Valid command data for all question types
- Invalid command data for error scenarios
- Performance test datasets
- Complex taxonomy scenarios

## Technical Notes

### Design Patterns Used
- **Command Pattern**: CQRS command implementation
- **Mediator Pattern**: Loose coupling between layers
- **Builder Pattern**: Command and response creation
- **Dependency Injection**: Spring-managed dependencies

### Performance Considerations
- Minimal object creation in command handling
- Efficient mediator routing algorithms
- Command validation optimization
- Response serialization performance

### Security Considerations
- Command validation prevents malicious data
- User context maintained through command processing
- No sensitive data exposure in responses
- Comprehensive audit logging for command processing