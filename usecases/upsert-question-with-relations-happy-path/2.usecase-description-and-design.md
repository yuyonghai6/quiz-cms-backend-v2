# Use Case Description and Design - Upsert Question with Taxonomies

## Use Case Definition

### Primary Goal
Enable content creators to create or update questions with complex taxonomy relationships in their question banks through a single HTTP operation.

### Primary Actor
- Content creator/educator with question bank access

### Preconditions
- User is authenticated and authorized (can disable and bypass this part in Spring Security at this moment)
- Target question bank exists and belongs to user (need test data loader to achieve it)
- Request contains structurally valid JSON

### Success Criteria
- Question is created (if source_question_id doesn't exist) or updated (if exists)
- All taxonomy relationships are properly established
- Response contains question ID and operation type (created/updated)

### Business Rules
- **Upsert Logic**: Use `source_question_id` to determine INSERT vs UPDATE
- **Taxonomy Validation**: All referenced taxonomy IDs must exist in user's taxonomy_sets
- **Bank Ownership**: User can only modify questions in their own question banks
- **Data Integrity**: Question type must match the provided type-specific data (mcq_data, essay_data, etc.)

## API Specification

### HTTP Endpoint
```
POST /api/users/{userId}/questionbanks/{questionbankId}/questions
Content-Type: application/json
```

### Path Parameters
- `userId`: User identifier (extracted from authentication context)
- `questionbankId`: Target question bank identifier

### Request Payload Structure
Based on the cleaned JSON (user_id and question_bank_id removed as per Option A):

```json
{
  "source_question_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "question_type": "mcq",
  "title": "JavaScript Array Methods",
  "content": "<p>Which method adds elements to the <strong>end</strong> of an array?</p>",

  "taxonomy": {
    "categories": {
      "level_1": {
        "id": "tech",
        "name": "Technology",
        "slug": "technology",
        "parent_id": null
      },
      "level_2": {
        "id": "prog",
        "name": "Programming",
        "slug": "programming",
        "parent_id": "tech"
      },
      "level_3": {
        "id": "web_dev",
        "name": "Web Development",
        "slug": "web-development",
        "parent_id": "prog"
      },
      "level_4": {
        "id": "javascript",
        "name": "JavaScript",
        "slug": "javascript",
        "parent_id": "web_dev"
      }
    },
    "tags": [...],
    "quizzes": [...],
    "difficulty_level": {...}
  },

  "points": 5,
  "solution_explanation": "<p>The <code>push()</code> method...</p>",
  "status": "draft",
  "display_order": 1,
  "attachments": [...],

  // Type-specific data (strategy pattern)
  "mcq_data": {...},
  "true_false_data": {...},
  "essay_data": {...},

  "question_settings": {...},
  "metadata": {...}
}
```

### Response Format
```json
{
  "status": "success",
  "data": {
    "question_id": "507f1f77bcf86cd799439014",
    "source_question_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "operation": "created|updated",
    "taxonomy_relationships_count": 8
  },
  "timestamp": "2025-09-13T10:30:00Z"
}
```

## Domain Design

### Aggregate Identification and Responsibilities

#### 1. QuestionAggregate (Primary Aggregate)
```java
public class QuestionAggregate extends AggregateRoot {
    private ObjectId id;
    private Long userId;
    private Long questionBankId;
    private String sourceQuestionId;
    private QuestionType questionType;
    private String title;
    private String content;
    // ... other fields

    // Business methods
    public static QuestionAggregate createNew(UpsertQuestionCommand command) {
        var aggregate = new QuestionAggregate();
        // Apply business rules
        aggregate.addDomainEvent(new QuestionCreatedEvent(...));
        return aggregate;
    }

    public void updateFrom(UpsertQuestionCommand command) {
        // Apply update business rules
        this.addDomainEvent(new QuestionUpdatedEvent(...));
    }
}
```

**Responsibilities**:
- Question content lifecycle management
- Business rule enforcement for question data
- Domain event generation
- Version control and audit trail

#### 2. TaxonomySetAggregate (Supporting Aggregate)
```java
public class TaxonomySetAggregate extends AggregateRoot {
    private Long userId;
    private Long questionBankId;
    private Map<String, CategoryLevel> categories;
    private List<Tag> tags;
    private List<Quiz> quizzes;
    private DifficultyLevel currentDifficultyLevel;

    // Validation methods
    public boolean validateTaxonomyReferences(List<String> taxonomyIds) {
        // Validate all referenced taxonomy IDs exist
    }
}
```

**Responsibilities**:
- Taxonomy reference validation
- Taxonomy structure integrity
- Category hierarchy validation

#### 3. QuestionTaxonomyRelationshipAggregate (Supporting Aggregate)
```java
public class QuestionTaxonomyRelationshipAggregate extends AggregateRoot {
    private Long userId;
    private Long questionBankId;
    private ObjectId questionId;
    private String taxonomyType;
    private String taxonomyId;

    public static List<QuestionTaxonomyRelationshipAggregate> createFromCommand(
        ObjectId questionId, UpsertQuestionCommand command) {
        // Create multiple relationship aggregates
    }
}
```

**Responsibilities**:
- Many-to-many relationship management
- Relationship integrity enforcement
- Bulk relationship operations

#### 4. QuestionBanksPerUserAggregate (Supporting Aggregate)
```java
public class QuestionBanksPerUserAggregate extends AggregateRoot {
    private Long userId;
    private Long defaultQuestionBankId;
    private List<QuestionBank> questionBanks;

    public boolean validateOwnership(Long userId, Long questionBankId) {
        // Validate user owns the question bank
    }
}
```

**Responsibilities**:
- Question bank ownership validation
- User isolation enforcement
- Default bank management

## Design Pattern Implementation

### 1. Chain of Responsibility (Validation)

```java
public abstract class ValidationHandler {
    protected ValidationHandler next;

    public ValidationHandler setNext(ValidationHandler handler) {
        this.next = handler;
        return handler;
    }

    public abstract Result<Void> validate(UpsertQuestionCommand command);

    protected Result<Void> checkNext(UpsertQuestionCommand command) {
        if (next == null) {
            return Result.success(null);
        }
        return next.validate(command);
    }
}

// Concrete validators
@Component
public class QuestionBankOwnershipValidator extends ValidationHandler {

    private final QuestionBanksPerUserRepository repository;

    @Override
    public Result<Void> validate(UpsertQuestionCommand command) {
        if (!repository.validateOwnership(command.getUserId(), command.getQuestionBankId())) {
            return Result.failure("User doesn't own the question bank");
        }
        return checkNext(command);
    }
}

@Component
public class TaxonomyReferenceValidator extends ValidationHandler {

    private final TaxonomySetRepository repository;

    @Override
    public Result<Void> validate(UpsertQuestionCommand command) {
        var taxonomyIds = extractTaxonomyIds(command);
        if (!repository.validateTaxonomyReferences(
            command.getUserId(),
            command.getQuestionBankId(),
            taxonomyIds)) {
            return Result.failure("Invalid taxonomy references");
        }
        return checkNext(command);
    }
}

// Chain setup
@Configuration
public class ValidationChainConfig {

    @Bean
    public ValidationHandler validationChain(
        QuestionBankOwnershipValidator ownershipValidator,
        TaxonomyReferenceValidator taxonomyValidator,
        QuestionDataIntegrityValidator dataValidator) {

        ownershipValidator
            .setNext(taxonomyValidator)
            .setNext(dataValidator);

        return ownershipValidator;
    }
}
```

### 2. Strategy Pattern (Question Types)

```java
public interface QuestionTypeStrategy {
    Result<QuestionAggregate> processQuestionData(UpsertQuestionCommand command);
    boolean supports(QuestionType type);
}

@Component
public class McqQuestionStrategy implements QuestionTypeStrategy {

    @Override
    public Result<QuestionAggregate> processQuestionData(UpsertQuestionCommand command) {
        // Validate MCQ-specific data
        if (command.getMcqData() == null) {
            return Result.failure("MCQ data is required for MCQ questions");
        }

        // Process MCQ-specific logic
        var aggregate = QuestionAggregate.createNew(command);
        aggregate.setMcqData(command.getMcqData());
        return Result.success(aggregate);
    }

    @Override
    public boolean supports(QuestionType type) {
        return type == QuestionType.MCQ;
    }
}

@Component
public class EssayQuestionStrategy implements QuestionTypeStrategy {
    // Similar implementation for essay questions
}

@Component
public class TrueFalseQuestionStrategy implements QuestionTypeStrategy {
    // Similar implementation for true/false questions
}

@Component
public class QuestionTypeStrategyFactory {

    private final List<QuestionTypeStrategy> strategies;

    public QuestionTypeStrategy getStrategy(QuestionType type) {
        return strategies.stream()
            .filter(strategy -> strategy.supports(type))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Unsupported question type: " + type));
    }
}
```

## Application Service Design

### Core Application Service
```java
@Service
@Transactional
public class QuestionApplicationService {

    private final ValidationHandler validationChain;
    private final QuestionTypeStrategyFactory strategyFactory;
    private final QuestionRepository questionRepository;
    private final QuestionTaxonomyRelationshipRepository relationshipRepository;

    public QuestionApplicationService(
        ValidationHandler validationChain,
        QuestionTypeStrategyFactory strategyFactory,
        QuestionRepository questionRepository,
        QuestionTaxonomyRelationshipRepository relationshipRepository) {

        this.validationChain = validationChain;
        this.strategyFactory = strategyFactory;
        this.questionRepository = questionRepository;
        this.relationshipRepository = relationshipRepository;
    }

    public Result<QuestionResponseDto> upsertQuestion(UpsertQuestionCommand command) {
        try {
            // 1. Validate using Chain of Responsibility
            var validationResult = validationChain.validate(command);
            if (validationResult.isFailure()) {
                return Result.failure(validationResult.getError());
            }

            // 2. Process question using Strategy Pattern
            var strategy = strategyFactory.getStrategy(command.getQuestionType());
            var questionAggregateResult = strategy.processQuestionData(command);
            if (questionAggregateResult.isFailure()) {
                return Result.failure(questionAggregateResult.getError());
            }

            // 3. Instantiate QuestionAggregate object and store to MongoDB
            var questionAggregate = questionAggregateResult.getValue();
            var questionResult = questionRepository.upsertBySourceQuestionId(questionAggregate);

            // 4. Instantiate QuestionTaxonomyRelationshipAggregate objects
            var relationships = QuestionTaxonomyRelationshipAggregate.createFromCommand(
                questionResult.getId(), command);

            // 5. Insert multiple relationship documents to MongoDB
            relationshipRepository.replaceRelationshipsForQuestion(
                questionResult.getId(), relationships);

            // 6. Return success response
            return Result.success(mapToResponseDto(questionResult));

        } catch (Exception ex) {
            return Result.failure("Database operation failed: " + ex.getMessage());
        }
    }

    private QuestionResponseDto mapToResponseDto(QuestionAggregate aggregate) {
        return QuestionResponseDto.builder()
            .questionId(aggregate.getId().toString())
            .sourceQuestionId(aggregate.getSourceQuestionId())
            .operation(aggregate.isNew() ? "created" : "updated")
            .build();
    }
}
```

## Repository Interface Design

### Port OUT Interfaces (Domain Layer)

```java
public interface QuestionRepository {
    Result<QuestionAggregate> upsertBySourceQuestionId(QuestionAggregate aggregate);
    Optional<QuestionAggregate> findBySourceQuestionId(Long userId, Long questionBankId, String sourceQuestionId);
}

public interface QuestionTaxonomyRelationshipRepository {
    void replaceRelationshipsForQuestion(ObjectId questionId, List<QuestionTaxonomyRelationshipAggregate> relationships);
    List<QuestionTaxonomyRelationshipAggregate> findByQuestionId(ObjectId questionId);
}

public interface TaxonomySetRepository {
    boolean validateTaxonomyReferences(Long userId, Long questionBankId, List<String> taxonomyIds);
    Optional<TaxonomySetAggregate> findByUserAndQuestionBank(Long userId, Long questionBankId);
}

public interface QuestionBanksPerUserRepository {
    boolean validateOwnership(Long userId, Long questionBankId);
    Optional<QuestionBanksPerUserAggregate> findByUserId(Long userId);
}
```

### Implementation Classes (Infrastructure Layer)

```java
@Repository
public class MongoQuestionRepository implements QuestionRepository {

    private final MongoTemplate mongoTemplate;

    @Override
    public Result<QuestionAggregate> upsertBySourceQuestionId(QuestionAggregate aggregate) {
        try {
            // Check if question exists
            var query = Query.query(Criteria
                .where("user_id").is(aggregate.getUserId())
                .and("question_bank_id").is(aggregate.getQuestionBankId())
                .and("source_question_id").is(aggregate.getSourceQuestionId()));

            var existingQuestion = mongoTemplate.findOne(query, QuestionDocument.class, "questions");

            if (existingQuestion != null) {
                // Update existing
                aggregate.setId(existingQuestion.getId());
                aggregate.updateTimestamp();
            } else {
                // Create new
                aggregate.setCreationTimestamp();
            }

            var document = QuestionDocument.fromAggregate(aggregate);
            var savedDocument = mongoTemplate.save(document, "questions");

            return Result.success(savedDocument.toAggregate());

        } catch (Exception ex) {
            return Result.failure("Failed to upsert question: " + ex.getMessage());
        }
    }
}
```

## Error Handling Design

### Error Classification
```java
public enum QuestionUpsertErrorCode {
    // Validation Errors (400)
    INVALID_JSON_STRUCTURE("Invalid JSON structure"),
    MISSING_REQUIRED_FIELD("Required field is missing"),
    INVALID_QUESTION_TYPE("Invalid question type"),
    TYPE_DATA_MISMATCH("Question type doesn't match provided data"),

    // Business Rule Violations (422)
    TAXONOMY_REFERENCE_NOT_FOUND("Taxonomy reference not found"),
    QUESTION_BANK_NOT_FOUND("Question bank not found"),
    UNAUTHORIZED_ACCESS("User doesn't own the question bank"),
    DUPLICATE_SOURCE_QUESTION_ID("Source question ID already exists"),

    // System Errors (500)
    DATABASE_ERROR("Database operation failed"),
    TRANSACTION_FAILED("Transaction failed");
}
```

### Error Response Structure
```java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    private String status = "error";
    private String errorCode;
    private String message;
    private Map<String, Object> details;
    private Instant timestamp;

    public static ErrorResponse of(QuestionUpsertErrorCode errorCode, String message) {
        return ErrorResponse.builder()
            .errorCode(errorCode.name())
            .message(message)
            .timestamp(Instant.now())
            .build();
    }
}
```

## Transaction Management

### ACID Compliance Strategy
```java
@Transactional(
    isolation = Isolation.READ_COMMITTED,
    propagation = Propagation.REQUIRED,
    rollbackFor = Exception.class
)
public Result<QuestionResponseDto> upsertQuestion(UpsertQuestionCommand command) {
    // All operations within single transaction:
    // 1. Question upsert
    // 2. Relationship replacement
    // Automatic rollback on any exception
}
```

### MongoDB Transaction Configuration
```java
@Configuration
public class MongoTransactionConfig {

    @Bean
    public MongoTransactionManager transactionManager(MongoDatabaseFactory factory) {
        return new MongoTransactionManager(factory);
    }
}
```

This design ensures clean separation of concerns, maintainable code structure, and adherence to DDD principles while implementing the requested design patterns effectively.