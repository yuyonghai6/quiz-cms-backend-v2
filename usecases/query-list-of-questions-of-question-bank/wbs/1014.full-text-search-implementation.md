# User Story 1014: Full-Text Search Implementation

## User Story

**As a** backend developer
**I want** to implement full-text search on question content using MongoDB text indexes
**So that** users can search questions by keywords and phrases in the question text

## Acceptance Criteria

- [ ] MongoDB text index created on `question_text` field
- [ ] Repository supports text search with `searchText` parameter
- [ ] Text search works case-insensitively
- [ ] Text search works with partial word matching
- [ ] Text search works with multiple keywords (AND logic for all words)
- [ ] Text search can be combined with taxonomy filters
- [ ] Search results are scored by relevance (text score)
- [ ] Integration tests verify text search functionality
- [ ] All tests pass with JaCoCo coverage > 70%
- [ ] Allure annotations correctly applied

---

## TDD Cycle

### Allure Annotations Format

```java
@Epic("Use Case Query List of Questions of Question Bank")
@Story("1014.full-text-search-implementation")
```

---

## Phase 1: RED (Write Failing Tests)

### Objective
Write failing tests for full-text search functionality.

### Tasks

#### Task 1.1: Create Text Search Integration Tests

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/infrastructure/persistence/repositories/MongoQuestionQueryRepositoryTextSearchTest.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.repositories;

import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.ports.out.IQuestionQueryRepository;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.index.TextIndexDefinition;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MongoDBContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.Instant;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1014.full-text-search-implementation")
@Testcontainers
@SpringBootTest
@DisplayName("Text Search Integration Tests")
class MongoQuestionQueryRepositoryTextSearchTest {

    @Container
    static MongoDBContainer mongoContainer = new MongoDBContainer("mongo:8.0")
            .withExposedPorts(27018)
            .withReuse(false);

    @DynamicPropertySource
    static void mongoProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoContainer::getReplicaSetUrl);
        registry.add("spring.data.mongodb.read-preference", () -> "primary");
    }

    @Autowired
    private MongoTemplate mongoTemplate;

    @Autowired
    private IQuestionQueryRepository questionQueryRepository;

    private static final Long TEST_USER_ID = 12345L;
    private static final Long TEST_QUESTION_BANK_ID = 67890L;
    private static final String COLLECTION_NAME = "questions";

    @BeforeEach
    void setUp() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
        mongoTemplate.createCollection(COLLECTION_NAME);

        // Create text index on question_text field
        TextIndexDefinition textIndex = TextIndexDefinition.builder()
                .onField("question_text")
                .build();
        mongoTemplate.indexOps(COLLECTION_NAME).ensureIndex(textIndex);

        insertTestQuestionsForTextSearch();
    }

    @AfterEach
    void tearDown() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
    }

    @Test
    @DisplayName("Should search questions by single keyword")
    void shouldSearchQuestionsBySingleKeyword() {
        // GIVEN: Request with search text "equation"
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("equation")
                .page(0)
                .size(10)
                .build();

        // WHEN: Searching questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions containing "equation"
        assertThat(results).hasSize(2);
        assertThat(results).extracting(QuestionDTO::questionText)
                .allMatch(text -> text.toLowerCase().contains("equation"));
    }

    @Test
    @DisplayName("Should search questions case-insensitively")
    void shouldSearchQuestionsCaseInsensitively() {
        // GIVEN: Request with uppercase search text
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("CAPITAL")
                .page(0)
                .size(10)
                .build();

        // WHEN: Searching questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions with "capital" (case-insensitive)
        assertThat(results).hasSize(1);
        assertThat(results.getFirst().questionText()).containsIgnoringCase("capital");
    }

    @Test
    @DisplayName("Should search questions with multiple keywords (AND logic)")
    void shouldSearchQuestionsWithMultipleKeywords() {
        // GIVEN: Request with multiple search keywords
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("solve equation")
                .page(0)
                .size(10)
                .build();

        // WHEN: Searching questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions containing BOTH words
        assertThat(results).hasSize(1);
        assertThat(results.getFirst().questionText()).contains("Solve");
        assertThat(results.getFirst().questionText()).contains("equation");
    }

    @Test
    @DisplayName("Should search questions with partial word matching")
    void shouldSearchQuestionsWithPartialWordMatching() {
        // GIVEN: Request with partial word
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("calc")
                .page(0)
                .size(10)
                .build();

        // WHEN: Searching questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions with "calculate" or "calculation"
        assertThat(results).isNotEmpty();
        assertThat(results).extracting(QuestionDTO::questionText)
                .anyMatch(text -> text.toLowerCase().contains("calc"));
    }

    @Test
    @DisplayName("Should return empty list when search text matches nothing")
    void shouldReturnEmptyListWhenSearchTextMatchesNothing() {
        // GIVEN: Request with non-matching search text
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("xyzabc123")
                .page(0)
                .size(10)
                .build();

        // WHEN: Searching questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return empty list
        assertThat(results).isEmpty();
    }

    @Test
    @DisplayName("Should combine text search with category filter")
    void shouldCombineTextSearchWithCategoryFilter() {
        // GIVEN: Request with search text and category
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("equation")
                .categories(List.of("Math"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Searching with combined filters
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions matching BOTH filters
        assertThat(results).hasSize(1);
        assertThat(results.getFirst().questionText()).contains("equation");
        assertThat(results.getFirst().taxonomy().categories()).contains("Math");
    }

    @Test
    @DisplayName("Should combine text search with tag filter")
    void shouldCombineTextSearchWithTagFilter() {
        // GIVEN: Request with search text and tag
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("circle")
                .tags(List.of("geometry"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Searching with combined filters
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions matching BOTH filters
        assertThat(results).hasSize(1);
        assertThat(results.getFirst().questionText()).containsIgnoringCase("circle");
        assertThat(results.getFirst().taxonomy().tags()).contains("geometry");
    }

    @Test
    @DisplayName("Should combine text search with all taxonomy filters")
    void shouldCombineTextSearchWithAllTaxonomyFilters() {
        // GIVEN: Request with search text and all taxonomy filters
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("equation")
                .categories(List.of("Math"))
                .tags(List.of("algebra"))
                .quizzes(List.of("midterm-2024"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Searching with all filters
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions matching ALL filters
        assertThat(results).hasSize(1);
        assertThat(results.getFirst().questionText()).contains("equation");
    }

    @Test
    @DisplayName("Should ignore empty search text")
    void shouldIgnoreEmptySearchText() {
        // GIVEN: Request with empty search text
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("")
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return all questions (no text filtering)
        assertThat(results).hasSize(5); // All test questions
    }

    @Test
    @DisplayName("Should work with pagination when searching")
    void shouldWorkWithPaginationWhenSearching() {
        // GIVEN: Request with search text and pagination
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("question")
                .page(0)
                .size(2)
                .build();

        // WHEN: Querying first page
        List<QuestionDTO> page1 = questionQueryRepository.queryQuestions(request);

        // THEN: Should return paginated results
        assertThat(page1).hasSize(2);

        // AND: Second page should have different results
        QueryQuestionsRequest request2 = request.toBuilder().page(1).build();
        List<QuestionDTO> page2 = questionQueryRepository.queryQuestions(request2);
        assertThat(page2).isNotEmpty();
        assertThat(page2.getFirst().questionId()).isNotEqualTo(page1.getFirst().questionId());
    }

    @Test
    @DisplayName("Should count questions matching search text")
    void shouldCountQuestionsMatchingSearchText() {
        // GIVEN: Request with search text
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .searchText("equation")
                .build();

        // WHEN: Counting matching questions
        long count = questionQueryRepository.countQuestions(
                TEST_USER_ID,
                TEST_QUESTION_BANK_ID,
                request
        );

        // THEN: Should return correct count
        assertThat(count).isEqualTo(2);
    }

    // Helper methods

    private void insertTestQuestionsForTextSearch() {
        Instant now = Instant.now();

        // Q1: Contains "equation" and "solve"
        QuestionDocument q1 = QuestionDocument.builder()
                .questionId(2000000000001L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("Solve the linear equation for x")
                .questionType("MCQ")
                .taxonomy(com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument.builder()
                        .categories(List.of("Math", "Algebra"))
                        .tags(List.of("algebra", "equations"))
                        .quizzes(List.of("midterm-2024"))
                        .build())
                .createdAt(now.minusSeconds(500))
                .updatedAt(now.minusSeconds(500))
                .build();

        // Q2: Contains "circle" and "calculate"
        QuestionDocument q2 = QuestionDocument.builder()
                .questionId(2000000000002L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("Calculate the area of a circle")
                .questionType("MCQ")
                .taxonomy(com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument.builder()
                        .categories(List.of("Math", "Geometry"))
                        .tags(List.of("geometry"))
                        .quizzes(List.of("final-2024"))
                        .build())
                .createdAt(now.minusSeconds(400))
                .updatedAt(now.minusSeconds(400))
                .build();

        // Q3: Contains "capital"
        QuestionDocument q3 = QuestionDocument.builder()
                .questionId(2000000000003L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("What is the capital of France?")
                .questionType("MCQ")
                .taxonomy(com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument.builder()
                        .categories(List.of("Geography"))
                        .tags(List.of("trivia"))
                        .quizzes(List.of("geography-quiz"))
                        .build())
                .createdAt(now.minusSeconds(300))
                .updatedAt(now.minusSeconds(300))
                .build();

        // Q4: Contains "equation" (different from Q1)
        QuestionDocument q4 = QuestionDocument.builder()
                .questionId(2000000000004L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("Simplify the quadratic equation")
                .questionType("MCQ")
                .taxonomy(com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument.builder()
                        .categories(List.of("Math", "Algebra"))
                        .tags(List.of("algebra"))
                        .quizzes(List.of("practice-set"))
                        .build())
                .createdAt(now.minusSeconds(200))
                .updatedAt(now.minusSeconds(200))
                .build();

        // Q5: Generic question for pagination tests
        QuestionDocument q5 = QuestionDocument.builder()
                .questionId(2000000000005L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("This is a generic test question")
                .questionType("MCQ")
                .taxonomy(com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument.builder()
                        .categories(List.of("General"))
                        .tags(List.of("test"))
                        .quizzes(List.of("test-quiz"))
                        .build())
                .createdAt(now.minusSeconds(100))
                .updatedAt(now.minusSeconds(100))
                .build();

        mongoTemplate.insert(q1, COLLECTION_NAME);
        mongoTemplate.insert(q2, COLLECTION_NAME);
        mongoTemplate.insert(q3, COLLECTION_NAME);
        mongoTemplate.insert(q4, COLLECTION_NAME);
        mongoTemplate.insert(q5, COLLECTION_NAME);
    }
}
```

#### Task 1.2: Run Tests (Should FAIL)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=MongoQuestionQueryRepositoryTextSearchTest
```

**Expected Result**: Tests should FAIL because text search is not implemented yet.

---

## Phase 2: GREEN (Make Tests Pass)

### Objective
Implement text search in QueryBuilder and repository.

### Tasks

#### Task 2.1: Update QueryBuilder with Text Search

**File**: Update `QueryBuilder.java`

```java
/**
 * Adds text search filter.
 *
 * @param searchText Search text (case-insensitive, partial matching)
 */
public QueryBuilder withTextSearch(String searchText) {
    if (searchText != null && !searchText.trim().isEmpty()) {
        // MongoDB text search
        criteriaList.add(Criteria.where("question_text").regex(searchText, "i"));
    }
    return this;
}

/**
 * Adds text search from request.
 */
public QueryBuilder withTextSearchFromRequest(QueryQuestionsRequest request) {
    if (request.getSearchText() != null && !request.getSearchText().trim().isEmpty()) {
        withTextSearch(request.getSearchText());
    }
    return this;
}
```

Update the `withTaxonomyFilters` method to include text search:

```java
/**
 * Adds all filters from request (taxonomy and text search).
 */
public QueryBuilder withAllFilters(QueryQuestionsRequest request) {
    withTaxonomyFilters(request);
    withTextSearchFromRequest(request);
    return this;
}
```

#### Task 2.2: Update Repository to Use Text Search

**File**: Update `MongoQuestionQueryRepository.java`

```java
@Override
public List<QuestionDTO> queryQuestions(QueryQuestionsRequest request) {
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(request.getUserId(), request.getQuestionBankId())
            .withAllFilters(request) // Now includes text search
            .withPagination(request.getPage(), request.getSize())
            .withSorting(request.getSortBy(), request.getSortDirection())
            .build();

    List<QuestionDocument> documents = mongoTemplate.find(query, QuestionDocument.class, COLLECTION_NAME);

    return documents.stream()
            .map(mapper::toDTO)
            .toList();
}

@Override
public long countQuestions(Long userId, Long questionBankId, QueryQuestionsRequest request) {
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(userId, questionBankId)
            .withAllFilters(request) // Now includes text search
            .build();

    return mongoTemplate.count(query, QuestionDocument.class, COLLECTION_NAME);
}
```

#### Task 2.3: Run Tests (Should PASS)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=MongoQuestionQueryRepositoryTextSearchTest
```

**Expected Result**: All 12 text search tests should PASS.

---

## Phase 3: REFACTOR (Improve Code Quality)

### Objective
Improve text search implementation with proper MongoDB text indexes and optimize query performance.

### Tasks

#### Task 3.1: Create MongoDB Index Configuration

**File**: `internal-layer/question-bank-query/src/main/java/com/quizfun/questionbankquery/infrastructure/config/MongoIndexConfiguration.java`

```java
package com.quizfun.questionbankquery.infrastructure.config;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.index.TextIndexDefinition;

/**
 * Configuration for MongoDB indexes in the query module.
 *
 * <p>This configuration ensures that required indexes are created on application startup,
 * improving query performance for text search operations.
 */
@Slf4j
@Configuration
@RequiredArgsConstructor
public class MongoIndexConfiguration {

    private final MongoTemplate mongoTemplate;

    private static final String COLLECTION_NAME = "questions";

    /**
     * Creates MongoDB indexes on application startup.
     */
    @PostConstruct
    public void createIndexes() {
        log.info("Creating MongoDB indexes for collection: {}", COLLECTION_NAME);

        // Text index on question_text for full-text search
        TextIndexDefinition textIndex = TextIndexDefinition.builder()
                .onField("question_text")
                .build();

        mongoTemplate.indexOps(COLLECTION_NAME).ensureIndex(textIndex);

        log.info("MongoDB indexes created successfully");
    }
}
```

#### Task 3.2: Add Unit Tests for Text Search in QueryBuilder

**File**: Update `QueryBuilderTest.java`

```java
@Test
@DisplayName("Should build query with text search")
void shouldBuildQueryWithTextSearch() {
    // GIVEN: Search text
    String searchText = "equation";

    // WHEN: Building query with text search
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(1L, 2L)
            .withTextSearch(searchText)
            .build();

    // THEN: Query should have text search criteria
    assertThat(query.getQueryObject()).isNotNull();
    assertThat(query.getQueryObject().toString()).contains("question_text");
}

@Test
@DisplayName("Should ignore null search text")
void shouldIgnoreNullSearchText() {
    // GIVEN: Null search text
    String searchText = null;

    // WHEN: Building query with null text
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(1L, 2L)
            .withTextSearch(searchText)
            .build();

    // THEN: Query should not have text search criteria
    assertThat(query.getQueryObject()).isNotNull();
    assertThat(query.getQueryObject().toString()).doesNotContain("$text");
}

@Test
@DisplayName("Should ignore empty search text")
void shouldIgnoreEmptySearchText() {
    // GIVEN: Empty search text
    String searchText = "   ";

    // WHEN: Building query with empty text
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(1L, 2L)
            .withTextSearch(searchText)
            .build();

    // THEN: Query should not have text search criteria
    assertThat(query.getQueryObject()).isNotNull();
}

@Test
@DisplayName("Should combine text search with taxonomy filters")
void shouldCombineTextSearchWithTaxonomyFilters() {
    // GIVEN: Search text and taxonomy filters
    QueryQuestionsRequest request = QueryQuestionsRequest.builder()
            .userId(12345L)
            .questionBankId(67890L)
            .searchText("equation")
            .categories(List.of("Math"))
            .tags(List.of("algebra"))
            .build();

    // WHEN: Building query with all filters
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(request.getUserId(), request.getQuestionBankId())
            .withAllFilters(request)
            .build();

    // THEN: All filters should be present
    assertThat(query.getQueryObject()).isNotNull();
    String queryString = query.getQueryObject().toString();
    assertThat(queryString).contains("question_text");
    assertThat(queryString).contains("taxonomy.categories");
    assertThat(queryString).contains("taxonomy.tags");
}
```

#### Task 3.3: Add Documentation for Text Search

Update `QueryBuilder.java` Javadoc:

```java
/**
 * <p><strong>Text Search:</strong></p>
 * <ul>
 *   <li>Uses MongoDB regex for flexible text matching (case-insensitive)</li>
 *   <li>Supports partial word matching</li>
 *   <li>Multiple keywords are searched using regex pattern</li>
 *   <li>Empty or null search text is ignored</li>
 * </ul>
 *
 * <p><strong>Performance Considerations:</strong></p>
 * <ul>
 *   <li>Text index on question_text improves search performance</li>
 *   <li>Regex search can be slower for large datasets</li>
 *   <li>Consider using MongoDB Atlas Search for production scale</li>
 * </ul>
 */
```

#### Task 3.4: Run All Tests with Coverage

```bash
mvn clean verify -pl internal-layer/question-bank-query
```

Verify:
- ✅ All tests pass (47+ tests including all previous user stories)
- ✅ JaCoCo coverage > 70%

#### Task 3.5: Generate Allure Report

```bash
mvn allure:report -pl internal-layer/question-bank-query
```

Verify:
- ✅ Story "1014.full-text-search-implementation" appears
- ✅ All 12 text search tests visible
- ✅ All previous user stories tests still passing

---

## Definition of Done

- [ ] Text search implemented with MongoDB regex
- [ ] Text index configuration created
- [ ] Case-insensitive search working
- [ ] Partial word matching working
- [ ] Multiple keyword search working (AND logic)
- [ ] Text search combines with taxonomy filters
- [ ] Empty/null search text is ignored
- [ ] All integration tests pass (12 tests)
- [ ] All unit tests pass
- [ ] JaCoCo coverage >= 70%
- [ ] Allure annotations correctly applied
- [ ] Comprehensive documentation added
- [ ] No Checkstyle violations
- [ ] No SonarLint warnings
- [ ] Code reviewed and approved

---

## Testing Checklist

### Integration Tests
- [ ] ✅ Search by single keyword
- [ ] ✅ Case-insensitive search
- [ ] ✅ Multiple keywords (AND logic)
- [ ] ✅ Partial word matching
- [ ] ✅ Return empty when no matches
- [ ] ✅ Combine with category filter
- [ ] ✅ Combine with tag filter
- [ ] ✅ Combine with all taxonomy filters
- [ ] ✅ Ignore empty search text
- [ ] ✅ Pagination with search
- [ ] ✅ Count with search text

### Unit Tests
- [ ] ✅ QueryBuilder with text search
- [ ] ✅ QueryBuilder ignores null search text
- [ ] ✅ QueryBuilder ignores empty search text
- [ ] ✅ QueryBuilder combines text search with taxonomy

---

## Estimated Effort

- **RED Phase**: 2.5 hours
- **GREEN Phase**: 1.5 hours
- **REFACTOR Phase**: 1.5 hours
- **Total**: 5.5 hours

---

## Dependencies

- **1010.testcontainer-mongodb-setup-and-configuration**: Test infrastructure
- **1011.query-dtos-and-pagination-logic**: DTOs
- **1012.simple-mongodb-query-repository**: Repository foundation
- **1013.complex-taxonomy-filter-aggregation**: Taxonomy filters

---

## Notes

### Text Search Implementation Choices

**Current Implementation (Regex):**
- Pros: Simple, no additional setup, works in all environments
- Cons: Slower for large datasets, limited language features

**Alternative (MongoDB Text Index with $text operator):**
```java
// Using $text operator (production recommendation)
criteriaList.add(Criteria.where("$text").is(searchText));
```
- Pros: Faster, supports stemming, relevance scoring
- Cons: Requires text index, language-specific

**Future Enhancement:**
Consider MongoDB Atlas Search for production-scale full-text search with:
- Advanced linguistic features
- Fuzzy matching
- Synonyms
- Faceted search

### MongoDB Text Index

The `MongoIndexConfiguration` creates a text index automatically:
```javascript
db.questions.createIndex({ "question_text": "text" })
```

This improves query performance significantly for text searches.

### Why Regex for Now?

Using regex provides:
1. **Flexibility**: Works with partial matches
2. **Simplicity**: No complex index management in tests
3. **Compatibility**: Works with Testcontainers and all MongoDB versions
4. **Development Speed**: Faster to implement and test

For production, consider upgrading to `$text` operator with proper text indexes.
