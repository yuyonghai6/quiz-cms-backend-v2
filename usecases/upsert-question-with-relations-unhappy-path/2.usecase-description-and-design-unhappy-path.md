# Use Case Description and Design - Upsert Question Unhappy Path

## Use Case Definition

### Primary Goal
Enhance the existing question upsert system (US-003 through US-007) with security breach protection and user-friendly error messaging, ensuring production-ready security and optimal developer experience.

### Primary Actors
- **Malicious Actor**: Attempting unauthorized access to question banks (external threat)
- **Content Creator**: Experiencing validation errors during question creation/update (legitimate user)
- **API Consumer**: Developer integrating with the question upsert API (legitimate user)
- **System Administrator**: Monitoring security events and system health (internal user)

### Preconditions
- **US-003**: Validation Chain Implementation is operational
- **US-004**: Question Type Strategy Implementation is operational
- **US-005**: Repository Layer Implementation is operational
- **US-007**: Application Service Integration is operational
- Spring Security authentication framework is configured
- MongoDB audit logging capabilities are available

### Success Criteria for Unhappy Path Handling
- **Security Breaches**: All unauthorized access attempts are detected using existing validation chain, logged with comprehensive audit trails, and blocked with minimal impact on legitimate users
- **Validation Errors**: API consumers receive structured error responses with actionable guidance, maintaining consistency with existing `Result<T>` pattern from US-003
- **System Resilience**: System continues operating normally despite attack attempts, with graceful degradation when needed
- **Integration Continuity**: All existing functionality from US-003 through US-007 remains operational
- **Audit Compliance**: Security events are logged using existing patterns and stored with proper retention policies

## Unhappy Path Use Case Scenarios

### 1. Security Breach Risk: Unauthorized Access to Question Banks

#### Scenario 1.1: Path Parameter Manipulation Attack
**Attack Vector**: Malicious user modifies `userId` or `questionbankId` in URL path to access other users' data

**Request Example**:
```http
POST /api/users/1001/questionbanks/2001/questions
Authorization: Bearer jwt_token_for_user_1002
Content-Type: application/json

{
  "source_question_id": "attack-question-123",
  "question_type": "mcq",
  "title": "Attempting unauthorized access",
  ...
}
```

**System Response**:
- **Detection**: Enhanced security validator cross-references JWT token user ID with path parameter
- **Action**: Immediate access denial and security event logging
- **Response**: 403 Forbidden with minimal information to prevent information disclosure

**Response Format**:
```json
{
  "status": "error",
  "error_code": "UNAUTHORIZED_ACCESS",
  "message": "Access denied",
  "timestamp": "2025-09-26T10:30:00Z",
  "request_id": "req_security_violation_123"
}
```

#### Scenario 1.2: Token Privilege Escalation Attack
**Attack Vector**: Valid user token used to access resources beyond authorized scope

**Detection Logic (Integrates with US-003 Validation Chain)**:
```java
@Component
public class SecurityContextValidator extends ValidationHandler {

    private final SecurityAuditLogger auditLogger;
    private final RetryHelper retryHelper; // Reuse from US-003
    private final ValidationChainMetrics metrics; // Reuse from US-003

    public SecurityContextValidator(ValidationHandler next) {
        super(next); // Follows US-003 pattern
    }

    @Override
    public Result<Void> validate(UpsertQuestionCommand command) {
        metrics.startTimer("security_context_validation"); // US-003 pattern

        try {
            // 1. Extract user from JWT token (using Spring Security)
            var authContext = SecurityContextHolder.getContext().getAuthentication();
            Long tokenUserId = Long.valueOf(authContext.getName());

            // 2. Compare with command user ID
            if (!tokenUserId.equals(command.getUserId())) {
                auditLogger.logSecurityViolation(
                    tokenUserId,
                    command.getUserId(),
                    SecurityEventType.PATH_PARAMETER_MANIPULATION
                );
                // Use existing ValidationErrorCode from US-003
                return Result.failure("User ID mismatch detected", ValidationErrorCode.UNAUTHORIZED_ACCESS);
            }

            // 3. Validate question bank ownership (enhanced version of existing validator)
            var ownershipResult = retryHelper.executeWithRetry(() ->
                questionBankRepository.validateOwnership(
                    command.getUserId(),
                    command.getQuestionBankId()
                ),
                "ownership_validation"
            );

            if (!ownershipResult || !ownershipResult) {
                auditLogger.logSecurityViolation(
                    command.getUserId(),
                    command.getQuestionBankId(),
                    SecurityEventType.UNAUTHORIZED_ACCESS_ATTEMPT
                );
                return Result.failure("Access denied to question bank", ValidationErrorCode.QUESTION_BANK_ACCESS_DENIED);
            }

            return checkNext(command); // Continue chain as per US-003 pattern

        } finally {
            metrics.endTimer("security_context_validation");
        }
    }
}
```

#### Scenario 1.3: Session Hijacking Detection
**Attack Vector**: Stolen or intercepted authentication tokens used maliciously

**Detection Mechanisms**:
- IP address validation against session creation IP
- User-Agent string consistency checking
- Geolocation anomaly detection
- Concurrent session violation detection

**Implementation**:
```java
@Component
public class SessionSecurityValidator {

    public Result<Void> validateSessionIntegrity(UpsertQuestionCommand command, HttpServletRequest request) {
        var sessionContext = sessionContextService.getSessionContext(command.getSessionId());

        // Check IP consistency
        String currentIp = getClientIpAddress(request);
        if (!sessionContext.getOriginatingIp().equals(currentIp)) {
            auditLogger.logSuspiciousActivity(
                command.getUserId(),
                SecurityEventType.SESSION_HIJACKING_ATTEMPT,
                Map.of("originalIp", sessionContext.getOriginatingIp(), "currentIp", currentIp)
            );

            // Flag for additional verification but don't block immediately
            sessionContext.flagForAdditionalVerification();
        }

        // Check for concurrent sessions from different locations
        if (sessionContextService.hasConcurrentSessionsFromDifferentLocations(command.getUserId())) {
            auditLogger.logSuspiciousActivity(
                command.getUserId(),
                SecurityEventType.CONCURRENT_SESSION_VIOLATION,
                Map.of("sessionCount", sessionContextService.getActiveSessionCount(command.getUserId()))
            );
        }

        return Result.success(null);
    }
}
```

### 2. Type-Specific Validation Error Messages

#### Scenario 2.1: MCQ Question Validation Failures

**Common MCQ Validation Issues**:

##### 2.1.1: Insufficient Options Error
**User Input**:
```json
{
  "question_type": "mcq",
  "title": "JavaScript Array Method",
  "mcq_data": {
    "options": [
      {"text": "push()", "is_correct": true}
    ],
    "multiple_correct_allowed": false
  }
}
```

**Enhanced Error Response**:
```json
{
  "status": "error",
  "error_code": "INSUFFICIENT_MCQ_OPTIONS",
  "title": "MCQ Must Have At Least 2 Options",
  "message": "Your MCQ question has 1 option(s), but requires at least 2. Multiple choice questions need at least two options for users to choose from.",
  "details": {
    "field": "mcq_data.options",
    "provided_count": 1,
    "minimum_required": 2,
    "question_type": "mcq"
  },
  "suggestions": [
    "Add at least one more option to your mcq_data.options array",
    "Each option should have 'text' and 'is_correct' properties",
    "Consider adding 3-4 options for better question quality",
    "Ensure at least one option is marked as correct"
  ],
  "example": {
    "mcq_data": {
      "options": [
        {"text": "push()", "is_correct": true},
        {"text": "pop()", "is_correct": false},
        {"text": "shift()", "is_correct": false}
      ]
    }
  },
  "documentation_url": "https://docs.example.com/question-types/mcq#validation-rules",
  "timestamp": "2025-09-26T10:30:00Z",
  "request_id": "req_mcq_validation_456"
}
```

##### 2.1.2: No Correct Answer Error
**User Input**:
```json
{
  "question_type": "mcq",
  "mcq_data": {
    "options": [
      {"text": "push()", "is_correct": false},
      {"text": "pop()", "is_correct": false},
      {"text": "shift()", "is_correct": false}
    ]
  }
}
```

**Enhanced Error Response**:
```json
{
  "status": "error",
  "error_code": "NO_CORRECT_MCQ_ANSWER",
  "title": "MCQ Missing Correct Answer",
  "message": "Your multiple choice question doesn't have any correct answers marked. Students need at least one correct option to choose from.",
  "details": {
    "field": "mcq_data.options[].is_correct",
    "total_options": 3,
    "correct_options": 0,
    "required_correct_options": "at least 1"
  },
  "suggestions": [
    "Set 'is_correct': true for at least one option in your mcq_data.options array",
    "Review your question to determine which option(s) should be correct",
    "If multiple answers are correct, set 'multiple_correct_allowed': true",
    "Double-check your question content matches the correct answer"
  ],
  "example": {
    "mcq_data": {
      "options": [
        {"text": "push()", "is_correct": true},
        {"text": "pop()", "is_correct": false},
        {"text": "shift()", "is_correct": false}
      ]
    }
  },
  "documentation_url": "https://docs.example.com/question-types/mcq#correct-answers",
  "timestamp": "2025-09-26T10:30:00Z"
}
```

#### Scenario 2.2: Essay Question Validation Failures

##### 2.2.1: Invalid Word Count Range Error
**User Input**:
```json
{
  "question_type": "essay",
  "essay_data": {
    "min_words": 500,
    "max_words": 200,
    "scored": true
  }
}
```

**Enhanced Error Response**:
```json
{
  "status": "error",
  "error_code": "INVALID_WORD_COUNT_RANGE",
  "title": "Invalid Word Count Range",
  "message": "The minimum word count (500) cannot be greater than the maximum word count (200). This would make it impossible for students to submit valid answers.",
  "details": {
    "field": "essay_data",
    "min_words": 500,
    "max_words": 200,
    "issue": "min_words > max_words"
  },
  "suggestions": [
    "Set max_words to a value greater than min_words (e.g., max_words: 750)",
    "Alternatively, reduce min_words to be less than max_words (e.g., min_words: 150)",
    "Consider typical essay lengths: short essays (100-300 words), medium essays (300-600 words)",
    "Remove word limits entirely by setting both min_words and max_words to null if not needed"
  ],
  "example": {
    "essay_data": {
      "min_words": 200,
      "max_words": 500,
      "scored": true
    }
  },
  "documentation_url": "https://docs.example.com/question-types/essay#word-count-limits",
  "timestamp": "2025-09-26T10:30:00Z"
}
```

##### 2.2.2: Missing Rubric for Scored Essay
**User Input**:
```json
{
  "question_type": "essay",
  "essay_data": {
    "scored": true,
    "min_words": 200,
    "max_words": 500
  }
}
```

**Enhanced Error Response**:
```json
{
  "status": "error",
  "error_code": "MISSING_ESSAY_RUBRIC",
  "title": "Scored Essay Missing Rubric",
  "message": "Essays with scoring enabled require a rubric to define how responses will be evaluated. Without a rubric, the system cannot score student responses.",
  "details": {
    "field": "essay_data.rubric",
    "scored": true,
    "rubric_provided": false,
    "required_when": "scored = true"
  },
  "suggestions": [
    "Add a 'rubric' object to your essay_data with scoring criteria",
    "Include criteria such as 'content', 'grammar', 'structure' with point values",
    "Alternatively, set 'scored': false if no scoring is needed",
    "Consider using a simple rubric with 3-5 criteria for easier grading"
  ],
  "example": {
    "essay_data": {
      "scored": true,
      "rubric": {
        "criteria": [
          {"name": "Content Quality", "max_points": 40, "description": "Accuracy and depth of response"},
          {"name": "Grammar & Style", "max_points": 30, "description": "Writing quality and clarity"},
          {"name": "Structure", "max_points": 30, "description": "Organization and flow"}
        ],
        "total_points": 100
      }
    }
  },
  "documentation_url": "https://docs.example.com/question-types/essay#rubric-requirements",
  "timestamp": "2025-09-26T10:30:00Z"
}
```

#### Scenario 2.3: True/False Question Validation Failures

##### 2.3.1: Missing True/False Data
**User Input**:
```json
{
  "question_type": "true_false",
  "title": "JavaScript arrays are objects",
  "content": "<p>In JavaScript, arrays are a type of object.</p>"
}
```

**Enhanced Error Response**:
```json
{
  "status": "error",
  "error_code": "MISSING_TRUE_FALSE_DATA",
  "title": "True/False Question Missing Required Data",
  "message": "True/False questions require 'true_false_data' field with the correct answer and optional explanation.",
  "details": {
    "field": "true_false_data",
    "question_type": "true_false",
    "required_fields": ["correct_answer"],
    "optional_fields": ["explanation", "time_limit_seconds"]
  },
  "suggestions": [
    "Add 'true_false_data' object to your request",
    "Set 'correct_answer' to either true or false based on your question",
    "Consider adding an 'explanation' to help students understand the correct answer",
    "Optionally set a 'time_limit_seconds' for timed questions"
  ],
  "example": {
    "true_false_data": {
      "correct_answer": true,
      "explanation": "In JavaScript, arrays are indeed objects with special properties and methods for handling ordered collections of data.",
      "time_limit_seconds": 30
    }
  },
  "documentation_url": "https://docs.example.com/question-types/true-false#data-requirements",
  "timestamp": "2025-09-26T10:30:00Z"
}
```

## API Specification for Unhappy Paths

### Security Error Response Format

**HTTP Status Codes for Security Issues**:
- `401 Unauthorized`: Invalid or missing authentication
- `403 Forbidden`: Valid authentication but insufficient permissions
- `429 Too Many Requests`: Rate limiting triggered

**Standard Security Error Response**:
```json
{
  "status": "error",
  "error_code": "SECURITY_VIOLATION_CODE",
  "message": "Brief, non-revealing error message",
  "timestamp": "2025-09-26T10:30:00Z",
  "request_id": "req_security_12345"
}
```

### Validation Error Response Format

**HTTP Status Code for Validation Issues**:
- `422 Unprocessable Entity`: Request syntax is valid but contains validation errors

**Enhanced Validation Error Response**:
```json
{
  "status": "error",
  "error_code": "VALIDATION_ERROR_CODE",
  "title": "Human-Friendly Error Title",
  "message": "Detailed explanation of the issue",
  "details": {
    "field": "specific.field.path",
    "provided_value": "what_was_provided",
    "expected": "what_was_expected"
  },
  "suggestions": [
    "Actionable step 1 to fix the issue",
    "Actionable step 2 to fix the issue",
    "Alternative approach if applicable"
  ],
  "example": {
    "corrected_field": "example of correct format"
  },
  "documentation_url": "https://docs.example.com/relevant-section",
  "timestamp": "2025-09-26T10:30:00Z",
  "request_id": "req_validation_67890"
}
```

## Implementation Design Patterns

### 1. Enhanced Security Validator Chain

```java
@Component
public class SecurityValidatorChain {

    private final List<SecurityValidator> validators;

    public SecurityValidationResult validateRequest(
        UpsertQuestionCommand command,
        HttpServletRequest request,
        SecurityContext securityContext) {

        var result = new SecurityValidationResult();

        for (SecurityValidator validator : validators) {
            var validatorResult = validator.validate(command, request, securityContext);

            if (validatorResult.isSecurityViolation()) {
                // Log security violation immediately
                auditLogger.logSecurityViolation(validatorResult);

                // Apply immediate defensive measures
                securityDefenseService.applyDefensiveMeasures(validatorResult);

                return validatorResult;
            }

            if (validatorResult.isSuspicious()) {
                result.addSuspiciousActivity(validatorResult);
            }
        }

        return result;
    }
}
```

### 2. Error Message Builder Pattern

```java
@Component
public class UserFriendlyErrorMessageBuilder {

    private final MessageSource messageSource;
    private final DocumentationUrlService documentationUrlService;

    public ErrorResponse buildValidationError(
        ValidationErrorCode errorCode,
        ValidationContext context,
        Locale locale) {

        return ErrorResponse.builder()
            .errorCode(errorCode.name())
            .title(messageSource.getMessage(errorCode.getTitleKey(), null, locale))
            .message(buildContextualMessage(errorCode, context, locale))
            .details(extractRelevantDetails(context))
            .suggestions(buildActionableSuggestions(errorCode, context, locale))
            .example(buildCorrectionExample(errorCode, context))
            .documentationUrl(documentationUrlService.getRelevantUrl(errorCode))
            .timestamp(Instant.now())
            .requestId(context.getRequestId())
            .build();
    }

    private String buildContextualMessage(ValidationErrorCode errorCode, ValidationContext context, Locale locale) {
        var messageKey = errorCode.getMessageKey();
        var messageArgs = extractMessageArguments(context);
        return messageSource.getMessage(messageKey, messageArgs, locale);
    }

    private List<String> buildActionableSuggestions(ValidationErrorCode errorCode, ValidationContext context, Locale locale) {
        var suggestions = new ArrayList<String>();

        // Add error-specific suggestions
        var suggestionKeys = errorCode.getSuggestionKeys();
        for (String suggestionKey : suggestionKeys) {
            suggestions.add(messageSource.getMessage(suggestionKey, null, locale));
        }

        // Add context-specific suggestions
        if (context.hasContextualSuggestions()) {
            suggestions.addAll(context.getContextualSuggestions());
        }

        return suggestions;
    }
}
```

### 3. Security Event Publisher

```java
@Component
public class SecurityEventPublisher {

    private final ApplicationEventPublisher eventPublisher;
    private final SecurityEventEnricher eventEnricher;

    @Async
    public void publishSecurityEvent(SecurityEvent event) {
        // Enrich event with additional context
        var enrichedEvent = eventEnricher.enrichEvent(event);

        // Publish to internal event bus
        eventPublisher.publishEvent(enrichedEvent);

        // Send to external security systems if critical
        if (event.getSeverity() == SeverityLevel.CRITICAL) {
            externalSecuritySystemsClient.sendAlert(enrichedEvent);
        }

        // Update security metrics
        securityMetricsService.recordSecurityEvent(enrichedEvent);
    }
}
```

## Business Rules for Unhappy Path Handling

### Security Business Rules

1. **Zero Trust Principle**: Every request is validated regardless of authentication status
2. **Fail Secure**: When in doubt, deny access and log the attempt
3. **Defense in Depth**: Multiple layers of security validation
4. **Immediate Response**: Security violations trigger immediate defensive measures
5. **Complete Audit Trail**: All security events are logged with full context
6. **Rate Limiting**: Suspicious activity triggers progressive rate limiting

### Validation Error Business Rules

1. **User-Centric Messaging**: Error messages prioritize user understanding over technical accuracy
2. **Actionable Guidance**: Every error includes specific steps to resolve the issue
3. **Progressive Disclosure**: Basic error first, detailed information available on request
4. **Example-Driven**: Provide concrete examples of correct formats
5. **Documentation Integration**: Link to relevant documentation sections
6. **Contextual Suggestions**: Tailor suggestions based on the specific validation failure

### Error Response Business Rules

1. **Consistent Format**: All error responses follow the same structured format
2. **Severity Classification**: Errors are classified by severity (INFO, WARNING, ERROR, CRITICAL)
3. **Request Tracking**: Every error response includes a unique request ID for support
4. **Localization Support**: Error messages support internationalization
5. **Privacy Protection**: Error messages never expose sensitive system information
6. **Development Friendly**: Include enough detail for API consumers to debug issues

This design ensures comprehensive protection against security threats while providing exceptional user experience through clear, actionable error messaging.