# User Story 1013: Complex Taxonomy Filter with MongoDB Aggregation

## User Story

**As a** backend developer
**I want** to implement complex taxonomy filtering using MongoDB aggregation pipelines
**So that** users can filter questions by categories (AND logic), tags (OR logic), and quizzes (OR logic)

## Acceptance Criteria

- [ ] Repository supports category filtering with AND logic across hierarchical levels
- [ ] Repository supports tag filtering with OR logic (at least one must match)
- [ ] Repository supports quiz filtering with OR logic (at least one must match)
- [ ] Combined filters use AND logic between different types (categories AND tags AND quizzes)
- [ ] Aggregation pipeline correctly implements the filter logic
- [ ] Filters work with pagination and sorting
- [ ] Empty filter lists are ignored (don't filter)
- [ ] Integration tests verify all filter combinations
- [ ] All tests pass with JaCoCo coverage > 70%
- [ ] Allure annotations correctly applied

---

## TDD Cycle

### Allure Annotations Format

```java
@Epic("Use Case Query List of Questions of Question Bank")
@Story("1013.complex-taxonomy-filter-aggregation")
```

---

## Phase 1: RED (Write Failing Tests)

### Objective
Write failing tests for taxonomy filter combinations.

### Tasks

#### Task 1.1: Create Integration Tests for Taxonomy Filters

**File**: `internal-layer/question-bank-query/src/test/java/com/quizfun/questionbankquery/infrastructure/persistence/repositories/MongoQuestionQueryRepositoryTaxonomyFiltersTest.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.repositories;

import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.ports.out.IQuestionQueryRepository;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.TaxonomyDocument;
import io.qameta.allure.Epic;
import io.qameta.allure.Story;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MongoDBContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.Instant;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@Epic("Use Case Query List of Questions of Question Bank")
@Story("1013.complex-taxonomy-filter-aggregation")
@Testcontainers
@SpringBootTest
@DisplayName("Taxonomy Filter Integration Tests")
class MongoQuestionQueryRepositoryTaxonomyFiltersTest {

    @Container
    static MongoDBContainer mongoContainer = new MongoDBContainer("mongo:8.0")
            .withExposedPorts(27018)
            .withReuse(false);

    @DynamicPropertySource
    static void mongoProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoContainer::getReplicaSetUrl);
        registry.add("spring.data.mongodb.read-preference", () -> "primary");
    }

    @Autowired
    private MongoTemplate mongoTemplate;

    @Autowired
    private IQuestionQueryRepository questionQueryRepository;

    private static final Long TEST_USER_ID = 12345L;
    private static final Long TEST_QUESTION_BANK_ID = 67890L;
    private static final String COLLECTION_NAME = "questions";

    @BeforeEach
    void setUp() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
        mongoTemplate.createCollection(COLLECTION_NAME);
        insertTestQuestionsWithTaxonomy();
    }

    @AfterEach
    void tearDown() {
        mongoTemplate.dropCollection(COLLECTION_NAME);
    }

    @Test
    @DisplayName("Should filter by single category (AND logic)")
    void shouldFilterBySingleCategory() {
        // GIVEN: Request with single category
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Math"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions with Math category
        assertThat(results).hasSize(2); // Q1: Math>Algebra, Q2: Math>Geometry
        assertThat(results).extracting(QuestionDTO::questionText)
                .containsExactlyInAnyOrder("Solve for x", "Calculate area of circle");
    }

    @Test
    @DisplayName("Should filter by hierarchical categories (AND logic across levels)")
    void shouldFilterByHierarchicalCategories() {
        // GIVEN: Request with hierarchical categories
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Math", "Algebra"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return only questions matching BOTH levels
        assertThat(results).hasSize(1); // Only Q1: Math>Algebra
        assertThat(results.getFirst().questionText()).isEqualTo("Solve for x");
    }

    @Test
    @DisplayName("Should filter by multiple categories requiring all (AND logic)")
    void shouldFilterByMultipleCategoriesRequiringAll() {
        // GIVEN: Request with three category levels
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Math", "Algebra", "Linear Equations"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return only questions matching ALL three levels
        assertThat(results).hasSize(1); // Only Q1: Math>Algebra>Linear Equations
        assertThat(results.getFirst().questionText()).isEqualTo("Solve for x");
    }

    @Test
    @DisplayName("Should filter by tags (OR logic)")
    void shouldFilterByTags() {
        // GIVEN: Request with multiple tags
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .tags(List.of("equations", "beginner"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions matching ANY tag (OR logic)
        assertThat(results).hasSize(2); // Q1: equations, Q3: beginner
        assertThat(results).extracting(QuestionDTO::questionText)
                .containsExactlyInAnyOrder("Solve for x", "What is 2 + 2?");
    }

    @Test
    @DisplayName("Should filter by single tag")
    void shouldFilterBySingleTag() {
        // GIVEN: Request with single tag
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .tags(List.of("geometry"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions with that tag
        assertThat(results).hasSize(1); // Only Q2: geometry
        assertThat(results.getFirst().questionText()).isEqualTo("Calculate area of circle");
    }

    @Test
    @DisplayName("Should filter by quizzes (OR logic)")
    void shouldFilterByQuizzes() {
        // GIVEN: Request with multiple quizzes
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .quizzes(List.of("midterm-2024", "practice-set-1"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions in ANY quiz (OR logic)
        assertThat(results).hasSize(2); // Q1: midterm-2024, Q3: practice-set-1
        assertThat(results).extracting(QuestionDTO::questionText)
                .containsExactlyInAnyOrder("Solve for x", "What is 2 + 2?");
    }

    @Test
    @DisplayName("Should combine category and tag filters (AND logic between types)")
    void shouldCombineCategoryAndTagFilters() {
        // GIVEN: Request with both category and tag filters
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Math"))
                .tags(List.of("equations"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions matching BOTH filters
        assertThat(results).hasSize(1); // Only Q1: Math + equations
        assertThat(results.getFirst().questionText()).isEqualTo("Solve for x");
    }

    @Test
    @DisplayName("Should combine category, tag, and quiz filters (AND logic between all)")
    void shouldCombineCategoryTagAndQuizFilters() {
        // GIVEN: Request with all three filter types
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Math"))
                .tags(List.of("equations"))
                .quizzes(List.of("midterm-2024"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return questions matching ALL filters
        assertThat(results).hasSize(1); // Only Q1: Math + equations + midterm-2024
        assertThat(results.getFirst().questionText()).isEqualTo("Solve for x");
    }

    @Test
    @DisplayName("Should return no results when filters don't match any question")
    void shouldReturnNoResultsWhenFiltersDoNotMatch() {
        // GIVEN: Request with non-matching filters
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Science"))
                .tags(List.of("chemistry"))
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return empty list
        assertThat(results).isEmpty();
    }

    @Test
    @DisplayName("Should ignore empty filter lists")
    void shouldIgnoreEmptyFilterLists() {
        // GIVEN: Request with empty filter lists
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of())
                .tags(List.of())
                .quizzes(List.of())
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying questions
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should return all questions (no filtering)
        assertThat(results).hasSize(4); // All test questions
    }

    @Test
    @DisplayName("Should work with pagination when filtering")
    void shouldWorkWithPaginationWhenFiltering() {
        // GIVEN: Request with filter and pagination
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Math"))
                .page(0)
                .size(1)
                .build();

        // WHEN: Querying first page
        List<QuestionDTO> page1 = questionQueryRepository.queryQuestions(request);

        // THEN: Should return one result
        assertThat(page1).hasSize(1);

        // AND: Second page should return another result
        QueryQuestionsRequest request2 = request.toBuilder().page(1).build();
        List<QuestionDTO> page2 = questionQueryRepository.queryQuestions(request2);
        assertThat(page2).hasSize(1);
        assertThat(page2.getFirst().questionId()).isNotEqualTo(page1.getFirst().questionId());
    }

    @Test
    @DisplayName("Should work with sorting when filtering")
    void shouldWorkWithSortingWhenFiltering() {
        // GIVEN: Request with filter and sorting
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .tags(List.of("equations", "beginner"))
                .sortBy("questionText")
                .sortDirection("asc")
                .page(0)
                .size(10)
                .build();

        // WHEN: Querying with sort
        List<QuestionDTO> results = questionQueryRepository.queryQuestions(request);

        // THEN: Should be sorted alphabetically
        assertThat(results).hasSize(2);
        assertThat(results.get(0).questionText()).isEqualTo("Solve for x");
        assertThat(results.get(1).questionText()).isEqualTo("What is 2 + 2?");
    }

    @Test
    @DisplayName("Should count filtered questions correctly")
    void shouldCountFilteredQuestionsCorrectly() {
        // GIVEN: Questions with category filter
        QueryQuestionsRequest request = QueryQuestionsRequest.builder()
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .categories(List.of("Math"))
                .build();

        // WHEN: Counting filtered questions
        long count = questionQueryRepository.countQuestions(
                TEST_USER_ID,
                TEST_QUESTION_BANK_ID,
                request
        );

        // THEN: Should return correct count
        assertThat(count).isEqualTo(2); // Q1 and Q2
    }

    // Helper method to insert test questions with taxonomy

    private void insertTestQuestionsWithTaxonomy() {
        Instant now = Instant.now();

        // Q1: Math > Algebra > Linear Equations, tags: [equations], quizzes: [midterm-2024]
        QuestionDocument q1 = QuestionDocument.builder()
                .questionId(1000000000001L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("Solve for x")
                .questionType("MCQ")
                .taxonomy(TaxonomyDocument.builder()
                        .categories(List.of("Math", "Algebra", "Linear Equations"))
                        .tags(List.of("equations"))
                        .quizzes(List.of("midterm-2024"))
                        .build())
                .createdAt(now.minusSeconds(400))
                .updatedAt(now.minusSeconds(400))
                .build();

        // Q2: Math > Geometry, tags: [geometry], quizzes: [final-2024]
        QuestionDocument q2 = QuestionDocument.builder()
                .questionId(1000000000002L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("Calculate area of circle")
                .questionType("MCQ")
                .taxonomy(TaxonomyDocument.builder()
                        .categories(List.of("Math", "Geometry"))
                        .tags(List.of("geometry"))
                        .quizzes(List.of("final-2024"))
                        .build())
                .createdAt(now.minusSeconds(300))
                .updatedAt(now.minusSeconds(300))
                .build();

        // Q3: Science > Physics, tags: [beginner], quizzes: [practice-set-1]
        QuestionDocument q3 = QuestionDocument.builder()
                .questionId(1000000000003L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("What is 2 + 2?")
                .questionType("MCQ")
                .taxonomy(TaxonomyDocument.builder()
                        .categories(List.of("Science", "Physics"))
                        .tags(List.of("beginner"))
                        .quizzes(List.of("practice-set-1"))
                        .build())
                .createdAt(now.minusSeconds(200))
                .updatedAt(now.minusSeconds(200))
                .build();

        // Q4: History > World War II, tags: [advanced], quizzes: [history-quiz]
        QuestionDocument q4 = QuestionDocument.builder()
                .questionId(1000000000004L)
                .userId(TEST_USER_ID)
                .questionBankId(TEST_QUESTION_BANK_ID)
                .questionText("When did WWII end?")
                .questionType("MCQ")
                .taxonomy(TaxonomyDocument.builder()
                        .categories(List.of("History", "World War II"))
                        .tags(List.of("advanced"))
                        .quizzes(List.of("history-quiz"))
                        .build())
                .createdAt(now.minusSeconds(100))
                .updatedAt(now.minusSeconds(100))
                .build();

        mongoTemplate.insert(q1, COLLECTION_NAME);
        mongoTemplate.insert(q2, COLLECTION_NAME);
        mongoTemplate.insert(q3, COLLECTION_NAME);
        mongoTemplate.insert(q4, COLLECTION_NAME);
    }
}
```

#### Task 1.2: Update Repository Interface with Count Overload

**File**: Update `IQuestionQueryRepository.java`

```java
/**
 * Counts total number of questions matching the filters.
 *
 * @param userId User ID
 * @param questionBankId Question Bank ID
 * @param request Request with filters
 * @return Total count of matching questions
 */
long countQuestions(Long userId, Long questionBankId, QueryQuestionsRequest request);
```

#### Task 1.3: Add toBuilder() to QueryQuestionsRequest

**File**: Update `QueryQuestionsRequest.java`

Add `toBuilder = true` to the `@Builder` annotation:

```java
@Getter
@Builder(toBuilder = true)
public class QueryQuestionsRequest {
    // ... existing fields
}
```

#### Task 1.4: Run Tests (Should FAIL)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=MongoQuestionQueryRepositoryTaxonomyFiltersTest
```

**Expected Result**: Tests should FAIL because taxonomy filtering is not implemented yet.

---

## Phase 2: GREEN (Make Tests Pass)

### Objective
Implement MongoDB aggregation pipeline for taxonomy filters.

### Tasks

#### Task 2.1: Extend QueryBuilder with Taxonomy Filters

**File**: Update `QueryBuilder.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.repositories;

import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;

import java.util.ArrayList;
import java.util.List;

/**
 * Builder for MongoDB queries with fluent API including taxonomy filters.
 */
public class QueryBuilder {

    private static final String FIELD_USER_ID = "user_id";
    private static final String FIELD_QUESTION_BANK_ID = "question_bank_id";
    private static final String FIELD_CREATED_AT = "created_at";
    private static final String FIELD_UPDATED_AT = "updated_at";
    private static final String FIELD_QUESTION_TEXT = "question_text";
    private static final String FIELD_TAXONOMY_CATEGORIES = "taxonomy.categories";
    private static final String FIELD_TAXONOMY_TAGS = "taxonomy.tags";
    private static final String FIELD_TAXONOMY_QUIZZES = "taxonomy.quizzes";

    private final Query query;
    private final List<Criteria> criteriaList;

    private QueryBuilder() {
        this.query = new Query();
        this.criteriaList = new ArrayList<>();
    }

    public static QueryBuilder create() {
        return new QueryBuilder();
    }

    /**
     * Adds userId and questionBankId filters.
     */
    public QueryBuilder withUserAndQuestionBank(Long userId, Long questionBankId) {
        criteriaList.add(Criteria.where(FIELD_USER_ID).is(userId));
        criteriaList.add(Criteria.where(FIELD_QUESTION_BANK_ID).is(questionBankId));
        return this;
    }

    /**
     * Adds category filters (AND logic - all must match).
     */
    public QueryBuilder withCategories(List<String> categories) {
        if (categories != null && !categories.isEmpty()) {
            // All categories must exist in the array (AND logic)
            criteriaList.add(Criteria.where(FIELD_TAXONOMY_CATEGORIES).all(categories));
        }
        return this;
    }

    /**
     * Adds tag filters (OR logic - at least one must match).
     */
    public QueryBuilder withTags(List<String> tags) {
        if (tags != null && !tags.isEmpty()) {
            // At least one tag must match (OR logic)
            criteriaList.add(Criteria.where(FIELD_TAXONOMY_TAGS).in(tags));
        }
        return this;
    }

    /**
     * Adds quiz filters (OR logic - at least one must match).
     */
    public QueryBuilder withQuizzes(List<String> quizzes) {
        if (quizzes != null && !quizzes.isEmpty()) {
            // At least one quiz must match (OR logic)
            criteriaList.add(Criteria.where(FIELD_TAXONOMY_QUIZZES).in(quizzes));
        }
        return this;
    }

    /**
     * Adds all taxonomy filters from request.
     */
    public QueryBuilder withTaxonomyFilters(QueryQuestionsRequest request) {
        withCategories(request.getCategories());
        withTags(request.getTags());
        withQuizzes(request.getQuizzes());
        return this;
    }

    /**
     * Adds pagination (skip and limit).
     */
    public QueryBuilder withPagination(int page, int size) {
        int skip = page * size;
        query.skip(skip).limit(size);
        return this;
    }

    /**
     * Adds sorting.
     */
    public QueryBuilder withSorting(String sortBy, String sortDirection) {
        Sort.Direction direction = "asc".equalsIgnoreCase(sortDirection)
                ? Sort.Direction.ASC
                : Sort.Direction.DESC;

        String sortField = mapSortField(sortBy);
        query.with(Sort.by(direction, sortField));
        return this;
    }

    /**
     * Builds and returns the Query object.
     */
    public Query build() {
        if (!criteriaList.isEmpty()) {
            Criteria combinedCriteria = new Criteria().andOperator(
                    criteriaList.toArray(new Criteria[0])
            );
            query.addCriteria(combinedCriteria);
        }
        return query;
    }

    /**
     * Maps logical sort field names to MongoDB document field names.
     */
    private String mapSortField(String sortBy) {
        return switch (sortBy) {
            case "createdAt" -> FIELD_CREATED_AT;
            case "updatedAt" -> FIELD_UPDATED_AT;
            case "questionText" -> FIELD_QUESTION_TEXT;
            default -> FIELD_CREATED_AT;
        };
    }
}
```

#### Task 2.2: Update Repository Implementation

**File**: Update `MongoQuestionQueryRepository.java`

```java
package com.quizfun.questionbankquery.infrastructure.persistence.repositories;

import com.quizfun.questionbankquery.application.dto.QuestionDTO;
import com.quizfun.questionbankquery.application.dto.QueryQuestionsRequest;
import com.quizfun.questionbankquery.application.ports.out.IQuestionQueryRepository;
import com.quizfun.questionbankquery.infrastructure.persistence.documents.QuestionDocument;
import com.quizfun.questionbankquery.infrastructure.persistence.mappers.QuestionDocumentMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * MongoDB implementation of question query repository with taxonomy filters.
 */
@Repository
@RequiredArgsConstructor
public class MongoQuestionQueryRepository implements IQuestionQueryRepository {

    private final MongoTemplate mongoTemplate;
    private final QuestionDocumentMapper mapper;

    private static final String COLLECTION_NAME = "questions";

    @Override
    public List<QuestionDTO> queryQuestions(QueryQuestionsRequest request) {
        Query query = QueryBuilder.create()
                .withUserAndQuestionBank(request.getUserId(), request.getQuestionBankId())
                .withTaxonomyFilters(request)
                .withPagination(request.getPage(), request.getSize())
                .withSorting(request.getSortBy(), request.getSortDirection())
                .build();

        List<QuestionDocument> documents = mongoTemplate.find(query, QuestionDocument.class, COLLECTION_NAME);

        return documents.stream()
                .map(mapper::toDTO)
                .toList();
    }

    @Override
    public long countQuestions(Long userId, Long questionBankId) {
        Query query = QueryBuilder.create()
                .withUserAndQuestionBank(userId, questionBankId)
                .build();

        return mongoTemplate.count(query, QuestionDocument.class, COLLECTION_NAME);
    }

    @Override
    public long countQuestions(Long userId, Long questionBankId, QueryQuestionsRequest request) {
        Query query = QueryBuilder.create()
                .withUserAndQuestionBank(userId, questionBankId)
                .withTaxonomyFilters(request)
                .build();

        return mongoTemplate.count(query, QuestionDocument.class, COLLECTION_NAME);
    }
}
```

#### Task 2.3: Run Tests (Should PASS)

```bash
mvn clean test -pl internal-layer/question-bank-query -Dtest=MongoQuestionQueryRepositoryTaxonomyFiltersTest
```

**Expected Result**: All 13 taxonomy filter tests should PASS.

---

## Phase 3: REFACTOR (Improve Code Quality)

### Objective
Improve test coverage, add unit tests for QueryBuilder taxonomy methods.

### Tasks

#### Task 3.1: Add Unit Tests for Taxonomy Filters in QueryBuilder

**File**: Update `QueryBuilderTest.java`

```java
@Test
@DisplayName("Should build query with category filters (AND logic)")
void shouldBuildQueryWithCategoryFilters() {
    // GIVEN: Multiple categories
    List<String> categories = List.of("Math", "Algebra", "Linear Equations");

    // WHEN: Building query with categories
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(1L, 2L)
            .withCategories(categories)
            .build();

    // THEN: Query should have category filter with all operator
    assertThat(query.getQueryObject()).isNotNull();
    assertThat(query.getQueryObject().toString()).contains("taxonomy.categories");
}

@Test
@DisplayName("Should build query with tag filters (OR logic)")
void shouldBuildQueryWithTagFilters() {
    // GIVEN: Multiple tags
    List<String> tags = List.of("equations", "beginner");

    // WHEN: Building query with tags
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(1L, 2L)
            .withTags(tags)
            .build();

    // THEN: Query should have tag filter with in operator
    assertThat(query.getQueryObject()).isNotNull();
    assertThat(query.getQueryObject().toString()).contains("taxonomy.tags");
}

@Test
@DisplayName("Should build query with quiz filters (OR logic)")
void shouldBuildQueryWithQuizFilters() {
    // GIVEN: Multiple quizzes
    List<String> quizzes = List.of("midterm-2024", "practice-set-1");

    // WHEN: Building query with quizzes
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(1L, 2L)
            .withQuizzes(quizzes)
            .build();

    // THEN: Query should have quiz filter with in operator
    assertThat(query.getQueryObject()).isNotNull();
    assertThat(query.getQueryObject().toString()).contains("taxonomy.quizzes");
}

@Test
@DisplayName("Should build query with all taxonomy filters combined")
void shouldBuildQueryWithAllTaxonomyFiltersCombined() {
    // GIVEN: All taxonomy filters
    List<String> categories = List.of("Math");
    List<String> tags = List.of("equations");
    List<String> quizzes = List.of("midterm-2024");

    // WHEN: Building query with all filters
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(1L, 2L)
            .withCategories(categories)
            .withTags(tags)
            .withQuizzes(quizzes)
            .build();

    // THEN: Query should have all filters
    assertThat(query.getQueryObject()).isNotNull();
    String queryString = query.getQueryObject().toString();
    assertThat(queryString).contains("taxonomy.categories");
    assertThat(queryString).contains("taxonomy.tags");
    assertThat(queryString).contains("taxonomy.quizzes");
}

@Test
@DisplayName("Should ignore empty taxonomy filter lists")
void shouldIgnoreEmptyTaxonomyFilterLists() {
    // GIVEN: Empty filter lists
    List<String> emptyList = List.of();

    // WHEN: Building query with empty lists
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(1L, 2L)
            .withCategories(emptyList)
            .withTags(emptyList)
            .withQuizzes(emptyList)
            .build();

    // THEN: Query should only have user and question bank filters
    assertThat(query.getQueryObject()).isNotNull();
    String queryString = query.getQueryObject().toString();
    assertThat(queryString).contains("user_id");
    assertThat(queryString).contains("question_bank_id");
    // Should not contain taxonomy fields
    assertThat(queryString).doesNotContain("taxonomy.categories");
    assertThat(queryString).doesNotContain("taxonomy.tags");
    assertThat(queryString).doesNotContain("taxonomy.quizzes");
}

@Test
@DisplayName("Should build query from QueryQuestionsRequest with taxonomy filters")
void shouldBuildQueryFromRequestWithTaxonomyFilters() {
    // GIVEN: Request with taxonomy filters
    QueryQuestionsRequest request = QueryQuestionsRequest.builder()
            .userId(12345L)
            .questionBankId(67890L)
            .categories(List.of("Math"))
            .tags(List.of("equations"))
            .quizzes(List.of("midterm-2024"))
            .page(0)
            .size(20)
            .build();

    // WHEN: Building query from request
    Query query = QueryBuilder.create()
            .withUserAndQuestionBank(request.getUserId(), request.getQuestionBankId())
            .withTaxonomyFilters(request)
            .withPagination(request.getPage(), request.getSize())
            .build();

    // THEN: All filters should be applied
    assertThat(query.getQueryObject()).isNotNull();
    assertThat(query.getSkip()).isZero();
    assertThat(query.getLimit()).isEqualTo(20);
}
```

#### Task 3.2: Add Documentation for Taxonomy Filter Logic

Add comprehensive Javadoc to `QueryBuilder.java`:

```java
/**
 * Builder for MongoDB queries with fluent API including taxonomy filters.
 *
 * <p><strong>Taxonomy Filter Logic:</strong></p>
 * <ul>
 *   <li><strong>Categories:</strong> AND logic - ALL categories must exist in the document's category array
 *       (uses MongoDB $all operator). Example: ["Math", "Algebra"] requires BOTH in categories array.</li>
 *   <li><strong>Tags:</strong> OR logic - AT LEAST ONE tag must match any tag in the document's tag array
 *       (uses MongoDB $in operator). Example: ["equations", "beginner"] matches if ANY tag matches.</li>
 *   <li><strong>Quizzes:</strong> OR logic - AT LEAST ONE quiz must match any quiz in the document's quiz array
 *       (uses MongoDB $in operator). Example: ["midterm-2024", "final-2024"] matches if ANY quiz matches.</li>
 *   <li><strong>Combined:</strong> AND logic between different filter types - ALL filter types must be satisfied
 *       if specified. Example: categories AND tags AND quizzes all must match.</li>
 * </ul>
 *
 * <p><strong>MongoDB Operators Used:</strong></p>
 * <ul>
 *   <li>$all: Categories (requires all values to be present in array)</li>
 *   <li>$in: Tags and Quizzes (matches if any value is in array)</li>
 *   <li>$and: Combines all criteria (user, questionBank, categories, tags, quizzes)</li>
 * </ul>
 *
 * @see org.springframework.data.mongodb.core.query.Criteria#all(Object...)
 * @see org.springframework.data.mongodb.core.query.Criteria#in(Object...)
 * @see org.springframework.data.mongodb.core.query.Criteria#andOperator(Criteria...)
 */
```

#### Task 3.3: Run All Tests with Coverage

```bash
mvn clean verify -pl internal-layer/question-bank-query
```

Verify:
- ✅ All tests pass (including previous user stories)
- ✅ JaCoCo coverage > 70%

#### Task 3.4: Generate Allure Report

```bash
mvn allure:report -pl internal-layer/question-bank-query
```

Verify:
- ✅ Story "1013.complex-taxonomy-filter-aggregation" appears in report
- ✅ All 13 taxonomy filter tests visible
- ✅ All previous tests still passing

---

## Definition of Done

- [ ] Taxonomy filter logic implemented (categories AND, tags OR, quizzes OR)
- [ ] Combined filters use AND logic between types
- [ ] Empty filter lists are ignored
- [ ] Filters work with pagination and sorting
- [ ] Count method supports filters
- [ ] All integration tests pass (13 tests)
- [ ] All unit tests pass
- [ ] JaCoCo coverage >= 70%
- [ ] Allure annotations correctly applied
- [ ] Comprehensive documentation added
- [ ] No Checkstyle violations
- [ ] No SonarLint warnings
- [ ] Code reviewed and approved

---

## Testing Checklist

### Integration Tests
- [ ] ✅ Filter by single category
- [ ] ✅ Filter by hierarchical categories (AND logic)
- [ ] ✅ Filter by three category levels (all AND)
- [ ] ✅ Filter by tags (OR logic)
- [ ] ✅ Filter by single tag
- [ ] ✅ Filter by quizzes (OR logic)
- [ ] ✅ Combine category and tag filters (AND between types)
- [ ] ✅ Combine all three filter types (AND between all)
- [ ] ✅ Return empty when filters don't match
- [ ] ✅ Ignore empty filter lists
- [ ] ✅ Work with pagination when filtering
- [ ] ✅ Work with sorting when filtering
- [ ] ✅ Count filtered questions correctly

### Unit Tests
- [ ] ✅ QueryBuilder with category filters
- [ ] ✅ QueryBuilder with tag filters
- [ ] ✅ QueryBuilder with quiz filters
- [ ] ✅ QueryBuilder with all taxonomy filters combined
- [ ] ✅ QueryBuilder ignores empty lists
- [ ] ✅ QueryBuilder from QueryQuestionsRequest

---

## Estimated Effort

- **RED Phase**: 3 hours
- **GREEN Phase**: 2 hours
- **REFACTOR Phase**: 1.5 hours
- **Total**: 6.5 hours

---

## Dependencies

- **1010.testcontainer-mongodb-setup-and-configuration**: Test infrastructure
- **1011.query-dtos-and-pagination-logic**: DTOs
- **1012.simple-mongodb-query-repository**: Basic repository foundation

---

## Notes

### MongoDB Operators Explained

- **`$all`**: Matches arrays that contain ALL specified elements (order doesn't matter)
  ```javascript
  { "taxonomy.categories": { "$all": ["Math", "Algebra"] } }
  // Matches: ["Math", "Algebra", "Linear Equations"]
  // Doesn't match: ["Math", "Geometry"]
  ```

- **`$in`**: Matches if ANY value in the specified list appears in the array
  ```javascript
  { "taxonomy.tags": { "$in": ["equations", "beginner"] } }
  // Matches: ["equations", "advanced"]
  // Matches: ["beginner"]
  // Doesn't match: ["expert", "geometry"]
  ```

### Why This Logic?

- **Categories** use AND because hierarchical taxonomy requires matching all levels
- **Tags/Quizzes** use OR for flexibility - users want to find questions with ANY of the specified tags
- **Between types** AND logic narrows results to precisely match user intent
