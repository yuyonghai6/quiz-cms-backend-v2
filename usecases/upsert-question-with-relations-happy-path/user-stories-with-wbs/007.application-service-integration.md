# US-007: Application Service Integration

## Story Overview
**As a** content creator
**I want** coordinated business operations with transaction support
**So that** question upsert operations are atomic and maintain data consistency across multiple collections

## Business Value
- Ensures ACID compliance across multiple MongoDB collections
- Coordinates validation, domain logic, and persistence operations
- Provides single entry point for complete business workflow
- Maintains data consistency through proper transaction management

## Work Breakdown Structure (WBS)

### 1. Application Service Design and Structure
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: US-003, US-004, US-005, US-006 complete

#### Tasks:
- [ ] **1.1** Design QuestionApplicationService class structure
- [ ] **1.2** Define constructor injection dependencies
- [ ] **1.3** Plan method signatures and contracts
- [ ] **1.4** Add comprehensive logging framework
- [ ] **1.5** Design error handling strategy

#### Implementation Details:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/application/services/QuestionApplicationService.java
@Service
@Transactional
public class QuestionApplicationService {

    private static final Logger logger = LoggerFactory.getLogger(QuestionApplicationService.class);

    private final ValidationHandler validationChain;
    private final QuestionTypeStrategyFactory strategyFactory;
    private final QuestionRepository questionRepository;
    private final QuestionTaxonomyRelationshipRepository relationshipRepository;

    public QuestionApplicationService(
            ValidationHandler validationChain,
            QuestionTypeStrategyFactory strategyFactory,
            QuestionRepository questionRepository,
            QuestionTaxonomyRelationshipRepository relationshipRepository) {

        this.validationChain = validationChain;
        this.strategyFactory = strategyFactory;
        this.questionRepository = questionRepository;
        this.relationshipRepository = relationshipRepository;

        logger.info("QuestionApplicationService initialized with dependencies: " +
                   "validation chain, strategy factory, question repository, relationship repository");
    }

    @Transactional(
        isolation = Isolation.READ_COMMITTED,
        propagation = Propagation.REQUIRED,
        rollbackFor = Exception.class
    )
    public Result<QuestionResponseDto> upsertQuestion(UpsertQuestionCommand command) {
        // Implementation in subsequent tasks
    }
}
```

#### Acceptance Criteria:
- Constructor injection used for all dependencies (as specified in requirements)
- Service marked as @Transactional for MongoDB transaction support
- Comprehensive logging configured
- Clear separation of concerns in method design

#### Test Requirements:
- [ ] Unit test: constructor injection functionality
- [ ] Unit test: service instantiation with mocked dependencies

---

### 2. Validation Chain Integration
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 1, US-003 Validation Chain complete

#### Tasks:
- [ ] **2.1** Integrate validation chain execution
- [ ] **2.2** Handle fail-fast validation behavior
- [ ] **2.3** Add validation timing and metrics
- [ ] **2.4** Implement validation error propagation
- [ ] **2.5** Add validation context logging

#### Implementation Details:
```java
// Addition to QuestionApplicationService
public Result<QuestionResponseDto> upsertQuestion(UpsertQuestionCommand command) {
    var timer = Timer.start();

    try {
        logger.info("Starting question upsert process for source ID: {} by user: {} in question bank: {}",
                   command.getSourceQuestionId(), command.getUserId(), command.getQuestionBankId());

        // Step 1: Execute validation chain (fail-fast)
        logger.debug("Executing validation chain for source ID: {}", command.getSourceQuestionId());
        var validationResult = validationChain.validate(command);

        if (validationResult.isFailure()) {
            logger.warn("Validation failed for source ID: {} with error: {}",
                       command.getSourceQuestionId(), validationResult.getError());

            // Record validation failure metrics
            recordValidationFailure(validationResult.getError());

            return Result.failure(validationResult.getError());
        }

        logger.debug("Validation chain passed for source ID: {}", command.getSourceQuestionId());
        recordValidationSuccess();

        // Continue to next step...

    } catch (Exception ex) {
        logger.error("Unexpected error during question upsert for source ID: {}",
                    command.getSourceQuestionId(), ex);
        return Result.failure("UPSERT_ERROR", "Unexpected error during question upsert: " + ex.getMessage());
    } finally {
        var duration = timer.stop();
        logger.debug("Validation chain execution took: {}ms for source ID: {}",
                    duration.toMillis(), command.getSourceQuestionId());
    }
}

private void recordValidationSuccess() {
    // Metrics recording for monitoring
}

private void recordValidationFailure(String errorCode) {
    // Metrics recording for monitoring
}
```

#### Acceptance Criteria:
- Validation chain executes first in the workflow
- Fail-fast behavior stops processing on validation failure
- Validation timing and metrics recorded
- Comprehensive logging for debugging

#### Test Requirements:
- [ ] Unit test: successful validation chain execution
- [ ] Unit test: validation failure handling and error propagation
- [ ] Unit test: validation timing measurement

---

### 3. Question Strategy Processing Integration
**Estimated Effort**: 0.5 days
**Priority**: High
**Dependencies**: Task 2, US-004 Strategy Pattern complete

#### Tasks:
- [ ] **3.1** Integrate question type strategy processing
- [ ] **3.2** Handle strategy selection and execution
- [ ] **3.3** Add strategy processing error handling
- [ ] **3.4** Implement aggregate instantiation logic
- [ ] **3.5** Add strategy performance monitoring

#### Implementation Details:
```java
// Continuation of upsertQuestion method
// Step 2: Process question using Strategy Pattern
logger.debug("Processing question data using strategy for type: {} and source ID: {}",
            command.getQuestionType(), command.getSourceQuestionId());

var strategy = strategyFactory.getStrategy(command.getQuestionType());
var questionAggregateResult = strategy.processQuestionData(command);

if (questionAggregateResult.isFailure()) {
    logger.warn("Strategy processing failed for source ID: {} with error: {}",
               command.getSourceQuestionId(), questionAggregateResult.getError());

    recordStrategyFailure(command.getQuestionType().toString(), questionAggregateResult.getError());

    return Result.failure(questionAggregateResult.getError());
}

var questionAggregate = questionAggregateResult.getValue();
logger.debug("Successfully processed question data for source ID: {} using {} strategy",
            command.getSourceQuestionId(), strategy.getStrategyName());

recordStrategySuccess(command.getQuestionType().toString());

// Validate aggregate state
if (!questionAggregate.hasValidTypeSpecificData()) {
    logger.error("Strategy produced invalid aggregate for source ID: {}",
                command.getSourceQuestionId());
    return Result.failure("INVALID_AGGREGATE", "Strategy produced invalid question aggregate");
}
```

#### Acceptance Criteria:
- Strategy factory correctly selects and executes appropriate strategy
- Strategy processing errors properly handled and logged
- QuestionAggregate instantiated correctly (as specified in requirements)
- Aggregate validation ensures data integrity

#### Test Requirements:
- [ ] Unit test: successful strategy processing for all question types
- [ ] Unit test: strategy processing failure handling
- [ ] Unit test: aggregate validation after strategy processing

---

### 4. Question Repository Integration and Transaction Management
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: Task 3, US-005 Repository Layer complete

#### Tasks:
- [ ] **4.1** Integrate question repository upsert operation
- [ ] **4.2** Implement MongoDB transaction configuration
- [ ] **4.3** Handle aggregate instantiation and storage
- [ ] **4.4** Add repository operation error handling
- [ ] **4.5** Implement transaction rollback scenarios

#### Implementation Details:
```java
// Continuation of upsertQuestion method
// Step 3: Instantiate QuestionAggregate object and store to MongoDB
logger.debug("Upserting question aggregate for source ID: {}", command.getSourceQuestionId());

var questionResult = questionRepository.upsertBySourceQuestionId(questionAggregate);

if (questionResult.isFailure()) {
    logger.error("Question repository upsert failed for source ID: {} with error: {}",
                command.getSourceQuestionId(), questionResult.getError());

    recordRepositoryFailure("question", questionResult.getError());

    // Transaction will automatically rollback due to @Transactional annotation
    return Result.failure(questionResult.getError());
}

var persistedQuestionAggregate = questionResult.getValue();
logger.debug("Successfully upserted question with MongoDB ID: {} for source ID: {}",
            persistedQuestionAggregate.getId(), command.getSourceQuestionId());

recordRepositorySuccess("question");

// Ensure we have a valid MongoDB ID for relationships
if (persistedQuestionAggregate.getId() == null) {
    logger.error("Persisted question has null MongoDB ID for source ID: {}",
                command.getSourceQuestionId());
    return Result.failure("INVALID_QUESTION_ID", "Question was persisted but has no MongoDB ID");
}
```

#### MongoDB Transaction Configuration:
```java
// Location: internal-layer/question-bank/src/main/java/com/quizfun/questionbank/infrastructure/configuration/MongoTransactionConfig.java
@Configuration
@EnableTransactionManagement
public class MongoTransactionConfig {

    @Bean
    public MongoTransactionManager transactionManager(MongoDatabaseFactory factory) {
        return new MongoTransactionManager(factory);
    }

    @Bean
    @Profile("test")
    public MongoTransactionManager testTransactionManager() {
        // TestContainers specific configuration
        var mongoContainer = TestContainersConfig.getMongoContainer();
        var factory = new SimpleMongoClientDatabaseFactory(
            MongoClients.create(mongoContainer.getReplicaSetUrl()),
            "quiz_cms_test"
        );
        return new MongoTransactionManager(factory);
    }
}
```

#### Acceptance Criteria:
- Question aggregate instantiated and stored correctly to MongoDB
- MongoDB transaction manager configured properly
- Transaction rollback works on any failure
- Repository error handling maintains transaction integrity

#### Test Requirements:
- [ ] Unit test: successful question repository upsert
- [ ] Unit test: repository failure and transaction rollback
- [ ] Integration test: MongoDB transaction behavior
- [ ] Integration test: transaction rollback on repository failure

---

### 5. Relationship Management Integration
**Estimated Effort**: 1 day
**Priority**: High
**Dependencies**: Task 4, US-006 Supporting Aggregates complete

#### Tasks:
- [ ] **5.1** Integrate relationship aggregate creation
- [ ] **5.2** Implement relationship repository operations
- [ ] **5.3** Handle multi-document insertion to MongoDB
- [ ] **5.4** Add relationship operation error handling
- [ ] **5.5** Ensure transactional consistency across collections

#### Implementation Details:
```java
// Continuation of upsertQuestion method
// Step 4: Instantiate QuestionTaxonomyRelationshipAggregate objects
logger.debug("Creating taxonomy relationships for question ID: {}", persistedQuestionAggregate.getId());

var relationships = QuestionTaxonomyRelationshipAggregate.createFromCommand(
    persistedQuestionAggregate.getId(), command);

logger.debug("Created {} taxonomy relationships for question ID: {}",
            relationships.size(), persistedQuestionAggregate.getId());

// Step 5: Insert multiple relationship documents to MongoDB (transactional)
// This part follows requirement: "do insert multiple documents to mongodb:
// for each question to every single taxonomy mapping, add one document"
var relationshipResult = relationshipRepository.replaceRelationshipsForQuestion(
    persistedQuestionAggregate.getId(), relationships);

if (relationshipResult.isFailure()) {
    logger.error("Relationship repository operation failed for question ID: {} with error: {}",
                persistedQuestionAggregate.getId(), relationshipResult.getError());

    recordRepositoryFailure("relationships", relationshipResult.getError());

    // Transaction will automatically rollback, undoing both question and relationship operations
    return Result.failure(relationshipResult.getError());
}

logger.debug("Successfully managed {} taxonomy relationships for question ID: {}",
            relationships.size(), persistedQuestionAggregate.getId());

recordRepositorySuccess("relationships");

// Step 6: Return success response
var responseDto = mapToResponseDto(persistedQuestionAggregate, relationships.size());
logger.info("Successfully completed question upsert for source ID: {} with operation: {}",
           command.getSourceQuestionId(), responseDto.getOperation());

return Result.success(responseDto);
```

#### Acceptance Criteria:
- Multiple relationship documents inserted to question_taxonomy_relationships collection
- Relationship operations participate in the same transaction as question operations
- Transaction rollback removes both question and relationship data on failure
- All taxonomy mappings create individual relationship documents

#### Test Requirements:
- [ ] Unit test: relationship aggregate creation from command
- [ ] Unit test: relationship repository operation success
- [ ] Unit test: relationship repository operation failure and rollback
- [ ] Integration test: complete transaction across both collections
- [ ] Integration test: relationship count matches taxonomy elements

---

### 6. Response Mapping and Completion
**Estimated Effort**: 0.5 days
**Priority**: Medium
**Dependencies**: Task 5 complete

#### Tasks:
- [ ] **6.1** Implement response DTO mapping
- [ ] **6.2** Add operation type detection (created vs updated)
- [ ] **6.3** Include relationship count in response
- [ ] **6.4** Add timing and performance metrics
- [ ] **6.5** Complete transaction and cleanup

#### Implementation Details:
```java
// Addition to QuestionApplicationService
private QuestionResponseDto mapToResponseDto(QuestionAggregate aggregate, int relationshipCount) {
    return QuestionResponseDto.builder()
        .questionId(aggregate.getId().toString())
        .sourceQuestionId(aggregate.getSourceQuestionId())
        .operation(determineOperation(aggregate))
        .taxonomyRelationshipsCount(relationshipCount)
        .build();
}

private String determineOperation(QuestionAggregate aggregate) {
    // Check if creation and update timestamps are the same (new question)
    // or if the question was actually updated
    return aggregate.getCreatedAt().equals(aggregate.getUpdatedAt()) ? "created" : "updated";
}

// Metrics recording methods
private void recordRepositorySuccess(String operation) {
    // Implementation for monitoring
}

private void recordRepositoryFailure(String operation, String error) {
    // Implementation for monitoring
}

private void recordStrategySuccess(String questionType) {
    // Implementation for monitoring
}

private void recordStrategyFailure(String questionType, String error) {
    // Implementation for monitoring
}
```

#### Acceptance Criteria:
- Response DTO includes operation type (created/updated)
- Relationship count accurately reflects created relationships
- Response contains all required information for client
- Performance metrics captured for monitoring

#### Test Requirements:
- [ ] Unit test: response DTO mapping for created question
- [ ] Unit test: response DTO mapping for updated question
- [ ] Unit test: relationship count accuracy in response

---

## Acceptance Criteria Summary

### Functional Requirements
- [ ] Application service coordinates validation, strategy processing, and persistence
- [ ] MongoDB transactions ensure ACID compliance across questions and relationships collections
- [ ] Constructor injection used for all dependencies as specified
- [ ] Question and relationship aggregates instantiated and stored correctly
- [ ] Complete business workflow executed with proper error handling

### Non-Functional Requirements
- [ ] Complete upsert operation completes within 500ms for typical requests
- [ ] Transaction overhead adds <50ms to operation time
- [ ] Memory usage <100MB during transaction processing
- [ ] Thread-safe service implementation

### Definition of Done
- [ ] QuestionApplicationService with complete business workflow implemented
- [ ] MongoDB transaction configuration working correctly
- [ ] All components integrated and working together
- [ ] Transaction rollback behavior verified
- [ ] Comprehensive error handling for all scenarios
- [ ] Performance monitoring and logging implemented
- [ ] Unit and integration tests covering all paths

## Dependencies and Risks

### Dependencies
- US-003 Validation Chain implementation
- US-004 Question Type Strategy implementation
- US-005 Repository Layer implementation
- US-006 Supporting Aggregates implementation
- MongoDB transaction manager configuration

### Risks
- **Risk**: MongoDB transaction performance overhead
  **Mitigation**: Optimize transaction scope and monitor performance

- **Risk**: Complex error handling across multiple operations
  **Mitigation**: Clear error propagation strategy and comprehensive testing

- **Risk**: Transaction rollback complexity
  **Mitigation**: Thorough testing of rollback scenarios

## Testing Strategy

### Unit Testing
- Individual service method testing with mocked dependencies
- Error scenario coverage for all integration points
- Transaction boundary testing
- Response mapping accuracy

### Integration Testing
- Complete business workflow with real dependencies
- MongoDB transaction behavior verification
- Error propagation and rollback testing
- Performance benchmarking under load

### Test Data Requirements
- Valid commands for all question types
- Invalid commands for error scenario testing
- Complex taxonomy scenarios for relationship testing
- Performance test datasets

## Technical Notes

### Design Patterns Used
- **Application Service Pattern**: Coordinated business workflow
- **Transaction Script**: ACID transaction management
- **Dependency Injection**: Constructor-based injection
- **Result Pattern**: Consistent error handling

### Performance Considerations
- Transaction scope optimization
- Efficient repository operations
- Minimal object creation during processing
- Performance monitoring and metrics

### Security Considerations
- User authorization through validation chain
- Data isolation through repository scoping
- Transaction integrity for data consistency
- Comprehensive audit logging for security events